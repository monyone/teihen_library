<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="generator" content="pandoc">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
						<!-- <title></title> -->
		<title>Teihen Library</title>
		<style type="text/css">code{white-space: pre;}</style>
		<!--[if lt IE 9]>
				<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
				<![endif]-->
						<style type="text/css">
			div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
		</style>
						<link href="data:text/css;charset=utf-8,body%20%7B%0Afont%2Dfamily%3A%20%27Lucida%20Grande%27%2C%20%27Hiragino%20Kaku%20Gothic%20ProN%27%2C%20%27Yu%20Gothic%27%2C%20Meiryo%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2016px%3B%0Aline%2Dheight%3A%201%2E6%3B%0Abackground%2Dcolor%3A%20white%3B%0Amargin%3A%200em%3B%0Apadding%3A%201px%3B%0A%7D%0Abody%20%3E%20%2A%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%20%21important%3B%0A%7D%0Abody%20%3E%20%2A%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%20%21important%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%234183C4%3B%20%7D%0Aa%2Eabsent%20%7B%0Acolor%3A%20%23cc0000%3B%20%7D%0Aa%2Eanchor%20%7B%0Adisplay%3A%20block%3B%0Apadding%2Dleft%3A%2030px%3B%0Amargin%2Dleft%3A%20%2D30px%3B%0Acursor%3A%20pointer%3B%0Aposition%3A%20absolute%3B%0Atop%3A%200%3B%0Aleft%3A%200%3B%0Abottom%3A%200%3B%20%7D%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0Amargin%3A%2020px%200%2010px%3B%0Apadding%3A%200%3B%0Afont%2Dweight%3A%20bold%3B%0A%2Dwebkit%2Dfont%2Dsmoothing%3A%20antialiased%3B%0Acursor%3A%20text%3B%0Aposition%3A%20relative%3B%20%7D%0Ah1%3Ahover%20a%2Eanchor%2C%20h2%3Ahover%20a%2Eanchor%2C%20h3%3Ahover%20a%2Eanchor%2C%20h4%3Ahover%20a%2Eanchor%2C%20h5%3Ahover%20a%2Eanchor%2C%20h6%3Ahover%20a%2Eanchor%20%7B%0Abackground%3A%20url%28%27data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8%2F9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw%2FeHBhY2tldCBiZWdpbj0i77u%2FIiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8%2BIDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI%2FPsQhXeAAAABfSURBVHjaYvz%2F%2Fz8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg%3D%3D%27%29%20no%2Drepeat%2010px%20center%3B%0Atext%2Ddecoration%3A%20none%3B%20%7D%0Ah1%20tt%2C%20h1%20code%20%7B%0Afont%2Dsize%3A%20inherit%3B%20%7D%0Ah2%20tt%2C%20h2%20code%20%7B%0Afont%2Dsize%3A%20inherit%3B%20%7D%0Ah3%20tt%2C%20h3%20code%20%7B%0Afont%2Dsize%3A%20inherit%3B%20%7D%0AW%20h4%20tt%2C%20h4%20code%20%7B%0Afont%2Dsize%3A%20inherit%3B%20%7D%0Ah5%20tt%2C%20h5%20code%20%7B%0Afont%2Dsize%3A%20inherit%3B%20%7D%0Ah6%20tt%2C%20h6%20code%20%7B%0Afont%2Dsize%3A%20inherit%3B%20%7D%0Ah1%20%7B%0Afont%2Dsize%3A%2028px%3B%0Acolor%3A%20black%3B%20%7D%0Ah2%20%7B%0Afont%2Dsize%3A%2024px%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23cccccc%3B%0Acolor%3A%20black%3B%20%7D%0Ah3%20%7B%0Afont%2Dsize%3A%2018px%3B%20%7D%0Ah4%20%7B%0Afont%2Dsize%3A%2016px%3B%20%7D%0Ah5%20%7B%0Afont%2Dsize%3A%2014px%3B%20%7D%0Ah6%20%7B%0Acolor%3A%20%23777777%3B%0Afont%2Dsize%3A%2014px%3B%20%7D%0Ap%2C%20blockquote%2C%20ul%2C%20ol%2C%20dl%2C%20li%2C%20table%2C%20pre%20%7B%0Amargin%3A%2015px%200%3B%20%7D%0Ahr%20%7B%0Abackground%3A%20transparent%20url%28%27data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw%2FeHBhY2tldCBiZWdpbj0i77u%2FIiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8%2BIDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI%2FPqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC%27%29%20repeat%2Dx%200%200%3B%0Aborder%3A%200%20none%3B%0Acolor%3A%20%23cccccc%3B%0Aheight%3A%204px%3B%0Apadding%3A%200%3B%20%7D%0Abody%20%3E%20h2%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%20%7D%0Abody%20%3E%20h1%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%20%7D%0Abody%20%3E%20h1%3Afirst%2Dchild%20%2B%20h2%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%20%7D%0Abody%20%3E%20h3%3Afirst%2Dchild%2C%20body%20%3E%20h4%3Afirst%2Dchild%2C%20body%20%3E%20h5%3Afirst%2Dchild%2C%20body%20%3E%20h6%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%20%7D%0Aa%3Afirst%2Dchild%20h1%2C%20a%3Afirst%2Dchild%20h2%2C%20a%3Afirst%2Dchild%20h3%2C%20a%3Afirst%2Dchild%20h4%2C%20a%3Afirst%2Dchild%20h5%2C%20a%3Afirst%2Dchild%20h6%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%20%7D%0Ah1%20p%2C%20h2%20p%2C%20h3%20p%2C%20h4%20p%2C%20h5%20p%2C%20h6%20p%20%7B%0Amargin%2Dtop%3A%200%3B%20%7D%0Ali%20p%2Efirst%20%7B%0Adisplay%3A%20inline%2Dblock%3B%20%7D%0Aul%2C%20ol%20%7B%0Apadding%2Dleft%3A%2030px%3B%20%7D%0Aul%20%3Afirst%2Dchild%2C%20ol%20%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%20%7D%0Aul%20%3Alast%2Dchild%2C%20ol%20%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%20%7D%0Adl%20%7B%0Apadding%3A%200%3B%20%7D%0Adl%20dt%20%7B%0Afont%2Dsize%3A%2014px%3B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dstyle%3A%20italic%3B%0Apadding%3A%200%3B%0Amargin%3A%2015px%200%205px%3B%20%7D%0Adl%20dt%3Afirst%2Dchild%20%7B%0Apadding%3A%200%3B%20%7D%0Adl%20dt%20%3E%20%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%20%7D%0Adl%20dt%20%3E%20%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%20%7D%0Adl%20dd%20%7B%0Amargin%3A%200%200%2015px%3B%0Apadding%3A%200%2015px%3B%20%7D%0Adl%20dd%20%3E%20%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%20%7D%0Adl%20dd%20%3E%20%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%20%7D%0Ablockquote%20%7B%0Aborder%2Dleft%3A%204px%20solid%20%23dddddd%3B%0Apadding%3A%200%2015px%3B%0Acolor%3A%20%23777777%3B%20%7D%0Ablockquote%20%3E%20%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%20%7D%0Ablockquote%20%3E%20%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%20%7D%0Atable%20%7B%0Apadding%3A%200%3B%20%7D%0Atable%20tr%20%7B%0Aborder%2Dtop%3A%201px%20solid%20%23cccccc%3B%0Abackground%2Dcolor%3A%20white%3B%0Amargin%3A%200%3B%0Apadding%3A%200%3B%20%7D%0Atable%20tr%3Anth%2Dchild%282n%29%20%7B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%20%7D%0Atable%20tr%20th%20%7B%0Afont%2Dweight%3A%20bold%3B%0Aborder%3A%201px%20solid%20%23cccccc%3B%0Atext%2Dalign%3A%20left%3B%0Amargin%3A%200%3B%0Apadding%3A%206px%2013px%3B%20%7D%0Atable%20tr%20td%20%7B%0Aborder%3A%201px%20solid%20%23cccccc%3B%0Atext%2Dalign%3A%20left%3B%0Amargin%3A%200%3B%0Apadding%3A%206px%2013px%3B%20%7D%0Atable%20tr%20th%20%3Afirst%2Dchild%2C%20table%20tr%20td%20%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%20%7D%0Atable%20tr%20th%20%3Alast%2Dchild%2C%20table%20tr%20td%20%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%20%7D%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%3B%20%7D%0Aspan%2Eframe%20%7B%0Adisplay%3A%20block%3B%0Aoverflow%3A%20hidden%3B%20%7D%0Aspan%2Eframe%20%3E%20span%20%7B%0Aborder%3A%201px%20solid%20%23dddddd%3B%0Adisplay%3A%20block%3B%0Afloat%3A%20left%3B%0Aoverflow%3A%20hidden%3B%0Amargin%3A%2013px%200%200%3B%0Apadding%3A%207px%3B%0Awidth%3A%20auto%3B%20%7D%0Aspan%2Eframe%20span%20img%20%7B%0Adisplay%3A%20block%3B%0Afloat%3A%20left%3B%20%7D%0Aspan%2Eframe%20span%20span%20%7B%0Aclear%3A%20both%3B%0Acolor%3A%20%23333333%3B%0Adisplay%3A%20block%3B%0Apadding%3A%205px%200%200%3B%20%7D%0Aspan%2Ealign%2Dcenter%20%7B%0Adisplay%3A%20block%3B%0Aoverflow%3A%20hidden%3B%0Aclear%3A%20both%3B%20%7D%0Aspan%2Ealign%2Dcenter%20%3E%20span%20%7B%0Adisplay%3A%20block%3B%0Aoverflow%3A%20hidden%3B%0Amargin%3A%2013px%20auto%200%3B%0Atext%2Dalign%3A%20center%3B%20%7D%0Aspan%2Ealign%2Dcenter%20span%20img%20%7B%0Amargin%3A%200%20auto%3B%0Atext%2Dalign%3A%20center%3B%20%7D%0Aspan%2Ealign%2Dright%20%7B%0Adisplay%3A%20block%3B%0Aoverflow%3A%20hidden%3B%0Aclear%3A%20both%3B%20%7D%0Aspan%2Ealign%2Dright%20%3E%20span%20%7B%0Adisplay%3A%20block%3B%0Aoverflow%3A%20hidden%3B%0Amargin%3A%2013px%200%200%3B%0Atext%2Dalign%3A%20right%3B%20%7D%0Aspan%2Ealign%2Dright%20span%20img%20%7B%0Amargin%3A%200%3B%0Atext%2Dalign%3A%20right%3B%20%7D%0Aspan%2Efloat%2Dleft%20%7B%0Adisplay%3A%20block%3B%0Amargin%2Dright%3A%2013px%3B%0Aoverflow%3A%20hidden%3B%0Afloat%3A%20left%3B%20%7D%0Aspan%2Efloat%2Dleft%20span%20%7B%0Amargin%3A%2013px%200%200%3B%20%7D%0Aspan%2Efloat%2Dright%20%7B%0Adisplay%3A%20block%3B%0Amargin%2Dleft%3A%2013px%3B%0Aoverflow%3A%20hidden%3B%0Afloat%3A%20right%3B%20%7D%0Aspan%2Efloat%2Dright%20%3E%20span%20%7B%0Adisplay%3A%20block%3B%0Aoverflow%3A%20hidden%3B%0Amargin%3A%2013px%20auto%200%3B%0Atext%2Dalign%3A%20right%3B%20%7D%0Acode%2C%20tt%20%7B%0Amargin%3A%200%202px%3B%0Apadding%3A%200%205px%3B%0Awhite%2Dspace%3A%20nowrap%3B%0Aborder%3A%201px%20solid%20%23eaeaea%3B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0Aborder%2Dradius%3A%203px%3B%20%7D%0Apre%20code%20%7B%0Amargin%3A%200%3B%0Apadding%3A%200%3B%0Awhite%2Dspace%3A%20pre%3B%0Aborder%3A%20none%3B%0Abackground%3A%20transparent%3B%0Afont%2Dfamily%3A%20Ricty%2C%20%22Ricty%20Diminished%22%2C%20Meiryo%2C%20%22MS%20Gothic%22%2C%20sans%2Dserif%3B%0A%7D%0A%2Ehighlight%20pre%20%7B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0Aborder%3A%201px%20solid%20%23cccccc%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%2019px%3B%0Aoverflow%3A%20auto%3B%0Apadding%3A%206px%2010px%3B%0Aborder%2Dradius%3A%203px%3B%20%7D%0Apre%20%7B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0Aborder%3A%201px%20solid%20%23cccccc%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%2019px%3B%0Aoverflow%3A%20auto%3B%0Apadding%3A%206px%2010px%3B%0Aborder%2Dradius%3A%203px%3B%20%7D%0Apre%20code%2C%20pre%20tt%20%7B%0Abackground%2Dcolor%3A%20transparent%3B%0Aborder%3A%20none%3B%20%7D%0A%23TOC%20%7B%0Afloat%3A%20left%3B%0Awidth%3A%20400px%3B%20%0Abackground%2Dcolor%3A%20%23e6e6fa%3B%0Acolor%3A%20%23000080%3B%0Amargin%3A0px%3B%0Apadding%3A%201px%3B%0Apadding%2Dbottom%3A%2010px%3B%0A%7D%0Anav%20a%20%7B%0Acolor%3A%20%23000080%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aul%2C%20li%20%7Bmargin%2Dtop%3A0%2E1em%3B%20margin%2Dbottom%3A0%2E1em%3B%7D%0A%23TOC%5FWARP%7B%0Awidth%3A%20400px%3B%0Amargin%3A%200px%3B%0Apadding%3A%200px%3B%0A%7D%0A%23CONTENT%20%7B%0Amargin%2Dleft%3A%20400px%3B%20%0Amargin%2Dtop%3A%200px%3B%0Apadding%3A%201px%3B%0Apadding%2Dleft%3A%2030px%3B%0Apadding%2Dbottom%3A%2030px%3B%0Apadding%2Dright%3A%2015px%3B%0Abackground%2Dcolor%3A%20%23f8f8ff%3B%0A%7D%0A%0A%40media%20screen%20and%20%28max%2Dwidth%20%3A%201080px%29%7B%0Apre%20code%20%7B%20font%2Dsize%20%3A%2012pt%7D%0A%23CONTENT%20%7B%0Awidth%3A%20100%25%3B%0Amargin%2Dleft%3A%200px%3B%0A%7D%0A%23TOC%7B%0Adisplay%3A%20none%3B%0Awidth%3A%200px%3B%0A%7D%0A%7D%0A%0A" rel="stylesheet">
								<script src="data:application/javascript; charset=utf-8;base64,LyohIGpRdWVyeSB2MS4xMi4xIHwgKGMpIGpRdWVyeSBGb3VuZGF0aW9uIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovCiFmdW5jdGlvbihhLGIpeyJvYmplY3QiPT10eXBlb2YgbW9kdWxlJiYib2JqZWN0Ij09dHlwZW9mIG1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWEuZG9jdW1lbnQ/YihhLCEwKTpmdW5jdGlvbihhKXtpZighYS5kb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnQiKTtyZXR1cm4gYihhKX06YihhKX0oInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnRoaXMsZnVuY3Rpb24oYSxiKXt2YXIgYz1bXSxkPWEuZG9jdW1lbnQsZT1jLnNsaWNlLGY9Yy5jb25jYXQsZz1jLnB1c2gsaD1jLmluZGV4T2YsaT17fSxqPWkudG9TdHJpbmcsaz1pLmhhc093blByb3BlcnR5LGw9e30sbT0iMS4xMi4xIixuPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBuLmZuLmluaXQoYSxiKX0sbz0vXltcc1x1RkVGRlx4QTBdK3xbXHNcdUZFRkZceEEwXSskL2cscD0vXi1tcy0vLHE9Ly0oW1xkYS16XSkvZ2kscj1mdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9O24uZm49bi5wcm90b3R5cGU9e2pxdWVyeTptLGNvbnN0cnVjdG9yOm4sc2VsZWN0b3I6IiIsbGVuZ3RoOjAsdG9BcnJheTpmdW5jdGlvbigpe3JldHVybiBlLmNhbGwodGhpcyl9LGdldDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT8wPmE/dGhpc1thK3RoaXMubGVuZ3RoXTp0aGlzW2FdOmUuY2FsbCh0aGlzKX0scHVzaFN0YWNrOmZ1bmN0aW9uKGEpe3ZhciBiPW4ubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLGEpO3JldHVybiBiLnByZXZPYmplY3Q9dGhpcyxiLmNvbnRleHQ9dGhpcy5jb250ZXh0LGJ9LGVhY2g6ZnVuY3Rpb24oYSl7cmV0dXJuIG4uZWFjaCh0aGlzLGEpfSxtYXA6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKG4ubWFwKHRoaXMsZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5jYWxsKGIsYyxiKX0pKX0sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZS5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxlcTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxlbmd0aCxjPSthKygwPmE/YjowKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYz49MCYmYj5jP1t0aGlzW2NdXTpbXSl9LGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXZPYmplY3R8fHRoaXMuY29uc3RydWN0b3IoKX0scHVzaDpnLHNvcnQ6Yy5zb3J0LHNwbGljZTpjLnNwbGljZX0sbi5leHRlbmQ9bi5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZz1hcmd1bWVudHNbMF18fHt9LGg9MSxpPWFyZ3VtZW50cy5sZW5ndGgsaj0hMTtmb3IoImJvb2xlYW4iPT10eXBlb2YgZyYmKGo9ZyxnPWFyZ3VtZW50c1toXXx8e30saCsrKSwib2JqZWN0Ij09dHlwZW9mIGd8fG4uaXNGdW5jdGlvbihnKXx8KGc9e30pLGg9PT1pJiYoZz10aGlzLGgtLSk7aT5oO2grKylpZihudWxsIT0oZT1hcmd1bWVudHNbaF0pKWZvcihkIGluIGUpYT1nW2RdLGM9ZVtkXSxnIT09YyYmKGomJmMmJihuLmlzUGxhaW5PYmplY3QoYyl8fChiPW4uaXNBcnJheShjKSkpPyhiPyhiPSExLGY9YSYmbi5pc0FycmF5KGEpP2E6W10pOmY9YSYmbi5pc1BsYWluT2JqZWN0KGEpP2E6e30sZ1tkXT1uLmV4dGVuZChqLGYsYykpOnZvaWQgMCE9PWMmJihnW2RdPWMpKTtyZXR1cm4gZ30sbi5leHRlbmQoe2V4cGFuZG86ImpRdWVyeSIrKG0rTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXEQvZywiIiksaXNSZWFkeTohMCxlcnJvcjpmdW5jdGlvbihhKXt0aHJvdyBuZXcgRXJyb3IoYSl9LG5vb3A6ZnVuY3Rpb24oKXt9LGlzRnVuY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuImZ1bmN0aW9uIj09PW4udHlwZShhKX0saXNBcnJheTpBcnJheS5pc0FycmF5fHxmdW5jdGlvbihhKXtyZXR1cm4iYXJyYXkiPT09bi50eXBlKGEpfSxpc1dpbmRvdzpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmYT09YS53aW5kb3d9LGlzTnVtZXJpYzpmdW5jdGlvbihhKXt2YXIgYj1hJiZhLnRvU3RyaW5nKCk7cmV0dXJuIW4uaXNBcnJheShhKSYmYi1wYXJzZUZsb2F0KGIpKzE+PTB9LGlzRW1wdHlPYmplY3Q6ZnVuY3Rpb24oYSl7dmFyIGI7Zm9yKGIgaW4gYSlyZXR1cm4hMTtyZXR1cm4hMH0saXNQbGFpbk9iamVjdDpmdW5jdGlvbihhKXt2YXIgYjtpZighYXx8Im9iamVjdCIhPT1uLnR5cGUoYSl8fGEubm9kZVR5cGV8fG4uaXNXaW5kb3coYSkpcmV0dXJuITE7dHJ5e2lmKGEuY29uc3RydWN0b3ImJiFrLmNhbGwoYSwiY29uc3RydWN0b3IiKSYmIWsuY2FsbChhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwiaXNQcm90b3R5cGVPZiIpKXJldHVybiExfWNhdGNoKGMpe3JldHVybiExfWlmKCFsLm93bkZpcnN0KWZvcihiIGluIGEpcmV0dXJuIGsuY2FsbChhLGIpO2ZvcihiIGluIGEpO3JldHVybiB2b2lkIDA9PT1ifHxrLmNhbGwoYSxiKX0sdHlwZTpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT9hKyIiOiJvYmplY3QiPT10eXBlb2YgYXx8ImZ1bmN0aW9uIj09dHlwZW9mIGE/aVtqLmNhbGwoYSldfHwib2JqZWN0Ijp0eXBlb2YgYX0sZ2xvYmFsRXZhbDpmdW5jdGlvbihiKXtiJiZuLnRyaW0oYikmJihhLmV4ZWNTY3JpcHR8fGZ1bmN0aW9uKGIpe2EuZXZhbC5jYWxsKGEsYil9KShiKX0sY2FtZWxDYXNlOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UocCwibXMtIikucmVwbGFjZShxLHIpfSxub2RlTmFtZTpmdW5jdGlvbihhLGIpe3JldHVybiBhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1iLnRvTG93ZXJDYXNlKCl9LGVhY2g6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPTA7aWYocyhhKSl7Zm9yKGM9YS5sZW5ndGg7Yz5kO2QrKylpZihiLmNhbGwoYVtkXSxkLGFbZF0pPT09ITEpYnJlYWt9ZWxzZSBmb3IoZCBpbiBhKWlmKGIuY2FsbChhW2RdLGQsYVtkXSk9PT0hMSlicmVhaztyZXR1cm4gYX0sdHJpbTpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT8iIjooYSsiIikucmVwbGFjZShvLCIiKX0sbWFrZUFycmF5OmZ1bmN0aW9uKGEsYil7dmFyIGM9Ynx8W107cmV0dXJuIG51bGwhPWEmJihzKE9iamVjdChhKSk/bi5tZXJnZShjLCJzdHJpbmciPT10eXBlb2YgYT9bYV06YSk6Zy5jYWxsKGMsYSkpLGN9LGluQXJyYXk6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO2lmKGIpe2lmKGgpcmV0dXJuIGguY2FsbChiLGEsYyk7Zm9yKGQ9Yi5sZW5ndGgsYz1jPzA+Yz9NYXRoLm1heCgwLGQrYyk6YzowO2Q+YztjKyspaWYoYyBpbiBiJiZiW2NdPT09YSlyZXR1cm4gY31yZXR1cm4tMX0sbWVyZ2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz0rYi5sZW5ndGgsZD0wLGU9YS5sZW5ndGg7d2hpbGUoYz5kKWFbZSsrXT1iW2QrK107aWYoYyE9PWMpd2hpbGUodm9pZCAwIT09YltkXSlhW2UrK109YltkKytdO3JldHVybiBhLmxlbmd0aD1lLGF9LGdyZXA6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZCxlPVtdLGY9MCxnPWEubGVuZ3RoLGg9IWM7Zz5mO2YrKylkPSFiKGFbZl0sZiksZCE9PWgmJmUucHVzaChhW2ZdKTtyZXR1cm4gZX0sbWFwOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGc9MCxoPVtdO2lmKHMoYSkpZm9yKGQ9YS5sZW5ndGg7ZD5nO2crKyllPWIoYVtnXSxnLGMpLG51bGwhPWUmJmgucHVzaChlKTtlbHNlIGZvcihnIGluIGEpZT1iKGFbZ10sZyxjKSxudWxsIT1lJiZoLnB1c2goZSk7cmV0dXJuIGYuYXBwbHkoW10saCl9LGd1aWQ6MSxwcm94eTpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZjtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIGImJihmPWFbYl0sYj1hLGE9Ziksbi5pc0Z1bmN0aW9uKGEpPyhjPWUuY2FsbChhcmd1bWVudHMsMiksZD1mdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGJ8fHRoaXMsYy5jb25jYXQoZS5jYWxsKGFyZ3VtZW50cykpKX0sZC5ndWlkPWEuZ3VpZD1hLmd1aWR8fG4uZ3VpZCsrLGQpOnZvaWQgMH0sbm93OmZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfSxzdXBwb3J0Omx9KSwiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYobi5mbltTeW1ib2wuaXRlcmF0b3JdPWNbU3ltYm9sLml0ZXJhdG9yXSksbi5lYWNoKCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbCIuc3BsaXQoIiAiKSxmdW5jdGlvbihhLGIpe2lbIltvYmplY3QgIitiKyJdIl09Yi50b0xvd2VyQ2FzZSgpfSk7ZnVuY3Rpb24gcyhhKXt2YXIgYj0hIWEmJiJsZW5ndGgiaW4gYSYmYS5sZW5ndGgsYz1uLnR5cGUoYSk7cmV0dXJuImZ1bmN0aW9uIj09PWN8fG4uaXNXaW5kb3coYSk/ITE6ImFycmF5Ij09PWN8fDA9PT1ifHwibnVtYmVyIj09dHlwZW9mIGImJmI+MCYmYi0xIGluIGF9dmFyIHQ9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGgsaSxqLGssbCxtLG4sbyxwLHEscixzLHQsdT0ic2l6emxlIisxKm5ldyBEYXRlLHY9YS5kb2N1bWVudCx3PTAseD0wLHk9Z2EoKSx6PWdhKCksQT1nYSgpLEI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT09PWImJihsPSEwKSwwfSxDPTE8PDMxLEQ9e30uaGFzT3duUHJvcGVydHksRT1bXSxGPUUucG9wLEc9RS5wdXNoLEg9RS5wdXNoLEk9RS5zbGljZSxKPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZD1hLmxlbmd0aDtkPmM7YysrKWlmKGFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSxLPSJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZCIsTD0iW1xceDIwXFx0XFxyXFxuXFxmXSIsTT0iKD86XFxcXC58W1xcdy1dfFteXFx4MDAtXFx4YTBdKSsiLE49IlxcWyIrTCsiKigiK00rIikoPzoiK0wrIiooWypeJHwhfl0/PSkiK0wrIiooPzonKCg/OlxcXFwufFteXFxcXCddKSopJ3xcIigoPzpcXFxcLnxbXlxcXFxcIl0pKilcInwoIitNKyIpKXwpIitMKyIqXFxdIixPPSI6KCIrTSsiKSg/OlxcKCgoJygoPzpcXFxcLnxbXlxcXFwnXSkqKSd8XCIoKD86XFxcXC58W15cXFxcXCJdKSopXCIpfCgoPzpcXFxcLnxbXlxcXFwoKVtcXF1dfCIrTisiKSopfC4qKVxcKXwpIixQPW5ldyBSZWdFeHAoTCsiKyIsImciKSxRPW5ldyBSZWdFeHAoIl4iK0wrIit8KCg/Ol58W15cXFxcXSkoPzpcXFxcLikqKSIrTCsiKyQiLCJnIiksUj1uZXcgUmVnRXhwKCJeIitMKyIqLCIrTCsiKiIpLFM9bmV3IFJlZ0V4cCgiXiIrTCsiKihbPit+XXwiK0wrIikiK0wrIioiKSxUPW5ldyBSZWdFeHAoIj0iK0wrIiooW15cXF0nXCJdKj8pIitMKyIqXFxdIiwiZyIpLFU9bmV3IFJlZ0V4cChPKSxWPW5ldyBSZWdFeHAoIl4iK00rIiQiKSxXPXtJRDpuZXcgUmVnRXhwKCJeIygiK00rIikiKSxDTEFTUzpuZXcgUmVnRXhwKCJeXFwuKCIrTSsiKSIpLFRBRzpuZXcgUmVnRXhwKCJeKCIrTSsifFsqXSkiKSxBVFRSOm5ldyBSZWdFeHAoIl4iK04pLFBTRVVETzpuZXcgUmVnRXhwKCJeIitPKSxDSElMRDpuZXcgUmVnRXhwKCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXCgiK0wrIiooZXZlbnxvZGR8KChbKy1dfCkoXFxkKilufCkiK0wrIiooPzooWystXXwpIitMKyIqKFxcZCspfCkpIitMKyIqXFwpfCkiLCJpIiksYm9vbDpuZXcgUmVnRXhwKCJeKD86IitLKyIpJCIsImkiKSxuZWVkc0NvbnRleHQ6bmV3IFJlZ0V4cCgiXiIrTCsiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFwoIitMKyIqKCg/Oi1cXGQpP1xcZCopIitMKyIqXFwpfCkoPz1bXi1dfCQpIiwiaSIpfSxYPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksWT0vXmhcZCQvaSxaPS9eW157XStce1xzKlxbbmF0aXZlIFx3LywkPS9eKD86IyhbXHctXSspfChcdyspfFwuKFtcdy1dKykpJC8sXz0vWyt+XS8sYWE9Lyd8XFwvZyxiYT1uZXcgUmVnRXhwKCJcXFxcKFtcXGRhLWZdezEsNn0iK0wrIj98KCIrTCsiKXwuKSIsImlnIiksY2E9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPSIweCIrYi02NTUzNjtyZXR1cm4gZCE9PWR8fGM/YjowPmQ/U3RyaW5nLmZyb21DaGFyQ29kZShkKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKGQ+PjEwfDU1Mjk2LDEwMjMmZHw1NjMyMCl9LGRhPWZ1bmN0aW9uKCl7bSgpfTt0cnl7SC5hcHBseShFPUkuY2FsbCh2LmNoaWxkTm9kZXMpLHYuY2hpbGROb2RlcyksRVt2LmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZX1jYXRjaChlYSl7SD17YXBwbHk6RS5sZW5ndGg/ZnVuY3Rpb24oYSxiKXtHLmFwcGx5KGEsSS5jYWxsKGIpKX06ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmxlbmd0aCxkPTA7d2hpbGUoYVtjKytdPWJbZCsrXSk7YS5sZW5ndGg9Yy0xfX19ZnVuY3Rpb24gZmEoYSxiLGQsZSl7dmFyIGYsaCxqLGssbCxvLHIscyx3PWImJmIub3duZXJEb2N1bWVudCx4PWI/Yi5ub2RlVHlwZTo5O2lmKGQ9ZHx8W10sInN0cmluZyIhPXR5cGVvZiBhfHwhYXx8MSE9PXgmJjkhPT14JiYxMSE9PXgpcmV0dXJuIGQ7aWYoIWUmJigoYj9iLm93bmVyRG9jdW1lbnR8fGI6dikhPT1uJiZtKGIpLGI9Ynx8bixwKSl7aWYoMTEhPT14JiYobz0kLmV4ZWMoYSkpKWlmKGY9b1sxXSl7aWYoOT09PXgpe2lmKCEoaj1iLmdldEVsZW1lbnRCeUlkKGYpKSlyZXR1cm4gZDtpZihqLmlkPT09ZilyZXR1cm4gZC5wdXNoKGopLGR9ZWxzZSBpZih3JiYoaj13LmdldEVsZW1lbnRCeUlkKGYpKSYmdChiLGopJiZqLmlkPT09ZilyZXR1cm4gZC5wdXNoKGopLGR9ZWxzZXtpZihvWzJdKXJldHVybiBILmFwcGx5KGQsYi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKSksZDtpZigoZj1vWzNdKSYmYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpcmV0dXJuIEguYXBwbHkoZCxiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZikpLGR9aWYoYy5xc2EmJiFBW2ErIiAiXSYmKCFxfHwhcS50ZXN0KGEpKSl7aWYoMSE9PXgpdz1iLHM9YTtlbHNlIGlmKCJvYmplY3QiIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXsoaz1iLmdldEF0dHJpYnV0ZSgiaWQiKSk/az1rLnJlcGxhY2UoYWEsIlxcJCYiKTpiLnNldEF0dHJpYnV0ZSgiaWQiLGs9dSkscj1nKGEpLGg9ci5sZW5ndGgsbD1WLnRlc3Qoayk/IiMiK2s6IltpZD0nIitrKyInXSI7d2hpbGUoaC0tKXJbaF09bCsiICIrcWEocltoXSk7cz1yLmpvaW4oIiwiKSx3PV8udGVzdChhKSYmb2EoYi5wYXJlbnROb2RlKXx8Yn1pZihzKXRyeXtyZXR1cm4gSC5hcHBseShkLHcucXVlcnlTZWxlY3RvckFsbChzKSksZH1jYXRjaCh5KXt9ZmluYWxseXtrPT09dSYmYi5yZW1vdmVBdHRyaWJ1dGUoImlkIil9fX1yZXR1cm4gaShhLnJlcGxhY2UoUSwiJDEiKSxiLGQsZSl9ZnVuY3Rpb24gZ2EoKXt2YXIgYT1bXTtmdW5jdGlvbiBiKGMsZSl7cmV0dXJuIGEucHVzaChjKyIgIik+ZC5jYWNoZUxlbmd0aCYmZGVsZXRlIGJbYS5zaGlmdCgpXSxiW2MrIiAiXT1lfXJldHVybiBifWZ1bmN0aW9uIGhhKGEpe3JldHVybiBhW3VdPSEwLGF9ZnVuY3Rpb24gaWEoYSl7dmFyIGI9bi5jcmVhdGVFbGVtZW50KCJkaXYiKTt0cnl7cmV0dXJuISFhKGIpfWNhdGNoKGMpe3JldHVybiExfWZpbmFsbHl7Yi5wYXJlbnROb2RlJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYiksYj1udWxsfX1mdW5jdGlvbiBqYShhLGIpe3ZhciBjPWEuc3BsaXQoInwiKSxlPWMubGVuZ3RoO3doaWxlKGUtLSlkLmF0dHJIYW5kbGVbY1tlXV09Yn1mdW5jdGlvbiBrYShhLGIpe3ZhciBjPWImJmEsZD1jJiYxPT09YS5ub2RlVHlwZSYmMT09PWIubm9kZVR5cGUmJih+Yi5zb3VyY2VJbmRleHx8QyktKH5hLnNvdXJjZUluZGV4fHxDKTtpZihkKXJldHVybiBkO2lmKGMpd2hpbGUoYz1jLm5leHRTaWJsaW5nKWlmKGM9PT1iKXJldHVybi0xO3JldHVybiBhPzE6LTF9ZnVuY3Rpb24gbGEoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4iaW5wdXQiPT09YyYmYi50eXBlPT09YX19ZnVuY3Rpb24gbWEoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oImlucHV0Ij09PWN8fCJidXR0b24iPT09YykmJmIudHlwZT09PWF9fWZ1bmN0aW9uIG5hKGEpe3JldHVybiBoYShmdW5jdGlvbihiKXtyZXR1cm4gYj0rYixoYShmdW5jdGlvbihjLGQpe3ZhciBlLGY9YShbXSxjLmxlbmd0aCxiKSxnPWYubGVuZ3RoO3doaWxlKGctLSljW2U9ZltnXV0mJihjW2VdPSEoZFtlXT1jW2VdKSl9KX0pfWZ1bmN0aW9uIG9hKGEpe3JldHVybiBhJiYidW5kZWZpbmVkIiE9dHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUmJmF9Yz1mYS5zdXBwb3J0PXt9LGY9ZmEuaXNYTUw9ZnVuY3Rpb24oYSl7dmFyIGI9YSYmKGEub3duZXJEb2N1bWVudHx8YSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiBiPyJIVE1MIiE9PWIubm9kZU5hbWU6ITF9LG09ZmEuc2V0RG9jdW1lbnQ9ZnVuY3Rpb24oYSl7dmFyIGIsZSxnPWE/YS5vd25lckRvY3VtZW50fHxhOnY7cmV0dXJuIGchPT1uJiY5PT09Zy5ub2RlVHlwZSYmZy5kb2N1bWVudEVsZW1lbnQ/KG49ZyxvPW4uZG9jdW1lbnRFbGVtZW50LHA9IWYobiksKGU9bi5kZWZhdWx0VmlldykmJmUudG9wIT09ZSYmKGUuYWRkRXZlbnRMaXN0ZW5lcj9lLmFkZEV2ZW50TGlzdGVuZXIoInVubG9hZCIsZGEsITEpOmUuYXR0YWNoRXZlbnQmJmUuYXR0YWNoRXZlbnQoIm9udW5sb2FkIixkYSkpLGMuYXR0cmlidXRlcz1pYShmdW5jdGlvbihhKXtyZXR1cm4gYS5jbGFzc05hbWU9ImkiLCFhLmdldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIil9KSxjLmdldEVsZW1lbnRzQnlUYWdOYW1lPWlhKGZ1bmN0aW9uKGEpe3JldHVybiBhLmFwcGVuZENoaWxkKG4uY3JlYXRlQ29tbWVudCgiIikpLCFhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCIqIikubGVuZ3RofSksYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lPVoudGVzdChuLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLGMuZ2V0QnlJZD1pYShmdW5jdGlvbihhKXtyZXR1cm4gby5hcHBlbmRDaGlsZChhKS5pZD11LCFuLmdldEVsZW1lbnRzQnlOYW1lfHwhbi5nZXRFbGVtZW50c0J5TmFtZSh1KS5sZW5ndGh9KSxjLmdldEJ5SWQ/KGQuZmluZC5JRD1mdW5jdGlvbihhLGIpe2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgYi5nZXRFbGVtZW50QnlJZCYmcCl7dmFyIGM9Yi5nZXRFbGVtZW50QnlJZChhKTtyZXR1cm4gYz9bY106W119fSxkLmZpbHRlci5JRD1mdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoYmEsY2EpO3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoImlkIik9PT1ifX0pOihkZWxldGUgZC5maW5kLklELGQuZmlsdGVyLklEPWZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShiYSxjYSk7cmV0dXJuIGZ1bmN0aW9uKGEpe3ZhciBjPSJ1bmRlZmluZWQiIT10eXBlb2YgYS5nZXRBdHRyaWJ1dGVOb2RlJiZhLmdldEF0dHJpYnV0ZU5vZGUoImlkIik7cmV0dXJuIGMmJmMudmFsdWU9PT1ifX0pLGQuZmluZC5UQUc9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZT9mdW5jdGlvbihhLGIpe3JldHVybiJ1bmRlZmluZWQiIT10eXBlb2YgYi5nZXRFbGVtZW50c0J5VGFnTmFtZT9iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpOmMucXNhP2IucXVlcnlTZWxlY3RvckFsbChhKTp2b2lkIDB9OmZ1bmN0aW9uKGEsYil7dmFyIGMsZD1bXSxlPTAsZj1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpO2lmKCIqIj09PWEpe3doaWxlKGM9ZltlKytdKTE9PT1jLm5vZGVUeXBlJiZkLnB1c2goYyk7cmV0dXJuIGR9cmV0dXJuIGZ9LGQuZmluZC5DTEFTUz1jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJmZ1bmN0aW9uKGEsYil7cmV0dXJuInVuZGVmaW5lZCIhPXR5cGVvZiBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJnA/Yi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGEpOnZvaWQgMH0scj1bXSxxPVtdLChjLnFzYT1aLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkmJihpYShmdW5jdGlvbihhKXtvLmFwcGVuZENoaWxkKGEpLmlubmVySFRNTD0iPGEgaWQ9JyIrdSsiJz48L2E+PHNlbGVjdCBpZD0nIit1KyItXHJcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD4iLGEucXVlcnlTZWxlY3RvckFsbCgiW21zYWxsb3djYXB0dXJlXj0nJ10iKS5sZW5ndGgmJnEucHVzaCgiWypeJF09IitMKyIqKD86Jyd8XCJcIikiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoIltzZWxlY3RlZF0iKS5sZW5ndGh8fHEucHVzaCgiXFxbIitMKyIqKD86dmFsdWV8IitLKyIpIiksYS5xdWVyeVNlbGVjdG9yQWxsKCJbaWR+PSIrdSsiLV0iKS5sZW5ndGh8fHEucHVzaCgifj0iKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoIjpjaGVja2VkIikubGVuZ3RofHxxLnB1c2goIjpjaGVja2VkIiksYS5xdWVyeVNlbGVjdG9yQWxsKCJhIyIrdSsiKyoiKS5sZW5ndGh8fHEucHVzaCgiLiMuK1srfl0iKX0pLGlhKGZ1bmN0aW9uKGEpe3ZhciBiPW4uY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtiLnNldEF0dHJpYnV0ZSgidHlwZSIsImhpZGRlbiIpLGEuYXBwZW5kQ2hpbGQoYikuc2V0QXR0cmlidXRlKCJuYW1lIiwiRCIpLGEucXVlcnlTZWxlY3RvckFsbCgiW25hbWU9ZF0iKS5sZW5ndGgmJnEucHVzaCgibmFtZSIrTCsiKlsqXiR8IX5dPz0iKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoIjplbmFibGVkIikubGVuZ3RofHxxLnB1c2goIjplbmFibGVkIiwiOmRpc2FibGVkIiksYS5xdWVyeVNlbGVjdG9yQWxsKCIqLDp4IikscS5wdXNoKCIsLio6Iil9KSksKGMubWF0Y2hlc1NlbGVjdG9yPVoudGVzdChzPW8ubWF0Y2hlc3x8by53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fG8ubW96TWF0Y2hlc1NlbGVjdG9yfHxvLm9NYXRjaGVzU2VsZWN0b3J8fG8ubXNNYXRjaGVzU2VsZWN0b3IpKSYmaWEoZnVuY3Rpb24oYSl7Yy5kaXNjb25uZWN0ZWRNYXRjaD1zLmNhbGwoYSwiZGl2Iikscy5jYWxsKGEsIltzIT0nJ106eCIpLHIucHVzaCgiIT0iLE8pfSkscT1xLmxlbmd0aCYmbmV3IFJlZ0V4cChxLmpvaW4oInwiKSkscj1yLmxlbmd0aCYmbmV3IFJlZ0V4cChyLmpvaW4oInwiKSksYj1aLnRlc3Qoby5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiksdD1ifHxaLnRlc3Qoby5jb250YWlucyk/ZnVuY3Rpb24oYSxiKXt2YXIgYz05PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLGQ9YiYmYi5wYXJlbnROb2RlO3JldHVybiBhPT09ZHx8ISghZHx8MSE9PWQubm9kZVR5cGV8fCEoYy5jb250YWlucz9jLmNvbnRhaW5zKGQpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24mJjE2JmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZCkpKX06ZnVuY3Rpb24oYSxiKXtpZihiKXdoaWxlKGI9Yi5wYXJlbnROb2RlKWlmKGI9PT1hKXJldHVybiEwO3JldHVybiExfSxCPWI/ZnVuY3Rpb24oYSxiKXtpZihhPT09YilyZXR1cm4gbD0hMCwwO3ZhciBkPSFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uLSFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO3JldHVybiBkP2Q6KGQ9KGEub3duZXJEb2N1bWVudHx8YSk9PT0oYi5vd25lckRvY3VtZW50fHxiKT9hLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpOjEsMSZkfHwhYy5zb3J0RGV0YWNoZWQmJmIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSk9PT1kP2E9PT1ufHxhLm93bmVyRG9jdW1lbnQ9PT12JiZ0KHYsYSk/LTE6Yj09PW58fGIub3duZXJEb2N1bWVudD09PXYmJnQodixiKT8xOms/SihrLGEpLUooayxiKTowOjQmZD8tMToxKX06ZnVuY3Rpb24oYSxiKXtpZihhPT09YilyZXR1cm4gbD0hMCwwO3ZhciBjLGQ9MCxlPWEucGFyZW50Tm9kZSxmPWIucGFyZW50Tm9kZSxnPVthXSxoPVtiXTtpZighZXx8IWYpcmV0dXJuIGE9PT1uPy0xOmI9PT1uPzE6ZT8tMTpmPzE6az9KKGssYSktSihrLGIpOjA7aWYoZT09PWYpcmV0dXJuIGthKGEsYik7Yz1hO3doaWxlKGM9Yy5wYXJlbnROb2RlKWcudW5zaGlmdChjKTtjPWI7d2hpbGUoYz1jLnBhcmVudE5vZGUpaC51bnNoaWZ0KGMpO3doaWxlKGdbZF09PT1oW2RdKWQrKztyZXR1cm4gZD9rYShnW2RdLGhbZF0pOmdbZF09PT12Py0xOmhbZF09PT12PzE6MH0sbik6bn0sZmEubWF0Y2hlcz1mdW5jdGlvbihhLGIpe3JldHVybiBmYShhLG51bGwsbnVsbCxiKX0sZmEubWF0Y2hlc1NlbGVjdG9yPWZ1bmN0aW9uKGEsYil7aWYoKGEub3duZXJEb2N1bWVudHx8YSkhPT1uJiZtKGEpLGI9Yi5yZXBsYWNlKFQsIj0nJDEnXSIpLGMubWF0Y2hlc1NlbGVjdG9yJiZwJiYhQVtiKyIgIl0mJighcnx8IXIudGVzdChiKSkmJighcXx8IXEudGVzdChiKSkpdHJ5e3ZhciBkPXMuY2FsbChhLGIpO2lmKGR8fGMuZGlzY29ubmVjdGVkTWF0Y2h8fGEuZG9jdW1lbnQmJjExIT09YS5kb2N1bWVudC5ub2RlVHlwZSlyZXR1cm4gZH1jYXRjaChlKXt9cmV0dXJuIGZhKGIsbixudWxsLFthXSkubGVuZ3RoPjB9LGZhLmNvbnRhaW5zPWZ1bmN0aW9uKGEsYil7cmV0dXJuKGEub3duZXJEb2N1bWVudHx8YSkhPT1uJiZtKGEpLHQoYSxiKX0sZmEuYXR0cj1mdW5jdGlvbihhLGIpeyhhLm93bmVyRG9jdW1lbnR8fGEpIT09biYmbShhKTt2YXIgZT1kLmF0dHJIYW5kbGVbYi50b0xvd2VyQ2FzZSgpXSxmPWUmJkQuY2FsbChkLmF0dHJIYW5kbGUsYi50b0xvd2VyQ2FzZSgpKT9lKGEsYiwhcCk6dm9pZCAwO3JldHVybiB2b2lkIDAhPT1mP2Y6Yy5hdHRyaWJ1dGVzfHwhcD9hLmdldEF0dHJpYnV0ZShiKTooZj1hLmdldEF0dHJpYnV0ZU5vZGUoYikpJiZmLnNwZWNpZmllZD9mLnZhbHVlOm51bGx9LGZhLmVycm9yPWZ1bmN0aW9uKGEpe3Rocm93IG5ldyBFcnJvcigiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogIithKX0sZmEudW5pcXVlU29ydD1mdW5jdGlvbihhKXt2YXIgYixkPVtdLGU9MCxmPTA7aWYobD0hYy5kZXRlY3REdXBsaWNhdGVzLGs9IWMuc29ydFN0YWJsZSYmYS5zbGljZSgwKSxhLnNvcnQoQiksbCl7d2hpbGUoYj1hW2YrK10pYj09PWFbZl0mJihlPWQucHVzaChmKSk7d2hpbGUoZS0tKWEuc3BsaWNlKGRbZV0sMSl9cmV0dXJuIGs9bnVsbCxhfSxlPWZhLmdldFRleHQ9ZnVuY3Rpb24oYSl7dmFyIGIsYz0iIixkPTAsZj1hLm5vZGVUeXBlO2lmKGYpe2lmKDE9PT1mfHw5PT09Znx8MTE9PT1mKXtpZigic3RyaW5nIj09dHlwZW9mIGEudGV4dENvbnRlbnQpcmV0dXJuIGEudGV4dENvbnRlbnQ7Zm9yKGE9YS5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKWMrPWUoYSl9ZWxzZSBpZigzPT09Znx8ND09PWYpcmV0dXJuIGEubm9kZVZhbHVlfWVsc2Ugd2hpbGUoYj1hW2QrK10pYys9ZShiKTtyZXR1cm4gY30sZD1mYS5zZWxlY3RvcnM9e2NhY2hlTGVuZ3RoOjUwLGNyZWF0ZVBzZXVkbzpoYSxtYXRjaDpXLGF0dHJIYW5kbGU6e30sZmluZDp7fSxyZWxhdGl2ZTp7Ij4iOntkaXI6InBhcmVudE5vZGUiLGZpcnN0OiEwfSwiICI6e2RpcjoicGFyZW50Tm9kZSJ9LCIrIjp7ZGlyOiJwcmV2aW91c1NpYmxpbmciLGZpcnN0OiEwfSwifiI6e2RpcjoicHJldmlvdXNTaWJsaW5nIn19LHByZUZpbHRlcjp7QVRUUjpmdW5jdGlvbihhKXtyZXR1cm4gYVsxXT1hWzFdLnJlcGxhY2UoYmEsY2EpLGFbM109KGFbM118fGFbNF18fGFbNV18fCIiKS5yZXBsYWNlKGJhLGNhKSwifj0iPT09YVsyXSYmKGFbM109IiAiK2FbM10rIiAiKSxhLnNsaWNlKDAsNCl9LENISUxEOmZ1bmN0aW9uKGEpe3JldHVybiBhWzFdPWFbMV0udG9Mb3dlckNhc2UoKSwibnRoIj09PWFbMV0uc2xpY2UoMCwzKT8oYVszXXx8ZmEuZXJyb3IoYVswXSksYVs0XT0rKGFbNF0/YVs1XSsoYVs2XXx8MSk6MiooImV2ZW4iPT09YVszXXx8Im9kZCI9PT1hWzNdKSksYVs1XT0rKGFbN10rYVs4XXx8Im9kZCI9PT1hWzNdKSk6YVszXSYmZmEuZXJyb3IoYVswXSksYX0sUFNFVURPOmZ1bmN0aW9uKGEpe3ZhciBiLGM9IWFbNl0mJmFbMl07cmV0dXJuIFcuQ0hJTEQudGVzdChhWzBdKT9udWxsOihhWzNdP2FbMl09YVs0XXx8YVs1XXx8IiI6YyYmVS50ZXN0KGMpJiYoYj1nKGMsITApKSYmKGI9Yy5pbmRleE9mKCIpIixjLmxlbmd0aC1iKS1jLmxlbmd0aCkmJihhWzBdPWFbMF0uc2xpY2UoMCxiKSxhWzJdPWMuc2xpY2UoMCxiKSksYS5zbGljZSgwLDMpKX19LGZpbHRlcjp7VEFHOmZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShiYSxjYSkudG9Mb3dlckNhc2UoKTtyZXR1cm4iKiI9PT1hP2Z1bmN0aW9uKCl7cmV0dXJuITB9OmZ1bmN0aW9uKGEpe3JldHVybiBhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1ifX0sQ0xBU1M6ZnVuY3Rpb24oYSl7dmFyIGI9eVthKyIgIl07cmV0dXJuIGJ8fChiPW5ldyBSZWdFeHAoIihefCIrTCsiKSIrYSsiKCIrTCsifCQpIikpJiZ5KGEsZnVuY3Rpb24oYSl7cmV0dXJuIGIudGVzdCgic3RyaW5nIj09dHlwZW9mIGEuY2xhc3NOYW1lJiZhLmNsYXNzTmFtZXx8InVuZGVmaW5lZCIhPXR5cGVvZiBhLmdldEF0dHJpYnV0ZSYmYS5nZXRBdHRyaWJ1dGUoImNsYXNzIil8fCIiKX0pfSxBVFRSOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZnVuY3Rpb24oZCl7dmFyIGU9ZmEuYXR0cihkLGEpO3JldHVybiBudWxsPT1lPyIhPSI9PT1iOmI/KGUrPSIiLCI9Ij09PWI/ZT09PWM6IiE9Ij09PWI/ZSE9PWM6Il49Ij09PWI/YyYmMD09PWUuaW5kZXhPZihjKToiKj0iPT09Yj9jJiZlLmluZGV4T2YoYyk+LTE6IiQ9Ij09PWI/YyYmZS5zbGljZSgtYy5sZW5ndGgpPT09Yzoifj0iPT09Yj8oIiAiK2UucmVwbGFjZShQLCIgIikrIiAiKS5pbmRleE9mKGMpPi0xOiJ8PSI9PT1iP2U9PT1jfHxlLnNsaWNlKDAsYy5sZW5ndGgrMSk9PT1jKyItIjohMSk6ITB9fSxDSElMRDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPSJudGgiIT09YS5zbGljZSgwLDMpLGc9Imxhc3QiIT09YS5zbGljZSgtNCksaD0ib2YtdHlwZSI9PT1iO3JldHVybiAxPT09ZCYmMD09PWU/ZnVuY3Rpb24oYSl7cmV0dXJuISFhLnBhcmVudE5vZGV9OmZ1bmN0aW9uKGIsYyxpKXt2YXIgaixrLGwsbSxuLG8scD1mIT09Zz8ibmV4dFNpYmxpbmciOiJwcmV2aW91c1NpYmxpbmciLHE9Yi5wYXJlbnROb2RlLHI9aCYmYi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLHM9IWkmJiFoLHQ9ITE7aWYocSl7aWYoZil7d2hpbGUocCl7bT1iO3doaWxlKG09bVtwXSlpZihoP20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PXI6MT09PW0ubm9kZVR5cGUpcmV0dXJuITE7bz1wPSJvbmx5Ij09PWEmJiFvJiYibmV4dFNpYmxpbmcifXJldHVybiEwfWlmKG89W2c/cS5maXJzdENoaWxkOnEubGFzdENoaWxkXSxnJiZzKXttPXEsbD1tW3VdfHwobVt1XT17fSksaz1sW20udW5pcXVlSURdfHwobFttLnVuaXF1ZUlEXT17fSksaj1rW2FdfHxbXSxuPWpbMF09PT13JiZqWzFdLHQ9biYmalsyXSxtPW4mJnEuY2hpbGROb2Rlc1tuXTt3aGlsZShtPSsrbiYmbSYmbVtwXXx8KHQ9bj0wKXx8by5wb3AoKSlpZigxPT09bS5ub2RlVHlwZSYmKyt0JiZtPT09Yil7a1thXT1bdyxuLHRdO2JyZWFrfX1lbHNlIGlmKHMmJihtPWIsbD1tW3VdfHwobVt1XT17fSksaz1sW20udW5pcXVlSURdfHwobFttLnVuaXF1ZUlEXT17fSksaj1rW2FdfHxbXSxuPWpbMF09PT13JiZqWzFdLHQ9biksdD09PSExKXdoaWxlKG09KytuJiZtJiZtW3BdfHwodD1uPTApfHxvLnBvcCgpKWlmKChoP20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PXI6MT09PW0ubm9kZVR5cGUpJiYrK3QmJihzJiYobD1tW3VdfHwobVt1XT17fSksaz1sW20udW5pcXVlSURdfHwobFttLnVuaXF1ZUlEXT17fSksa1thXT1bdyx0XSksbT09PWIpKWJyZWFrO3JldHVybiB0LT1lLHQ9PT1kfHx0JWQ9PT0wJiZ0L2Q+PTB9fX0sUFNFVURPOmZ1bmN0aW9uKGEsYil7dmFyIGMsZT1kLnBzZXVkb3NbYV18fGQuc2V0RmlsdGVyc1thLnRvTG93ZXJDYXNlKCldfHxmYS5lcnJvcigidW5zdXBwb3J0ZWQgcHNldWRvOiAiK2EpO3JldHVybiBlW3VdP2UoYik6ZS5sZW5ndGg+MT8oYz1bYSxhLCIiLGJdLGQuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShhLnRvTG93ZXJDYXNlKCkpP2hhKGZ1bmN0aW9uKGEsYyl7dmFyIGQsZj1lKGEsYiksZz1mLmxlbmd0aDt3aGlsZShnLS0pZD1KKGEsZltnXSksYVtkXT0hKGNbZF09ZltnXSl9KTpmdW5jdGlvbihhKXtyZXR1cm4gZShhLDAsYyl9KTplfX0scHNldWRvczp7bm90OmhhKGZ1bmN0aW9uKGEpe3ZhciBiPVtdLGM9W10sZD1oKGEucmVwbGFjZShRLCIkMSIpKTtyZXR1cm4gZFt1XT9oYShmdW5jdGlvbihhLGIsYyxlKXt2YXIgZixnPWQoYSxudWxsLGUsW10pLGg9YS5sZW5ndGg7d2hpbGUoaC0tKShmPWdbaF0pJiYoYVtoXT0hKGJbaF09ZikpfSk6ZnVuY3Rpb24oYSxlLGYpe3JldHVybiBiWzBdPWEsZChiLG51bGwsZixjKSxiWzBdPW51bGwsIWMucG9wKCl9fSksaGFzOmhhKGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gZmEoYSxiKS5sZW5ndGg+MH19KSxjb250YWluczpoYShmdW5jdGlvbihhKXtyZXR1cm4gYT1hLnJlcGxhY2UoYmEsY2EpLGZ1bmN0aW9uKGIpe3JldHVybihiLnRleHRDb250ZW50fHxiLmlubmVyVGV4dHx8ZShiKSkuaW5kZXhPZihhKT4tMX19KSxsYW5nOmhhKGZ1bmN0aW9uKGEpe3JldHVybiBWLnRlc3QoYXx8IiIpfHxmYS5lcnJvcigidW5zdXBwb3J0ZWQgbGFuZzogIithKSxhPWEucmVwbGFjZShiYSxjYSkudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihiKXt2YXIgYztkbyBpZihjPXA/Yi5sYW5nOmIuZ2V0QXR0cmlidXRlKCJ4bWw6bGFuZyIpfHxiLmdldEF0dHJpYnV0ZSgibGFuZyIpKXJldHVybiBjPWMudG9Mb3dlckNhc2UoKSxjPT09YXx8MD09PWMuaW5kZXhPZihhKyItIik7d2hpbGUoKGI9Yi5wYXJlbnROb2RlKSYmMT09PWIubm9kZVR5cGUpO3JldHVybiExfX0pLHRhcmdldDpmdW5jdGlvbihiKXt2YXIgYz1hLmxvY2F0aW9uJiZhLmxvY2F0aW9uLmhhc2g7cmV0dXJuIGMmJmMuc2xpY2UoMSk9PT1iLmlkfSxyb290OmZ1bmN0aW9uKGEpe3JldHVybiBhPT09b30sZm9jdXM6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1uLmFjdGl2ZUVsZW1lbnQmJighbi5oYXNGb2N1c3x8bi5oYXNGb2N1cygpKSYmISEoYS50eXBlfHxhLmhyZWZ8fH5hLnRhYkluZGV4KX0sZW5hYmxlZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5kaXNhYmxlZD09PSExfSxkaXNhYmxlZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5kaXNhYmxlZD09PSEwfSxjaGVja2VkOmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4iaW5wdXQiPT09YiYmISFhLmNoZWNrZWR8fCJvcHRpb24iPT09YiYmISFhLnNlbGVjdGVkfSxzZWxlY3RlZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCxhLnNlbGVjdGVkPT09ITB9LGVtcHR5OmZ1bmN0aW9uKGEpe2ZvcihhPWEuZmlyc3RDaGlsZDthO2E9YS5uZXh0U2libGluZylpZihhLm5vZGVUeXBlPDYpcmV0dXJuITE7cmV0dXJuITB9LHBhcmVudDpmdW5jdGlvbihhKXtyZXR1cm4hZC5wc2V1ZG9zLmVtcHR5KGEpfSxoZWFkZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIFkudGVzdChhLm5vZGVOYW1lKX0saW5wdXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIFgudGVzdChhLm5vZGVOYW1lKX0sYnV0dG9uOmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4iaW5wdXQiPT09YiYmImJ1dHRvbiI9PT1hLnR5cGV8fCJidXR0b24iPT09Yn0sdGV4dDpmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4iaW5wdXQiPT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiYidGV4dCI9PT1hLnR5cGUmJihudWxsPT0oYj1hLmdldEF0dHJpYnV0ZSgidHlwZSIpKXx8InRleHQiPT09Yi50b0xvd2VyQ2FzZSgpKX0sZmlyc3Q6bmEoZnVuY3Rpb24oKXtyZXR1cm5bMF19KSxsYXN0Om5hKGZ1bmN0aW9uKGEsYil7cmV0dXJuW2ItMV19KSxlcTpuYShmdW5jdGlvbihhLGIsYyl7cmV0dXJuWzA+Yz9jK2I6Y119KSxldmVuOm5hKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7Yj5jO2MrPTIpYS5wdXNoKGMpO3JldHVybiBhfSksb2RkOm5hKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTE7Yj5jO2MrPTIpYS5wdXNoKGMpO3JldHVybiBhfSksbHQ6bmEoZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wPmM/YytiOmM7LS1kPj0wOylhLnB1c2goZCk7cmV0dXJuIGF9KSxndDpuYShmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPTA+Yz9jK2I6YzsrK2Q8YjspYS5wdXNoKGQpO3JldHVybiBhfSl9fSxkLnBzZXVkb3MubnRoPWQucHNldWRvcy5lcTtmb3IoYiBpbntyYWRpbzohMCxjaGVja2JveDohMCxmaWxlOiEwLHBhc3N3b3JkOiEwLGltYWdlOiEwfSlkLnBzZXVkb3NbYl09bGEoYik7Zm9yKGIgaW57c3VibWl0OiEwLHJlc2V0OiEwfSlkLnBzZXVkb3NbYl09bWEoYik7ZnVuY3Rpb24gcGEoKXt9cGEucHJvdG90eXBlPWQuZmlsdGVycz1kLnBzZXVkb3MsZC5zZXRGaWx0ZXJzPW5ldyBwYSxnPWZhLnRva2VuaXplPWZ1bmN0aW9uKGEsYil7dmFyIGMsZSxmLGcsaCxpLGosaz16W2ErIiAiXTtpZihrKXJldHVybiBiPzA6ay5zbGljZSgwKTtoPWEsaT1bXSxqPWQucHJlRmlsdGVyO3doaWxlKGgpeyghY3x8KGU9Ui5leGVjKGgpKSkmJihlJiYoaD1oLnNsaWNlKGVbMF0ubGVuZ3RoKXx8aCksaS5wdXNoKGY9W10pKSxjPSExLChlPVMuZXhlYyhoKSkmJihjPWUuc2hpZnQoKSxmLnB1c2goe3ZhbHVlOmMsdHlwZTplWzBdLnJlcGxhY2UoUSwiICIpfSksaD1oLnNsaWNlKGMubGVuZ3RoKSk7Zm9yKGcgaW4gZC5maWx0ZXIpIShlPVdbZ10uZXhlYyhoKSl8fGpbZ10mJiEoZT1qW2ddKGUpKXx8KGM9ZS5zaGlmdCgpLGYucHVzaCh7dmFsdWU6Yyx0eXBlOmcsbWF0Y2hlczplfSksaD1oLnNsaWNlKGMubGVuZ3RoKSk7aWYoIWMpYnJlYWt9cmV0dXJuIGI/aC5sZW5ndGg6aD9mYS5lcnJvcihhKTp6KGEsaSkuc2xpY2UoMCl9O2Z1bmN0aW9uIHFhKGEpe2Zvcih2YXIgYj0wLGM9YS5sZW5ndGgsZD0iIjtjPmI7YisrKWQrPWFbYl0udmFsdWU7cmV0dXJuIGR9ZnVuY3Rpb24gcmEoYSxiLGMpe3ZhciBkPWIuZGlyLGU9YyYmInBhcmVudE5vZGUiPT09ZCxmPXgrKztyZXR1cm4gYi5maXJzdD9mdW5jdGlvbihiLGMsZil7d2hpbGUoYj1iW2RdKWlmKDE9PT1iLm5vZGVUeXBlfHxlKXJldHVybiBhKGIsYyxmKX06ZnVuY3Rpb24oYixjLGcpe3ZhciBoLGksaixrPVt3LGZdO2lmKGcpe3doaWxlKGI9YltkXSlpZigoMT09PWIubm9kZVR5cGV8fGUpJiZhKGIsYyxnKSlyZXR1cm4hMH1lbHNlIHdoaWxlKGI9YltkXSlpZigxPT09Yi5ub2RlVHlwZXx8ZSl7aWYoaj1iW3VdfHwoYlt1XT17fSksaT1qW2IudW5pcXVlSURdfHwoaltiLnVuaXF1ZUlEXT17fSksKGg9aVtkXSkmJmhbMF09PT13JiZoWzFdPT09ZilyZXR1cm4ga1syXT1oWzJdO2lmKGlbZF09ayxrWzJdPWEoYixjLGcpKXJldHVybiEwfX19ZnVuY3Rpb24gc2EoYSl7cmV0dXJuIGEubGVuZ3RoPjE/ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEubGVuZ3RoO3doaWxlKGUtLSlpZighYVtlXShiLGMsZCkpcmV0dXJuITE7cmV0dXJuITB9OmFbMF19ZnVuY3Rpb24gdGEoYSxiLGMpe2Zvcih2YXIgZD0wLGU9Yi5sZW5ndGg7ZT5kO2QrKylmYShhLGJbZF0sYyk7cmV0dXJuIGN9ZnVuY3Rpb24gdWEoYSxiLGMsZCxlKXtmb3IodmFyIGYsZz1bXSxoPTAsaT1hLmxlbmd0aCxqPW51bGwhPWI7aT5oO2grKykoZj1hW2hdKSYmKCFjfHxjKGYsZCxlKSkmJihnLnB1c2goZiksaiYmYi5wdXNoKGgpKTtyZXR1cm4gZ31mdW5jdGlvbiB2YShhLGIsYyxkLGUsZil7cmV0dXJuIGQmJiFkW3VdJiYoZD12YShkKSksZSYmIWVbdV0mJihlPXZhKGUsZikpLGhhKGZ1bmN0aW9uKGYsZyxoLGkpe3ZhciBqLGssbCxtPVtdLG49W10sbz1nLmxlbmd0aCxwPWZ8fHRhKGJ8fCIqIixoLm5vZGVUeXBlP1toXTpoLFtdKSxxPSFhfHwhZiYmYj9wOnVhKHAsbSxhLGgsaSkscj1jP2V8fChmP2E6b3x8ZCk/W106ZzpxO2lmKGMmJmMocSxyLGgsaSksZCl7aj11YShyLG4pLGQoaixbXSxoLGkpLGs9ai5sZW5ndGg7d2hpbGUoay0tKShsPWpba10pJiYocltuW2tdXT0hKHFbbltrXV09bCkpfWlmKGYpe2lmKGV8fGEpe2lmKGUpe2o9W10saz1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJmoucHVzaChxW2tdPWwpO2UobnVsbCxyPVtdLGosaSl9az1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJihqPWU/SihmLGwpOm1ba10pPi0xJiYoZltqXT0hKGdbal09bCkpfX1lbHNlIHI9dWEocj09PWc/ci5zcGxpY2UobyxyLmxlbmd0aCk6ciksZT9lKG51bGwsZyxyLGkpOkguYXBwbHkoZyxyKX0pfWZ1bmN0aW9uIHdhKGEpe2Zvcih2YXIgYixjLGUsZj1hLmxlbmd0aCxnPWQucmVsYXRpdmVbYVswXS50eXBlXSxoPWd8fGQucmVsYXRpdmVbIiAiXSxpPWc/MTowLGs9cmEoZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1ifSxoLCEwKSxsPXJhKGZ1bmN0aW9uKGEpe3JldHVybiBKKGIsYSk+LTF9LGgsITApLG09W2Z1bmN0aW9uKGEsYyxkKXt2YXIgZT0hZyYmKGR8fGMhPT1qKXx8KChiPWMpLm5vZGVUeXBlP2soYSxjLGQpOmwoYSxjLGQpKTtyZXR1cm4gYj1udWxsLGV9XTtmPmk7aSsrKWlmKGM9ZC5yZWxhdGl2ZVthW2ldLnR5cGVdKW09W3JhKHNhKG0pLGMpXTtlbHNle2lmKGM9ZC5maWx0ZXJbYVtpXS50eXBlXS5hcHBseShudWxsLGFbaV0ubWF0Y2hlcyksY1t1XSl7Zm9yKGU9KytpO2Y+ZTtlKyspaWYoZC5yZWxhdGl2ZVthW2VdLnR5cGVdKWJyZWFrO3JldHVybiB2YShpPjEmJnNhKG0pLGk+MSYmcWEoYS5zbGljZSgwLGktMSkuY29uY2F0KHt2YWx1ZToiICI9PT1hW2ktMl0udHlwZT8iKiI6IiJ9KSkucmVwbGFjZShRLCIkMSIpLGMsZT5pJiZ3YShhLnNsaWNlKGksZSkpLGY+ZSYmd2EoYT1hLnNsaWNlKGUpKSxmPmUmJnFhKGEpKX1tLnB1c2goYyl9cmV0dXJuIHNhKG0pfWZ1bmN0aW9uIHhhKGEsYil7dmFyIGM9Yi5sZW5ndGg+MCxlPWEubGVuZ3RoPjAsZj1mdW5jdGlvbihmLGcsaCxpLGspe3ZhciBsLG8scSxyPTAscz0iMCIsdD1mJiZbXSx1PVtdLHY9aix4PWZ8fGUmJmQuZmluZC5UQUcoIioiLGspLHk9dys9bnVsbD09dj8xOk1hdGgucmFuZG9tKCl8fC4xLHo9eC5sZW5ndGg7Zm9yKGsmJihqPWc9PT1ufHxnfHxrKTtzIT09eiYmbnVsbCE9KGw9eFtzXSk7cysrKXtpZihlJiZsKXtvPTAsZ3x8bC5vd25lckRvY3VtZW50PT09bnx8KG0obCksaD0hcCk7d2hpbGUocT1hW28rK10paWYocShsLGd8fG4saCkpe2kucHVzaChsKTticmVha31rJiYodz15KX1jJiYoKGw9IXEmJmwpJiZyLS0sZiYmdC5wdXNoKGwpKX1pZihyKz1zLGMmJnMhPT1yKXtvPTA7d2hpbGUocT1iW28rK10pcSh0LHUsZyxoKTtpZihmKXtpZihyPjApd2hpbGUocy0tKXRbc118fHVbc118fCh1W3NdPUYuY2FsbChpKSk7dT11YSh1KX1ILmFwcGx5KGksdSksayYmIWYmJnUubGVuZ3RoPjAmJnIrYi5sZW5ndGg+MSYmZmEudW5pcXVlU29ydChpKX1yZXR1cm4gayYmKHc9eSxqPXYpLHR9O3JldHVybiBjP2hhKGYpOmZ9cmV0dXJuIGg9ZmEuY29tcGlsZT1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9W10sZT1bXSxmPUFbYSsiICJdO2lmKCFmKXtifHwoYj1nKGEpKSxjPWIubGVuZ3RoO3doaWxlKGMtLSlmPXdhKGJbY10pLGZbdV0/ZC5wdXNoKGYpOmUucHVzaChmKTtmPUEoYSx4YShlLGQpKSxmLnNlbGVjdG9yPWF9cmV0dXJuIGZ9LGk9ZmEuc2VsZWN0PWZ1bmN0aW9uKGEsYixlLGYpe3ZhciBpLGosayxsLG0sbj0iZnVuY3Rpb24iPT10eXBlb2YgYSYmYSxvPSFmJiZnKGE9bi5zZWxlY3Rvcnx8YSk7aWYoZT1lfHxbXSwxPT09by5sZW5ndGgpe2lmKGo9b1swXT1vWzBdLnNsaWNlKDApLGoubGVuZ3RoPjImJiJJRCI9PT0oaz1qWzBdKS50eXBlJiZjLmdldEJ5SWQmJjk9PT1iLm5vZGVUeXBlJiZwJiZkLnJlbGF0aXZlW2pbMV0udHlwZV0pe2lmKGI9KGQuZmluZC5JRChrLm1hdGNoZXNbMF0ucmVwbGFjZShiYSxjYSksYil8fFtdKVswXSwhYilyZXR1cm4gZTtuJiYoYj1iLnBhcmVudE5vZGUpLGE9YS5zbGljZShqLnNoaWZ0KCkudmFsdWUubGVuZ3RoKX1pPVcubmVlZHNDb250ZXh0LnRlc3QoYSk/MDpqLmxlbmd0aDt3aGlsZShpLS0pe2lmKGs9altpXSxkLnJlbGF0aXZlW2w9ay50eXBlXSlicmVhaztpZigobT1kLmZpbmRbbF0pJiYoZj1tKGsubWF0Y2hlc1swXS5yZXBsYWNlKGJhLGNhKSxfLnRlc3QoalswXS50eXBlKSYmb2EoYi5wYXJlbnROb2RlKXx8YikpKXtpZihqLnNwbGljZShpLDEpLGE9Zi5sZW5ndGgmJnFhKGopLCFhKXJldHVybiBILmFwcGx5KGUsZiksZTticmVha319fXJldHVybihufHxoKGEsbykpKGYsYiwhcCxlLCFifHxfLnRlc3QoYSkmJm9hKGIucGFyZW50Tm9kZSl8fGIpLGV9LGMuc29ydFN0YWJsZT11LnNwbGl0KCIiKS5zb3J0KEIpLmpvaW4oIiIpPT09dSxjLmRldGVjdER1cGxpY2F0ZXM9ISFsLG0oKSxjLnNvcnREZXRhY2hlZD1pYShmdW5jdGlvbihhKXtyZXR1cm4gMSZhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG4uY3JlYXRlRWxlbWVudCgiZGl2IikpfSksaWEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPSI8YSBocmVmPScjJz48L2E+IiwiIyI9PT1hLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCJocmVmIil9KXx8amEoInR5cGV8aHJlZnxoZWlnaHR8d2lkdGgiLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYz92b2lkIDA6YS5nZXRBdHRyaWJ1dGUoYiwidHlwZSI9PT1iLnRvTG93ZXJDYXNlKCk/MToyKX0pLGMuYXR0cmlidXRlcyYmaWEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPSI8aW5wdXQvPiIsYS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIiKSwiIj09PWEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoInZhbHVlIil9KXx8amEoInZhbHVlIixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGN8fCJpbnB1dCIhPT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk/dm9pZCAwOmEuZGVmYXVsdFZhbHVlfSksaWEoZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWEuZ2V0QXR0cmlidXRlKCJkaXNhYmxlZCIpfSl8fGphKEssZnVuY3Rpb24oYSxiLGMpe3ZhciBkO3JldHVybiBjP3ZvaWQgMDphW2JdPT09ITA/Yi50b0xvd2VyQ2FzZSgpOihkPWEuZ2V0QXR0cmlidXRlTm9kZShiKSkmJmQuc3BlY2lmaWVkP2QudmFsdWU6bnVsbH0pLGZhfShhKTtuLmZpbmQ9dCxuLmV4cHI9dC5zZWxlY3RvcnMsbi5leHByWyI6Il09bi5leHByLnBzZXVkb3Msbi51bmlxdWVTb3J0PW4udW5pcXVlPXQudW5pcXVlU29ydCxuLnRleHQ9dC5nZXRUZXh0LG4uaXNYTUxEb2M9dC5pc1hNTCxuLmNvbnRhaW5zPXQuY29udGFpbnM7dmFyIHU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVtdLGU9dm9pZCAwIT09Yzt3aGlsZSgoYT1hW2JdKSYmOSE9PWEubm9kZVR5cGUpaWYoMT09PWEubm9kZVR5cGUpe2lmKGUmJm4oYSkuaXMoYykpYnJlYWs7ZC5wdXNoKGEpfXJldHVybiBkfSx2PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdO2E7YT1hLm5leHRTaWJsaW5nKTE9PT1hLm5vZGVUeXBlJiZhIT09YiYmYy5wdXNoKGEpO3JldHVybiBjfSx3PW4uZXhwci5tYXRjaC5uZWVkc0NvbnRleHQseD0vXjwoW1x3LV0rKVxzKlwvPz4oPzo8XC9cMT58KSQvLHk9L14uW146I1xbXC4sXSokLztmdW5jdGlvbiB6KGEsYixjKXtpZihuLmlzRnVuY3Rpb24oYikpcmV0dXJuIG4uZ3JlcChhLGZ1bmN0aW9uKGEsZCl7cmV0dXJuISFiLmNhbGwoYSxkLGEpIT09Y30pO2lmKGIubm9kZVR5cGUpcmV0dXJuIG4uZ3JlcChhLGZ1bmN0aW9uKGEpe3JldHVybiBhPT09YiE9PWN9KTtpZigic3RyaW5nIj09dHlwZW9mIGIpe2lmKHkudGVzdChiKSlyZXR1cm4gbi5maWx0ZXIoYixhLGMpO2I9bi5maWx0ZXIoYixhKX1yZXR1cm4gbi5ncmVwKGEsZnVuY3Rpb24oYSl7cmV0dXJuIG4uaW5BcnJheShhLGIpPi0xIT09Y30pfW4uZmlsdGVyPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iWzBdO3JldHVybiBjJiYoYT0iOm5vdCgiK2ErIikiKSwxPT09Yi5sZW5ndGgmJjE9PT1kLm5vZGVUeXBlP24uZmluZC5tYXRjaGVzU2VsZWN0b3IoZCxhKT9bZF06W106bi5maW5kLm1hdGNoZXMoYSxuLmdyZXAoYixmdW5jdGlvbihhKXtyZXR1cm4gMT09PWEubm9kZVR5cGV9KSl9LG4uZm4uZXh0ZW5kKHtmaW5kOmZ1bmN0aW9uKGEpe3ZhciBiLGM9W10sZD10aGlzLGU9ZC5sZW5ndGg7aWYoInN0cmluZyIhPXR5cGVvZiBhKXJldHVybiB0aGlzLnB1c2hTdGFjayhuKGEpLmZpbHRlcihmdW5jdGlvbigpe2ZvcihiPTA7ZT5iO2IrKylpZihuLmNvbnRhaW5zKGRbYl0sdGhpcykpcmV0dXJuITB9KSk7Zm9yKGI9MDtlPmI7YisrKW4uZmluZChhLGRbYl0sYyk7cmV0dXJuIGM9dGhpcy5wdXNoU3RhY2soZT4xP24udW5pcXVlKGMpOmMpLGMuc2VsZWN0b3I9dGhpcy5zZWxlY3Rvcj90aGlzLnNlbGVjdG9yKyIgIithOmEsY30sZmlsdGVyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnB1c2hTdGFjayh6KHRoaXMsYXx8W10sITEpKX0sbm90OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnB1c2hTdGFjayh6KHRoaXMsYXx8W10sITApKX0saXM6ZnVuY3Rpb24oYSl7cmV0dXJuISF6KHRoaXMsInN0cmluZyI9PXR5cGVvZiBhJiZ3LnRlc3QoYSk/bihhKTphfHxbXSwhMSkubGVuZ3RofX0pO3ZhciBBLEI9L14oPzpccyooPFtcd1xXXSs+KVtePl0qfCMoW1x3LV0qKSkkLyxDPW4uZm4uaW5pdD1mdW5jdGlvbihhLGIsYyl7dmFyIGUsZjtpZighYSlyZXR1cm4gdGhpcztpZihjPWN8fEEsInN0cmluZyI9PXR5cGVvZiBhKXtpZihlPSI8Ij09PWEuY2hhckF0KDApJiYiPiI9PT1hLmNoYXJBdChhLmxlbmd0aC0xKSYmYS5sZW5ndGg+PTM/W251bGwsYSxudWxsXTpCLmV4ZWMoYSksIWV8fCFlWzFdJiZiKXJldHVybiFifHxiLmpxdWVyeT8oYnx8YykuZmluZChhKTp0aGlzLmNvbnN0cnVjdG9yKGIpLmZpbmQoYSk7aWYoZVsxXSl7aWYoYj1iIGluc3RhbmNlb2Ygbj9iWzBdOmIsbi5tZXJnZSh0aGlzLG4ucGFyc2VIVE1MKGVbMV0sYiYmYi5ub2RlVHlwZT9iLm93bmVyRG9jdW1lbnR8fGI6ZCwhMCkpLHgudGVzdChlWzFdKSYmbi5pc1BsYWluT2JqZWN0KGIpKWZvcihlIGluIGIpbi5pc0Z1bmN0aW9uKHRoaXNbZV0pP3RoaXNbZV0oYltlXSk6dGhpcy5hdHRyKGUsYltlXSk7cmV0dXJuIHRoaXN9aWYoZj1kLmdldEVsZW1lbnRCeUlkKGVbMl0pLGYmJmYucGFyZW50Tm9kZSl7aWYoZi5pZCE9PWVbMl0pcmV0dXJuIEEuZmluZChhKTt0aGlzLmxlbmd0aD0xLHRoaXNbMF09Zn1yZXR1cm4gdGhpcy5jb250ZXh0PWQsdGhpcy5zZWxlY3Rvcj1hLHRoaXN9cmV0dXJuIGEubm9kZVR5cGU/KHRoaXMuY29udGV4dD10aGlzWzBdPWEsdGhpcy5sZW5ndGg9MSx0aGlzKTpuLmlzRnVuY3Rpb24oYSk/InVuZGVmaW5lZCIhPXR5cGVvZiBjLnJlYWR5P2MucmVhZHkoYSk6YShuKToodm9pZCAwIT09YS5zZWxlY3RvciYmKHRoaXMuc2VsZWN0b3I9YS5zZWxlY3Rvcix0aGlzLmNvbnRleHQ9YS5jb250ZXh0KSxuLm1ha2VBcnJheShhLHRoaXMpKX07Qy5wcm90b3R5cGU9bi5mbixBPW4oZCk7dmFyIEQ9L14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sRT17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTtuLmZuLmV4dGVuZCh7aGFzOmZ1bmN0aW9uKGEpe3ZhciBiLGM9bihhLHRoaXMpLGQ9Yy5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKGI9MDtkPmI7YisrKWlmKG4uY29udGFpbnModGhpcyxjW2JdKSlyZXR1cm4hMH0pfSxjbG9zZXN0OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjLGQ9MCxlPXRoaXMubGVuZ3RoLGY9W10sZz13LnRlc3QoYSl8fCJzdHJpbmciIT10eXBlb2YgYT9uKGEsYnx8dGhpcy5jb250ZXh0KTowO2U+ZDtkKyspZm9yKGM9dGhpc1tkXTtjJiZjIT09YjtjPWMucGFyZW50Tm9kZSlpZihjLm5vZGVUeXBlPDExJiYoZz9nLmluZGV4KGMpPi0xOjE9PT1jLm5vZGVUeXBlJiZuLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGMsYSkpKXtmLnB1c2goYyk7YnJlYWt9cmV0dXJuIHRoaXMucHVzaFN0YWNrKGYubGVuZ3RoPjE/bi51bmlxdWVTb3J0KGYpOmYpfSxpbmRleDpmdW5jdGlvbihhKXtyZXR1cm4gYT8ic3RyaW5nIj09dHlwZW9mIGE/bi5pbkFycmF5KHRoaXNbMF0sbihhKSk6bi5pbkFycmF5KGEuanF1ZXJ5P2FbMF06YSx0aGlzKTp0aGlzWzBdJiZ0aGlzWzBdLnBhcmVudE5vZGU/dGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGg6LTF9LGFkZDpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnB1c2hTdGFjayhuLnVuaXF1ZVNvcnQobi5tZXJnZSh0aGlzLmdldCgpLG4oYSxiKSkpKX0sYWRkQmFjazpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGQobnVsbD09YT90aGlzLnByZXZPYmplY3Q6dGhpcy5wcmV2T2JqZWN0LmZpbHRlcihhKSl9fSk7ZnVuY3Rpb24gRihhLGIpe2RvIGE9YVtiXTt3aGlsZShhJiYxIT09YS5ub2RlVHlwZSk7cmV0dXJuIGF9bi5lYWNoKHtwYXJlbnQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO3JldHVybiBiJiYxMSE9PWIubm9kZVR5cGU/YjpudWxsfSxwYXJlbnRzOmZ1bmN0aW9uKGEpe3JldHVybiB1KGEsInBhcmVudE5vZGUiKX0scGFyZW50c1VudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdShhLCJwYXJlbnROb2RlIixjKX0sbmV4dDpmdW5jdGlvbihhKXtyZXR1cm4gRihhLCJuZXh0U2libGluZyIpfSxwcmV2OmZ1bmN0aW9uKGEpe3JldHVybiBGKGEsInByZXZpb3VzU2libGluZyIpfSxuZXh0QWxsOmZ1bmN0aW9uKGEpe3JldHVybiB1KGEsIm5leHRTaWJsaW5nIil9LHByZXZBbGw6ZnVuY3Rpb24oYSl7cmV0dXJuIHUoYSwicHJldmlvdXNTaWJsaW5nIil9LG5leHRVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHUoYSwibmV4dFNpYmxpbmciLGMpfSxwcmV2VW50aWw6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB1KGEsInByZXZpb3VzU2libGluZyIsYyl9LHNpYmxpbmdzOmZ1bmN0aW9uKGEpe3JldHVybiB2KChhLnBhcmVudE5vZGV8fHt9KS5maXJzdENoaWxkLGEpfSxjaGlsZHJlbjpmdW5jdGlvbihhKXtyZXR1cm4gdihhLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihhKXtyZXR1cm4gbi5ub2RlTmFtZShhLCJpZnJhbWUiKT9hLmNvbnRlbnREb2N1bWVudHx8YS5jb250ZW50V2luZG93LmRvY3VtZW50Om4ubWVyZ2UoW10sYS5jaGlsZE5vZGVzKX19LGZ1bmN0aW9uKGEsYil7bi5mblthXT1mdW5jdGlvbihjLGQpe3ZhciBlPW4ubWFwKHRoaXMsYixjKTtyZXR1cm4iVW50aWwiIT09YS5zbGljZSgtNSkmJihkPWMpLGQmJiJzdHJpbmciPT10eXBlb2YgZCYmKGU9bi5maWx0ZXIoZCxlKSksdGhpcy5sZW5ndGg+MSYmKEVbYV18fChlPW4udW5pcXVlU29ydChlKSksRC50ZXN0KGEpJiYoZT1lLnJldmVyc2UoKSkpLHRoaXMucHVzaFN0YWNrKGUpfX0pO3ZhciBHPS9cUysvZztmdW5jdGlvbiBIKGEpe3ZhciBiPXt9O3JldHVybiBuLmVhY2goYS5tYXRjaChHKXx8W10sZnVuY3Rpb24oYSxjKXtiW2NdPSEwfSksYn1uLkNhbGxiYWNrcz1mdW5jdGlvbihhKXthPSJzdHJpbmciPT10eXBlb2YgYT9IKGEpOm4uZXh0ZW5kKHt9LGEpO3ZhciBiLGMsZCxlLGY9W10sZz1bXSxoPS0xLGk9ZnVuY3Rpb24oKXtmb3IoZT1hLm9uY2UsZD1iPSEwO2cubGVuZ3RoO2g9LTEpe2M9Zy5zaGlmdCgpO3doaWxlKCsraDxmLmxlbmd0aClmW2hdLmFwcGx5KGNbMF0sY1sxXSk9PT0hMSYmYS5zdG9wT25GYWxzZSYmKGg9Zi5sZW5ndGgsYz0hMSl9YS5tZW1vcnl8fChjPSExKSxiPSExLGUmJihmPWM/W106IiIpfSxqPXthZGQ6ZnVuY3Rpb24oKXtyZXR1cm4gZiYmKGMmJiFiJiYoaD1mLmxlbmd0aC0xLGcucHVzaChjKSksZnVuY3Rpb24gZChiKXtuLmVhY2goYixmdW5jdGlvbihiLGMpe24uaXNGdW5jdGlvbihjKT9hLnVuaXF1ZSYmai5oYXMoYyl8fGYucHVzaChjKTpjJiZjLmxlbmd0aCYmInN0cmluZyIhPT1uLnR5cGUoYykmJmQoYyl9KX0oYXJndW1lbnRzKSxjJiYhYiYmaSgpKSx0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gbi5lYWNoKGFyZ3VtZW50cyxmdW5jdGlvbihhLGIpe3ZhciBjO3doaWxlKChjPW4uaW5BcnJheShiLGYsYykpPi0xKWYuc3BsaWNlKGMsMSksaD49YyYmaC0tfSksdGhpc30saGFzOmZ1bmN0aW9uKGEpe3JldHVybiBhP24uaW5BcnJheShhLGYpPi0xOmYubGVuZ3RoPjB9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIGYmJihmPVtdKSx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGU9Zz1bXSxmPWM9IiIsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hZn0sbG9jazpmdW5jdGlvbigpe3JldHVybiBlPSEwLGN8fGouZGlzYWJsZSgpLHRoaXN9LGxvY2tlZDpmdW5jdGlvbigpe3JldHVybiEhZX0sZmlyZVdpdGg6ZnVuY3Rpb24oYSxjKXtyZXR1cm4gZXx8KGM9Y3x8W10sYz1bYSxjLnNsaWNlP2Muc2xpY2UoKTpjXSxnLnB1c2goYyksYnx8aSgpKSx0aGlzfSxmaXJlOmZ1bmN0aW9uKCl7cmV0dXJuIGouZmlyZVdpdGgodGhpcyxhcmd1bWVudHMpLHRoaXN9LGZpcmVkOmZ1bmN0aW9uKCl7cmV0dXJuISFkfX07cmV0dXJuIGp9LG4uZXh0ZW5kKHtEZWZlcnJlZDpmdW5jdGlvbihhKXt2YXIgYj1bWyJyZXNvbHZlIiwiZG9uZSIsbi5DYWxsYmFja3MoIm9uY2UgbWVtb3J5IiksInJlc29sdmVkIl0sWyJyZWplY3QiLCJmYWlsIixuLkNhbGxiYWNrcygib25jZSBtZW1vcnkiKSwicmVqZWN0ZWQiXSxbIm5vdGlmeSIsInByb2dyZXNzIixuLkNhbGxiYWNrcygibWVtb3J5IildXSxjPSJwZW5kaW5nIixkPXtzdGF0ZTpmdW5jdGlvbigpe3JldHVybiBjfSxhbHdheXM6ZnVuY3Rpb24oKXtyZXR1cm4gZS5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpLHRoaXN9LHRoZW46ZnVuY3Rpb24oKXt2YXIgYT1hcmd1bWVudHM7cmV0dXJuIG4uRGVmZXJyZWQoZnVuY3Rpb24oYyl7bi5lYWNoKGIsZnVuY3Rpb24oYixmKXt2YXIgZz1uLmlzRnVuY3Rpb24oYVtiXSkmJmFbYl07ZVtmWzFdXShmdW5jdGlvbigpe3ZhciBhPWcmJmcuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EmJm4uaXNGdW5jdGlvbihhLnByb21pc2UpP2EucHJvbWlzZSgpLnByb2dyZXNzKGMubm90aWZ5KS5kb25lKGMucmVzb2x2ZSkuZmFpbChjLnJlamVjdCk6Y1tmWzBdKyJXaXRoIl0odGhpcz09PWQ/Yy5wcm9taXNlKCk6dGhpcyxnP1thXTphcmd1bWVudHMpfSl9KSxhPW51bGx9KS5wcm9taXNlKCl9LHByb21pc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/bi5leHRlbmQoYSxkKTpkfX0sZT17fTtyZXR1cm4gZC5waXBlPWQudGhlbixuLmVhY2goYixmdW5jdGlvbihhLGYpe3ZhciBnPWZbMl0saD1mWzNdO2RbZlsxXV09Zy5hZGQsaCYmZy5hZGQoZnVuY3Rpb24oKXtjPWh9LGJbMV5hXVsyXS5kaXNhYmxlLGJbMl1bMl0ubG9jayksZVtmWzBdXT1mdW5jdGlvbigpe3JldHVybiBlW2ZbMF0rIldpdGgiXSh0aGlzPT09ZT9kOnRoaXMsYXJndW1lbnRzKSx0aGlzfSxlW2ZbMF0rIldpdGgiXT1nLmZpcmVXaXRofSksZC5wcm9taXNlKGUpLGEmJmEuY2FsbChlLGUpLGV9LHdoZW46ZnVuY3Rpb24oYSl7dmFyIGI9MCxjPWUuY2FsbChhcmd1bWVudHMpLGQ9Yy5sZW5ndGgsZj0xIT09ZHx8YSYmbi5pc0Z1bmN0aW9uKGEucHJvbWlzZSk/ZDowLGc9MT09PWY/YTpuLkRlZmVycmVkKCksaD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGZ1bmN0aW9uKGQpe2JbYV09dGhpcyxjW2FdPWFyZ3VtZW50cy5sZW5ndGg+MT9lLmNhbGwoYXJndW1lbnRzKTpkLGM9PT1pP2cubm90aWZ5V2l0aChiLGMpOi0tZnx8Zy5yZXNvbHZlV2l0aChiLGMpfX0saSxqLGs7aWYoZD4xKWZvcihpPW5ldyBBcnJheShkKSxqPW5ldyBBcnJheShkKSxrPW5ldyBBcnJheShkKTtkPmI7YisrKWNbYl0mJm4uaXNGdW5jdGlvbihjW2JdLnByb21pc2UpP2NbYl0ucHJvbWlzZSgpLnByb2dyZXNzKGgoYixqLGkpKS5kb25lKGgoYixrLGMpKS5mYWlsKGcucmVqZWN0KTotLWY7cmV0dXJuIGZ8fGcucmVzb2x2ZVdpdGgoayxjKSxnLnByb21pc2UoKX19KTt2YXIgSTtuLmZuLnJlYWR5PWZ1bmN0aW9uKGEpe3JldHVybiBuLnJlYWR5LnByb21pc2UoKS5kb25lKGEpLHRoaXN9LG4uZXh0ZW5kKHtpc1JlYWR5OiExLHJlYWR5V2FpdDoxLGhvbGRSZWFkeTpmdW5jdGlvbihhKXthP24ucmVhZHlXYWl0Kys6bi5yZWFkeSghMCl9LHJlYWR5OmZ1bmN0aW9uKGEpeyhhPT09ITA/LS1uLnJlYWR5V2FpdDpuLmlzUmVhZHkpfHwobi5pc1JlYWR5PSEwLGEhPT0hMCYmLS1uLnJlYWR5V2FpdD4wfHwoSS5yZXNvbHZlV2l0aChkLFtuXSksbi5mbi50cmlnZ2VySGFuZGxlciYmKG4oZCkudHJpZ2dlckhhbmRsZXIoInJlYWR5IiksbihkKS5vZmYoInJlYWR5IikpKSl9fSk7ZnVuY3Rpb24gSigpe2QuYWRkRXZlbnRMaXN0ZW5lcj8oZC5yZW1vdmVFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIixLKSxhLnJlbW92ZUV2ZW50TGlzdGVuZXIoImxvYWQiLEspKTooZC5kZXRhY2hFdmVudCgib25yZWFkeXN0YXRlY2hhbmdlIixLKSxhLmRldGFjaEV2ZW50KCJvbmxvYWQiLEspKX1mdW5jdGlvbiBLKCl7KGQuYWRkRXZlbnRMaXN0ZW5lcnx8ImxvYWQiPT09YS5ldmVudC50eXBlfHwiY29tcGxldGUiPT09ZC5yZWFkeVN0YXRlKSYmKEooKSxuLnJlYWR5KCkpfW4ucmVhZHkucHJvbWlzZT1mdW5jdGlvbihiKXtpZighSSlpZihJPW4uRGVmZXJyZWQoKSwiY29tcGxldGUiPT09ZC5yZWFkeVN0YXRlfHwibG9hZGluZyIhPT1kLnJlYWR5U3RhdGUmJiFkLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbClhLnNldFRpbWVvdXQobi5yZWFkeSk7ZWxzZSBpZihkLmFkZEV2ZW50TGlzdGVuZXIpZC5hZGRFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIixLKSxhLmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLEspO2Vsc2V7ZC5hdHRhY2hFdmVudCgib25yZWFkeXN0YXRlY2hhbmdlIixLKSxhLmF0dGFjaEV2ZW50KCJvbmxvYWQiLEspO3ZhciBjPSExO3RyeXtjPW51bGw9PWEuZnJhbWVFbGVtZW50JiZkLmRvY3VtZW50RWxlbWVudH1jYXRjaChlKXt9YyYmYy5kb1Njcm9sbCYmIWZ1bmN0aW9uIGYoKXtpZighbi5pc1JlYWR5KXt0cnl7Yy5kb1Njcm9sbCgibGVmdCIpfWNhdGNoKGIpe3JldHVybiBhLnNldFRpbWVvdXQoZiw1MCl9SigpLG4ucmVhZHkoKX19KCl9cmV0dXJuIEkucHJvbWlzZShiKX0sbi5yZWFkeS5wcm9taXNlKCk7dmFyIEw7Zm9yKEwgaW4gbihsKSlicmVhaztsLm93bkZpcnN0PSIwIj09PUwsbC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0PSExLG4oZnVuY3Rpb24oKXt2YXIgYSxiLGMsZTtjPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImJvZHkiKVswXSxjJiZjLnN0eWxlJiYoYj1kLmNyZWF0ZUVsZW1lbnQoImRpdiIpLGU9ZC5jcmVhdGVFbGVtZW50KCJkaXYiKSxlLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2JvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4IixjLmFwcGVuZENoaWxkKGUpLmFwcGVuZENoaWxkKGIpLCJ1bmRlZmluZWQiIT10eXBlb2YgYi5zdHlsZS56b29tJiYoYi5zdHlsZS5jc3NUZXh0PSJkaXNwbGF5OmlubGluZTttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjFweDt3aWR0aDoxcHg7em9vbToxIixsLmlubGluZUJsb2NrTmVlZHNMYXlvdXQ9YT0zPT09Yi5vZmZzZXRXaWR0aCxhJiYoYy5zdHlsZS56b29tPTEpKSxjLnJlbW92ZUNoaWxkKGUpKX0pLGZ1bmN0aW9uKCl7dmFyIGE9ZC5jcmVhdGVFbGVtZW50KCJkaXYiKTtsLmRlbGV0ZUV4cGFuZG89ITA7dHJ5e2RlbGV0ZSBhLnRlc3R9Y2F0Y2goYil7bC5kZWxldGVFeHBhbmRvPSExfWE9bnVsbH0oKTt2YXIgTT1mdW5jdGlvbihhKXt2YXIgYj1uLm5vRGF0YVsoYS5ub2RlTmFtZSsiICIpLnRvTG93ZXJDYXNlKCldLGM9K2Eubm9kZVR5cGV8fDE7cmV0dXJuIDEhPT1jJiY5IT09Yz8hMTohYnx8YiE9PSEwJiZhLmdldEF0dHJpYnV0ZSgiY2xhc3NpZCIpPT09Yn0sTj0vXig/Olx7W1x3XFddKlx9fFxbW1x3XFddKlxdKSQvLE89LyhbQS1aXSkvZztmdW5jdGlvbiBQKGEsYixjKXtpZih2b2lkIDA9PT1jJiYxPT09YS5ub2RlVHlwZSl7dmFyIGQ9ImRhdGEtIitiLnJlcGxhY2UoTywiLSQxIikudG9Mb3dlckNhc2UoKTtpZihjPWEuZ2V0QXR0cmlidXRlKGQpLCJzdHJpbmciPT10eXBlb2YgYyl7dHJ5e2M9InRydWUiPT09Yz8hMDoiZmFsc2UiPT09Yz8hMToibnVsbCI9PT1jP251bGw6K2MrIiI9PT1jPytjOk4udGVzdChjKT9uLnBhcnNlSlNPTihjKTpjfWNhdGNoKGUpe31uLmRhdGEoYSxiLGMpfWVsc2UgYz12b2lkIDA7Cn1yZXR1cm4gY31mdW5jdGlvbiBRKGEpe3ZhciBiO2ZvcihiIGluIGEpaWYoKCJkYXRhIiE9PWJ8fCFuLmlzRW1wdHlPYmplY3QoYVtiXSkpJiYidG9KU09OIiE9PWIpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gUihhLGIsZCxlKXtpZihNKGEpKXt2YXIgZixnLGg9bi5leHBhbmRvLGk9YS5ub2RlVHlwZSxqPWk/bi5jYWNoZTphLGs9aT9hW2hdOmFbaF0mJmg7aWYoayYmaltrXSYmKGV8fGpba10uZGF0YSl8fHZvaWQgMCE9PWR8fCJzdHJpbmciIT10eXBlb2YgYilyZXR1cm4ga3x8KGs9aT9hW2hdPWMucG9wKCl8fG4uZ3VpZCsrOmgpLGpba118fChqW2tdPWk/e306e3RvSlNPTjpuLm5vb3B9KSwoIm9iamVjdCI9PXR5cGVvZiBifHwiZnVuY3Rpb24iPT10eXBlb2YgYikmJihlP2pba109bi5leHRlbmQoaltrXSxiKTpqW2tdLmRhdGE9bi5leHRlbmQoaltrXS5kYXRhLGIpKSxnPWpba10sZXx8KGcuZGF0YXx8KGcuZGF0YT17fSksZz1nLmRhdGEpLHZvaWQgMCE9PWQmJihnW24uY2FtZWxDYXNlKGIpXT1kKSwic3RyaW5nIj09dHlwZW9mIGI/KGY9Z1tiXSxudWxsPT1mJiYoZj1nW24uY2FtZWxDYXNlKGIpXSkpOmY9ZyxmfX1mdW5jdGlvbiBTKGEsYixjKXtpZihNKGEpKXt2YXIgZCxlLGY9YS5ub2RlVHlwZSxnPWY/bi5jYWNoZTphLGg9Zj9hW24uZXhwYW5kb106bi5leHBhbmRvO2lmKGdbaF0pe2lmKGImJihkPWM/Z1toXTpnW2hdLmRhdGEpKXtuLmlzQXJyYXkoYik/Yj1iLmNvbmNhdChuLm1hcChiLG4uY2FtZWxDYXNlKSk6YiBpbiBkP2I9W2JdOihiPW4uY2FtZWxDYXNlKGIpLGI9YiBpbiBkP1tiXTpiLnNwbGl0KCIgIikpLGU9Yi5sZW5ndGg7d2hpbGUoZS0tKWRlbGV0ZSBkW2JbZV1dO2lmKGM/IVEoZCk6IW4uaXNFbXB0eU9iamVjdChkKSlyZXR1cm59KGN8fChkZWxldGUgZ1toXS5kYXRhLFEoZ1toXSkpKSYmKGY/bi5jbGVhbkRhdGEoW2FdLCEwKTpsLmRlbGV0ZUV4cGFuZG98fGchPWcud2luZG93P2RlbGV0ZSBnW2hdOmdbaF09dm9pZCAwKX19fW4uZXh0ZW5kKHtjYWNoZTp7fSxub0RhdGE6eyJhcHBsZXQgIjohMCwiZW1iZWQgIjohMCwib2JqZWN0ICI6ImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMCJ9LGhhc0RhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9YS5ub2RlVHlwZT9uLmNhY2hlW2Fbbi5leHBhbmRvXV06YVtuLmV4cGFuZG9dLCEhYSYmIVEoYSl9LGRhdGE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBSKGEsYixjKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihhLGIpe3JldHVybiBTKGEsYil9LF9kYXRhOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUihhLGIsYywhMCl9LF9yZW1vdmVEYXRhOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoYSxiLCEwKX19KSxuLmZuLmV4dGVuZCh7ZGF0YTpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPXRoaXNbMF0sZz1mJiZmLmF0dHJpYnV0ZXM7aWYodm9pZCAwPT09YSl7aWYodGhpcy5sZW5ndGgmJihlPW4uZGF0YShmKSwxPT09Zi5ub2RlVHlwZSYmIW4uX2RhdGEoZiwicGFyc2VkQXR0cnMiKSkpe2M9Zy5sZW5ndGg7d2hpbGUoYy0tKWdbY10mJihkPWdbY10ubmFtZSwwPT09ZC5pbmRleE9mKCJkYXRhLSIpJiYoZD1uLmNhbWVsQ2FzZShkLnNsaWNlKDUpKSxQKGYsZCxlW2RdKSkpO24uX2RhdGEoZiwicGFyc2VkQXR0cnMiLCEwKX1yZXR1cm4gZX1yZXR1cm4ib2JqZWN0Ij09dHlwZW9mIGE/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7bi5kYXRhKHRoaXMsYSl9KTphcmd1bWVudHMubGVuZ3RoPjE/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7bi5kYXRhKHRoaXMsYSxiKX0pOmY/UChmLGEsbi5kYXRhKGYsYSkpOnZvaWQgMH0scmVtb3ZlRGF0YTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bi5yZW1vdmVEYXRhKHRoaXMsYSl9KX19KSxuLmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO3JldHVybiBhPyhiPShifHwiZngiKSsicXVldWUiLGQ9bi5fZGF0YShhLGIpLGMmJighZHx8bi5pc0FycmF5KGMpP2Q9bi5fZGF0YShhLGIsbi5tYWtlQXJyYXkoYykpOmQucHVzaChjKSksZHx8W10pOnZvaWQgMH0sZGVxdWV1ZTpmdW5jdGlvbihhLGIpe2I9Ynx8ImZ4Ijt2YXIgYz1uLnF1ZXVlKGEsYiksZD1jLmxlbmd0aCxlPWMuc2hpZnQoKSxmPW4uX3F1ZXVlSG9va3MoYSxiKSxnPWZ1bmN0aW9uKCl7bi5kZXF1ZXVlKGEsYil9OyJpbnByb2dyZXNzIj09PWUmJihlPWMuc2hpZnQoKSxkLS0pLGUmJigiZngiPT09YiYmYy51bnNoaWZ0KCJpbnByb2dyZXNzIiksZGVsZXRlIGYuc3RvcCxlLmNhbGwoYSxnLGYpKSwhZCYmZiYmZi5lbXB0eS5maXJlKCl9LF9xdWV1ZUhvb2tzOmZ1bmN0aW9uKGEsYil7dmFyIGM9YisicXVldWVIb29rcyI7cmV0dXJuIG4uX2RhdGEoYSxjKXx8bi5fZGF0YShhLGMse2VtcHR5Om4uQ2FsbGJhY2tzKCJvbmNlIG1lbW9yeSIpLmFkZChmdW5jdGlvbigpe24uX3JlbW92ZURhdGEoYSxiKyJxdWV1ZSIpLG4uX3JlbW92ZURhdGEoYSxjKX0pfSl9fSksbi5mbi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9MjtyZXR1cm4ic3RyaW5nIiE9dHlwZW9mIGEmJihiPWEsYT0iZngiLGMtLSksYXJndW1lbnRzLmxlbmd0aDxjP24ucXVldWUodGhpc1swXSxhKTp2b2lkIDA9PT1iP3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9bi5xdWV1ZSh0aGlzLGEsYik7bi5fcXVldWVIb29rcyh0aGlzLGEpLCJmeCI9PT1hJiYiaW5wcm9ncmVzcyIhPT1jWzBdJiZuLmRlcXVldWUodGhpcyxhKX0pfSxkZXF1ZXVlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtuLmRlcXVldWUodGhpcyxhKX0pfSxjbGVhclF1ZXVlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnF1ZXVlKGF8fCJmeCIsW10pfSxwcm9taXNlOmZ1bmN0aW9uKGEsYil7dmFyIGMsZD0xLGU9bi5EZWZlcnJlZCgpLGY9dGhpcyxnPXRoaXMubGVuZ3RoLGg9ZnVuY3Rpb24oKXstLWR8fGUucmVzb2x2ZVdpdGgoZixbZl0pfTsic3RyaW5nIiE9dHlwZW9mIGEmJihiPWEsYT12b2lkIDApLGE9YXx8ImZ4Ijt3aGlsZShnLS0pYz1uLl9kYXRhKGZbZ10sYSsicXVldWVIb29rcyIpLGMmJmMuZW1wdHkmJihkKyssYy5lbXB0eS5hZGQoaCkpO3JldHVybiBoKCksZS5wcm9taXNlKGIpfX0pLGZ1bmN0aW9uKCl7dmFyIGE7bC5zaHJpbmtXcmFwQmxvY2tzPWZ1bmN0aW9uKCl7aWYobnVsbCE9YSlyZXR1cm4gYTthPSExO3ZhciBiLGMsZTtyZXR1cm4gYz1kLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJib2R5IilbMF0sYyYmYy5zdHlsZT8oYj1kLmNyZWF0ZUVsZW1lbnQoImRpdiIpLGU9ZC5jcmVhdGVFbGVtZW50KCJkaXYiKSxlLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2JvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4IixjLmFwcGVuZENoaWxkKGUpLmFwcGVuZENoaWxkKGIpLCJ1bmRlZmluZWQiIT10eXBlb2YgYi5zdHlsZS56b29tJiYoYi5zdHlsZS5jc3NUZXh0PSItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjFweDt3aWR0aDoxcHg7em9vbToxIixiLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudCgiZGl2IikpLnN0eWxlLndpZHRoPSI1cHgiLGE9MyE9PWIub2Zmc2V0V2lkdGgpLGMucmVtb3ZlQ2hpbGQoZSksYSk6dm9pZCAwfX0oKTt2YXIgVD0vWystXT8oPzpcZCpcLnwpXGQrKD86W2VFXVsrLV0/XGQrfCkvLnNvdXJjZSxVPW5ldyBSZWdFeHAoIl4oPzooWystXSk9fCkoIitUKyIpKFthLXolXSopJCIsImkiKSxWPVsiVG9wIiwiUmlnaHQiLCJCb3R0b20iLCJMZWZ0Il0sVz1mdW5jdGlvbihhLGIpe3JldHVybiBhPWJ8fGEsIm5vbmUiPT09bi5jc3MoYSwiZGlzcGxheSIpfHwhbi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsYSl9O2Z1bmN0aW9uIFgoYSxiLGMsZCl7dmFyIGUsZj0xLGc9MjAsaD1kP2Z1bmN0aW9uKCl7cmV0dXJuIGQuY3VyKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG4uY3NzKGEsYiwiIil9LGk9aCgpLGo9YyYmY1szXXx8KG4uY3NzTnVtYmVyW2JdPyIiOiJweCIpLGs9KG4uY3NzTnVtYmVyW2JdfHwicHgiIT09aiYmK2kpJiZVLmV4ZWMobi5jc3MoYSxiKSk7aWYoayYma1szXSE9PWope2o9anx8a1szXSxjPWN8fFtdLGs9K2l8fDE7ZG8gZj1mfHwiLjUiLGsvPWYsbi5zdHlsZShhLGIsaytqKTt3aGlsZShmIT09KGY9aCgpL2kpJiYxIT09ZiYmLS1nKX1yZXR1cm4gYyYmKGs9K2t8fCtpfHwwLGU9Y1sxXT9rKyhjWzFdKzEpKmNbMl06K2NbMl0sZCYmKGQudW5pdD1qLGQuc3RhcnQ9ayxkLmVuZD1lKSksZX12YXIgWT1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXt2YXIgaD0wLGk9YS5sZW5ndGgsaj1udWxsPT1jO2lmKCJvYmplY3QiPT09bi50eXBlKGMpKXtlPSEwO2ZvcihoIGluIGMpWShhLGIsaCxjW2hdLCEwLGYsZyl9ZWxzZSBpZih2b2lkIDAhPT1kJiYoZT0hMCxuLmlzRnVuY3Rpb24oZCl8fChnPSEwKSxqJiYoZz8oYi5jYWxsKGEsZCksYj1udWxsKTooaj1iLGI9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBqLmNhbGwobihhKSxjKX0pKSxiKSlmb3IoO2k+aDtoKyspYihhW2hdLGMsZz9kOmQuY2FsbChhW2hdLGgsYihhW2hdLGMpKSk7cmV0dXJuIGU/YTpqP2IuY2FsbChhKTppP2IoYVswXSxjKTpmfSxaPS9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLCQ9LzwoW1x3Oi1dKykvLF89L14kfFwvKD86amF2YXxlY21hKXNjcmlwdC9pLGFhPS9eXHMrLyxiYT0iYWJicnxhcnRpY2xlfGFzaWRlfGF1ZGlvfGJkaXxjYW52YXN8ZGF0YXxkYXRhbGlzdHxkZXRhaWxzfGRpYWxvZ3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8aGVhZGVyfGhncm91cHxtYWlufG1hcmt8bWV0ZXJ8bmF2fG91dHB1dHxwaWN0dXJlfHByb2dyZXNzfHNlY3Rpb258c3VtbWFyeXx0ZW1wbGF0ZXx0aW1lfHZpZGVvIjtmdW5jdGlvbiBjYShhKXt2YXIgYj1iYS5zcGxpdCgifCIpLGM9YS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7aWYoYy5jcmVhdGVFbGVtZW50KXdoaWxlKGIubGVuZ3RoKWMuY3JlYXRlRWxlbWVudChiLnBvcCgpKTtyZXR1cm4gY30hZnVuY3Rpb24oKXt2YXIgYT1kLmNyZWF0ZUVsZW1lbnQoImRpdiIpLGI9ZC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksYz1kLmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7YS5pbm5lckhUTUw9IiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPiIsbC5sZWFkaW5nV2hpdGVzcGFjZT0zPT09YS5maXJzdENoaWxkLm5vZGVUeXBlLGwudGJvZHk9IWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInRib2R5IikubGVuZ3RoLGwuaHRtbFNlcmlhbGl6ZT0hIWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImxpbmsiKS5sZW5ndGgsbC5odG1sNUNsb25lPSI8Om5hdj48LzpuYXY+IiE9PWQuY3JlYXRlRWxlbWVudCgibmF2IikuY2xvbmVOb2RlKCEwKS5vdXRlckhUTUwsYy50eXBlPSJjaGVja2JveCIsYy5jaGVja2VkPSEwLGIuYXBwZW5kQ2hpbGQoYyksbC5hcHBlbmRDaGVja2VkPWMuY2hlY2tlZCxhLmlubmVySFRNTD0iPHRleHRhcmVhPng8L3RleHRhcmVhPiIsbC5ub0Nsb25lQ2hlY2tlZD0hIWEuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlLGIuYXBwZW5kQ2hpbGQoYSksYz1kLmNyZWF0ZUVsZW1lbnQoImlucHV0IiksYy5zZXRBdHRyaWJ1dGUoInR5cGUiLCJyYWRpbyIpLGMuc2V0QXR0cmlidXRlKCJjaGVja2VkIiwiY2hlY2tlZCIpLGMuc2V0QXR0cmlidXRlKCJuYW1lIiwidCIpLGEuYXBwZW5kQ2hpbGQoYyksbC5jaGVja0Nsb25lPWEuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLGwubm9DbG9uZUV2ZW50PSEhYS5hZGRFdmVudExpc3RlbmVyLGFbbi5leHBhbmRvXT0xLGwuYXR0cmlidXRlcz0hYS5nZXRBdHRyaWJ1dGUobi5leHBhbmRvKX0oKTt2YXIgZGE9e29wdGlvbjpbMSwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPiIsIjwvc2VsZWN0PiJdLGxlZ2VuZDpbMSwiPGZpZWxkc2V0PiIsIjwvZmllbGRzZXQ+Il0sYXJlYTpbMSwiPG1hcD4iLCI8L21hcD4iXSxwYXJhbTpbMSwiPG9iamVjdD4iLCI8L29iamVjdD4iXSx0aGVhZDpbMSwiPHRhYmxlPiIsIjwvdGFibGU+Il0sdHI6WzIsIjx0YWJsZT48dGJvZHk+IiwiPC90Ym9keT48L3RhYmxlPiJdLGNvbDpbMiwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4iLCI8L2NvbGdyb3VwPjwvdGFibGU+Il0sdGQ6WzMsIjx0YWJsZT48dGJvZHk+PHRyPiIsIjwvdHI+PC90Ym9keT48L3RhYmxlPiJdLF9kZWZhdWx0OmwuaHRtbFNlcmlhbGl6ZT9bMCwiIiwiIl06WzEsIlg8ZGl2PiIsIjwvZGl2PiJdfTtkYS5vcHRncm91cD1kYS5vcHRpb24sZGEudGJvZHk9ZGEudGZvb3Q9ZGEuY29sZ3JvdXA9ZGEuY2FwdGlvbj1kYS50aGVhZCxkYS50aD1kYS50ZDtmdW5jdGlvbiBlYShhLGIpe3ZhciBjLGQsZT0wLGY9InVuZGVmaW5lZCIhPXR5cGVvZiBhLmdldEVsZW1lbnRzQnlUYWdOYW1lP2EuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYnx8IioiKToidW5kZWZpbmVkIiE9dHlwZW9mIGEucXVlcnlTZWxlY3RvckFsbD9hLnF1ZXJ5U2VsZWN0b3JBbGwoYnx8IioiKTp2b2lkIDA7aWYoIWYpZm9yKGY9W10sYz1hLmNoaWxkTm9kZXN8fGE7bnVsbCE9KGQ9Y1tlXSk7ZSsrKSFifHxuLm5vZGVOYW1lKGQsYik/Zi5wdXNoKGQpOm4ubWVyZ2UoZixlYShkLGIpKTtyZXR1cm4gdm9pZCAwPT09Ynx8YiYmbi5ub2RlTmFtZShhLGIpP24ubWVyZ2UoW2FdLGYpOmZ9ZnVuY3Rpb24gZmEoYSxiKXtmb3IodmFyIGMsZD0wO251bGwhPShjPWFbZF0pO2QrKyluLl9kYXRhKGMsImdsb2JhbEV2YWwiLCFifHxuLl9kYXRhKGJbZF0sImdsb2JhbEV2YWwiKSl9dmFyIGdhPS88fCYjP1x3KzsvLGhhPS88dGJvZHkvaTtmdW5jdGlvbiBpYShhKXtaLnRlc3QoYS50eXBlKSYmKGEuZGVmYXVsdENoZWNrZWQ9YS5jaGVja2VkKX1mdW5jdGlvbiBqYShhLGIsYyxkLGUpe2Zvcih2YXIgZixnLGgsaSxqLGssbSxvPWEubGVuZ3RoLHA9Y2EoYikscT1bXSxyPTA7bz5yO3IrKylpZihnPWFbcl0sZ3x8MD09PWcpaWYoIm9iamVjdCI9PT1uLnR5cGUoZykpbi5tZXJnZShxLGcubm9kZVR5cGU/W2ddOmcpO2Vsc2UgaWYoZ2EudGVzdChnKSl7aT1pfHxwLmFwcGVuZENoaWxkKGIuY3JlYXRlRWxlbWVudCgiZGl2IikpLGo9KCQuZXhlYyhnKXx8WyIiLCIiXSlbMV0udG9Mb3dlckNhc2UoKSxtPWRhW2pdfHxkYS5fZGVmYXVsdCxpLmlubmVySFRNTD1tWzFdK24uaHRtbFByZWZpbHRlcihnKSttWzJdLGY9bVswXTt3aGlsZShmLS0paT1pLmxhc3RDaGlsZDtpZighbC5sZWFkaW5nV2hpdGVzcGFjZSYmYWEudGVzdChnKSYmcS5wdXNoKGIuY3JlYXRlVGV4dE5vZGUoYWEuZXhlYyhnKVswXSkpLCFsLnRib2R5KXtnPSJ0YWJsZSIhPT1qfHxoYS50ZXN0KGcpPyI8dGFibGU+IiE9PW1bMV18fGhhLnRlc3QoZyk/MDppOmkuZmlyc3RDaGlsZCxmPWcmJmcuY2hpbGROb2Rlcy5sZW5ndGg7d2hpbGUoZi0tKW4ubm9kZU5hbWUoaz1nLmNoaWxkTm9kZXNbZl0sInRib2R5IikmJiFrLmNoaWxkTm9kZXMubGVuZ3RoJiZnLnJlbW92ZUNoaWxkKGspfW4ubWVyZ2UocSxpLmNoaWxkTm9kZXMpLGkudGV4dENvbnRlbnQ9IiI7d2hpbGUoaS5maXJzdENoaWxkKWkucmVtb3ZlQ2hpbGQoaS5maXJzdENoaWxkKTtpPXAubGFzdENoaWxkfWVsc2UgcS5wdXNoKGIuY3JlYXRlVGV4dE5vZGUoZykpO2kmJnAucmVtb3ZlQ2hpbGQoaSksbC5hcHBlbmRDaGVja2VkfHxuLmdyZXAoZWEocSwiaW5wdXQiKSxpYSkscj0wO3doaWxlKGc9cVtyKytdKWlmKGQmJm4uaW5BcnJheShnLGQpPi0xKWUmJmUucHVzaChnKTtlbHNlIGlmKGg9bi5jb250YWlucyhnLm93bmVyRG9jdW1lbnQsZyksaT1lYShwLmFwcGVuZENoaWxkKGcpLCJzY3JpcHQiKSxoJiZmYShpKSxjKXtmPTA7d2hpbGUoZz1pW2YrK10pXy50ZXN0KGcudHlwZXx8IiIpJiZjLnB1c2goZyl9cmV0dXJuIGk9bnVsbCxwfSFmdW5jdGlvbigpe3ZhciBiLGMsZT1kLmNyZWF0ZUVsZW1lbnQoImRpdiIpO2ZvcihiIGlue3N1Ym1pdDohMCxjaGFuZ2U6ITAsZm9jdXNpbjohMH0pYz0ib24iK2IsKGxbYl09YyBpbiBhKXx8KGUuc2V0QXR0cmlidXRlKGMsInQiKSxsW2JdPWUuYXR0cmlidXRlc1tjXS5leHBhbmRvPT09ITEpO2U9bnVsbH0oKTt2YXIga2E9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pLGxhPS9ea2V5LyxtYT0vXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sbmE9L14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLG9hPS9eKFteLl0qKSg/OlwuKC4rKXwpLztmdW5jdGlvbiBwYSgpe3JldHVybiEwfWZ1bmN0aW9uIHFhKCl7cmV0dXJuITF9ZnVuY3Rpb24gcmEoKXt0cnl7cmV0dXJuIGQuYWN0aXZlRWxlbWVudH1jYXRjaChhKXt9fWZ1bmN0aW9uIHNhKGEsYixjLGQsZSxmKXt2YXIgZyxoO2lmKCJvYmplY3QiPT10eXBlb2YgYil7InN0cmluZyIhPXR5cGVvZiBjJiYoZD1kfHxjLGM9dm9pZCAwKTtmb3IoaCBpbiBiKXNhKGEsaCxjLGQsYltoXSxmKTtyZXR1cm4gYX1pZihudWxsPT1kJiZudWxsPT1lPyhlPWMsZD1jPXZvaWQgMCk6bnVsbD09ZSYmKCJzdHJpbmciPT10eXBlb2YgYz8oZT1kLGQ9dm9pZCAwKTooZT1kLGQ9YyxjPXZvaWQgMCkpLGU9PT0hMSllPXFhO2Vsc2UgaWYoIWUpcmV0dXJuIGE7cmV0dXJuIDE9PT1mJiYoZz1lLGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG4oKS5vZmYoYSksZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGUuZ3VpZD1nLmd1aWR8fChnLmd1aWQ9bi5ndWlkKyspKSxhLmVhY2goZnVuY3Rpb24oKXtuLmV2ZW50LmFkZCh0aGlzLGIsZSxkLGMpfSl9bi5ldmVudD17Z2xvYmFsOnt9LGFkZDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGcsaCxpLGosayxsLG0sbyxwLHEscj1uLl9kYXRhKGEpO2lmKHIpe2MuaGFuZGxlciYmKGk9YyxjPWkuaGFuZGxlcixlPWkuc2VsZWN0b3IpLGMuZ3VpZHx8KGMuZ3VpZD1uLmd1aWQrKyksKGc9ci5ldmVudHMpfHwoZz1yLmV2ZW50cz17fSksKGs9ci5oYW5kbGUpfHwoaz1yLmhhbmRsZT1mdW5jdGlvbihhKXtyZXR1cm4idW5kZWZpbmVkIj09dHlwZW9mIG58fGEmJm4uZXZlbnQudHJpZ2dlcmVkPT09YS50eXBlP3ZvaWQgMDpuLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGsuZWxlbSxhcmd1bWVudHMpfSxrLmVsZW09YSksYj0oYnx8IiIpLm1hdGNoKEcpfHxbIiJdLGg9Yi5sZW5ndGg7d2hpbGUoaC0tKWY9b2EuZXhlYyhiW2hdKXx8W10sbz1xPWZbMV0scD0oZlsyXXx8IiIpLnNwbGl0KCIuIikuc29ydCgpLG8mJihqPW4uZXZlbnQuc3BlY2lhbFtvXXx8e30sbz0oZT9qLmRlbGVnYXRlVHlwZTpqLmJpbmRUeXBlKXx8byxqPW4uZXZlbnQuc3BlY2lhbFtvXXx8e30sbD1uLmV4dGVuZCh7dHlwZTpvLG9yaWdUeXBlOnEsZGF0YTpkLGhhbmRsZXI6YyxndWlkOmMuZ3VpZCxzZWxlY3RvcjplLG5lZWRzQ29udGV4dDplJiZuLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoZSksbmFtZXNwYWNlOnAuam9pbigiLiIpfSxpKSwobT1nW29dKXx8KG09Z1tvXT1bXSxtLmRlbGVnYXRlQ291bnQ9MCxqLnNldHVwJiZqLnNldHVwLmNhbGwoYSxkLHAsaykhPT0hMXx8KGEuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIobyxrLCExKTphLmF0dGFjaEV2ZW50JiZhLmF0dGFjaEV2ZW50KCJvbiIrbyxrKSkpLGouYWRkJiYoai5hZGQuY2FsbChhLGwpLGwuaGFuZGxlci5ndWlkfHwobC5oYW5kbGVyLmd1aWQ9Yy5ndWlkKSksZT9tLnNwbGljZShtLmRlbGVnYXRlQ291bnQrKywwLGwpOm0ucHVzaChsKSxuLmV2ZW50Lmdsb2JhbFtvXT0hMCk7YT1udWxsfX0scmVtb3ZlOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGksaixrLGwsbSxvLHAscSxyPW4uaGFzRGF0YShhKSYmbi5fZGF0YShhKTtpZihyJiYoaz1yLmV2ZW50cykpe2I9KGJ8fCIiKS5tYXRjaChHKXx8WyIiXSxqPWIubGVuZ3RoO3doaWxlKGotLSlpZihoPW9hLmV4ZWMoYltqXSl8fFtdLG89cT1oWzFdLHA9KGhbMl18fCIiKS5zcGxpdCgiLiIpLnNvcnQoKSxvKXtsPW4uZXZlbnQuc3BlY2lhbFtvXXx8e30sbz0oZD9sLmRlbGVnYXRlVHlwZTpsLmJpbmRUeXBlKXx8byxtPWtbb118fFtdLGg9aFsyXSYmbmV3IFJlZ0V4cCgiKF58XFwuKSIrcC5qb2luKCJcXC4oPzouKlxcLnwpIikrIihcXC58JCkiKSxpPWY9bS5sZW5ndGg7d2hpbGUoZi0tKWc9bVtmXSwhZSYmcSE9PWcub3JpZ1R5cGV8fGMmJmMuZ3VpZCE9PWcuZ3VpZHx8aCYmIWgudGVzdChnLm5hbWVzcGFjZSl8fGQmJmQhPT1nLnNlbGVjdG9yJiYoIioqIiE9PWR8fCFnLnNlbGVjdG9yKXx8KG0uc3BsaWNlKGYsMSksZy5zZWxlY3RvciYmbS5kZWxlZ2F0ZUNvdW50LS0sbC5yZW1vdmUmJmwucmVtb3ZlLmNhbGwoYSxnKSk7aSYmIW0ubGVuZ3RoJiYobC50ZWFyZG93biYmbC50ZWFyZG93bi5jYWxsKGEscCxyLmhhbmRsZSkhPT0hMXx8bi5yZW1vdmVFdmVudChhLG8sci5oYW5kbGUpLGRlbGV0ZSBrW29dKX1lbHNlIGZvcihvIGluIGspbi5ldmVudC5yZW1vdmUoYSxvK2Jbal0sYyxkLCEwKTtuLmlzRW1wdHlPYmplY3QoaykmJihkZWxldGUgci5oYW5kbGUsbi5fcmVtb3ZlRGF0YShhLCJldmVudHMiKSl9fSx0cmlnZ2VyOmZ1bmN0aW9uKGIsYyxlLGYpe3ZhciBnLGgsaSxqLGwsbSxvLHA9W2V8fGRdLHE9ay5jYWxsKGIsInR5cGUiKT9iLnR5cGU6YixyPWsuY2FsbChiLCJuYW1lc3BhY2UiKT9iLm5hbWVzcGFjZS5zcGxpdCgiLiIpOltdO2lmKGk9bT1lPWV8fGQsMyE9PWUubm9kZVR5cGUmJjghPT1lLm5vZGVUeXBlJiYhbmEudGVzdChxK24uZXZlbnQudHJpZ2dlcmVkKSYmKHEuaW5kZXhPZigiLiIpPi0xJiYocj1xLnNwbGl0KCIuIikscT1yLnNoaWZ0KCksci5zb3J0KCkpLGg9cS5pbmRleE9mKCI6Iik8MCYmIm9uIitxLGI9YltuLmV4cGFuZG9dP2I6bmV3IG4uRXZlbnQocSwib2JqZWN0Ij09dHlwZW9mIGImJmIpLGIuaXNUcmlnZ2VyPWY/MjozLGIubmFtZXNwYWNlPXIuam9pbigiLiIpLGIucm5hbWVzcGFjZT1iLm5hbWVzcGFjZT9uZXcgUmVnRXhwKCIoXnxcXC4pIityLmpvaW4oIlxcLig/Oi4qXFwufCkiKSsiKFxcLnwkKSIpOm51bGwsYi5yZXN1bHQ9dm9pZCAwLGIudGFyZ2V0fHwoYi50YXJnZXQ9ZSksYz1udWxsPT1jP1tiXTpuLm1ha2VBcnJheShjLFtiXSksbD1uLmV2ZW50LnNwZWNpYWxbcV18fHt9LGZ8fCFsLnRyaWdnZXJ8fGwudHJpZ2dlci5hcHBseShlLGMpIT09ITEpKXtpZighZiYmIWwubm9CdWJibGUmJiFuLmlzV2luZG93KGUpKXtmb3Ioaj1sLmRlbGVnYXRlVHlwZXx8cSxuYS50ZXN0KGorcSl8fChpPWkucGFyZW50Tm9kZSk7aTtpPWkucGFyZW50Tm9kZSlwLnB1c2goaSksbT1pO209PT0oZS5vd25lckRvY3VtZW50fHxkKSYmcC5wdXNoKG0uZGVmYXVsdFZpZXd8fG0ucGFyZW50V2luZG93fHxhKX1vPTA7d2hpbGUoKGk9cFtvKytdKSYmIWIuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSliLnR5cGU9bz4xP2o6bC5iaW5kVHlwZXx8cSxnPShuLl9kYXRhKGksImV2ZW50cyIpfHx7fSlbYi50eXBlXSYmbi5fZGF0YShpLCJoYW5kbGUiKSxnJiZnLmFwcGx5KGksYyksZz1oJiZpW2hdLGcmJmcuYXBwbHkmJk0oaSkmJihiLnJlc3VsdD1nLmFwcGx5KGksYyksYi5yZXN1bHQ9PT0hMSYmYi5wcmV2ZW50RGVmYXVsdCgpKTtpZihiLnR5cGU9cSwhZiYmIWIuaXNEZWZhdWx0UHJldmVudGVkKCkmJighbC5fZGVmYXVsdHx8bC5fZGVmYXVsdC5hcHBseShwLnBvcCgpLGMpPT09ITEpJiZNKGUpJiZoJiZlW3FdJiYhbi5pc1dpbmRvdyhlKSl7bT1lW2hdLG0mJihlW2hdPW51bGwpLG4uZXZlbnQudHJpZ2dlcmVkPXE7dHJ5e2VbcV0oKX1jYXRjaChzKXt9bi5ldmVudC50cmlnZ2VyZWQ9dm9pZCAwLG0mJihlW2hdPW0pfXJldHVybiBiLnJlc3VsdH19LGRpc3BhdGNoOmZ1bmN0aW9uKGEpe2E9bi5ldmVudC5maXgoYSk7dmFyIGIsYyxkLGYsZyxoPVtdLGk9ZS5jYWxsKGFyZ3VtZW50cyksaj0obi5fZGF0YSh0aGlzLCJldmVudHMiKXx8e30pW2EudHlwZV18fFtdLGs9bi5ldmVudC5zcGVjaWFsW2EudHlwZV18fHt9O2lmKGlbMF09YSxhLmRlbGVnYXRlVGFyZ2V0PXRoaXMsIWsucHJlRGlzcGF0Y2h8fGsucHJlRGlzcGF0Y2guY2FsbCh0aGlzLGEpIT09ITEpe2g9bi5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsYSxqKSxiPTA7d2hpbGUoKGY9aFtiKytdKSYmIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSl7YS5jdXJyZW50VGFyZ2V0PWYuZWxlbSxjPTA7d2hpbGUoKGc9Zi5oYW5kbGVyc1tjKytdKSYmIWEuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkoIWEucm5hbWVzcGFjZXx8YS5ybmFtZXNwYWNlLnRlc3QoZy5uYW1lc3BhY2UpKSYmKGEuaGFuZGxlT2JqPWcsYS5kYXRhPWcuZGF0YSxkPSgobi5ldmVudC5zcGVjaWFsW2cub3JpZ1R5cGVdfHx7fSkuaGFuZGxlfHxnLmhhbmRsZXIpLmFwcGx5KGYuZWxlbSxpKSx2b2lkIDAhPT1kJiYoYS5yZXN1bHQ9ZCk9PT0hMSYmKGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpKSl9cmV0dXJuIGsucG9zdERpc3BhdGNoJiZrLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsYSksYS5yZXN1bHR9fSxoYW5kbGVyczpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGc9W10saD1iLmRlbGVnYXRlQ291bnQsaT1hLnRhcmdldDtpZihoJiZpLm5vZGVUeXBlJiYoImNsaWNrIiE9PWEudHlwZXx8aXNOYU4oYS5idXR0b24pfHxhLmJ1dHRvbjwxKSlmb3IoO2khPXRoaXM7aT1pLnBhcmVudE5vZGV8fHRoaXMpaWYoMT09PWkubm9kZVR5cGUmJihpLmRpc2FibGVkIT09ITB8fCJjbGljayIhPT1hLnR5cGUpKXtmb3IoZD1bXSxjPTA7aD5jO2MrKylmPWJbY10sZT1mLnNlbGVjdG9yKyIgIix2b2lkIDA9PT1kW2VdJiYoZFtlXT1mLm5lZWRzQ29udGV4dD9uKGUsdGhpcykuaW5kZXgoaSk+LTE6bi5maW5kKGUsdGhpcyxudWxsLFtpXSkubGVuZ3RoKSxkW2VdJiZkLnB1c2goZik7ZC5sZW5ndGgmJmcucHVzaCh7ZWxlbTppLGhhbmRsZXJzOmR9KX1yZXR1cm4gaDxiLmxlbmd0aCYmZy5wdXNoKHtlbGVtOnRoaXMsaGFuZGxlcnM6Yi5zbGljZShoKX0pLGd9LGZpeDpmdW5jdGlvbihhKXtpZihhW24uZXhwYW5kb10pcmV0dXJuIGE7dmFyIGIsYyxlLGY9YS50eXBlLGc9YSxoPXRoaXMuZml4SG9va3NbZl07aHx8KHRoaXMuZml4SG9va3NbZl09aD1tYS50ZXN0KGYpP3RoaXMubW91c2VIb29rczpsYS50ZXN0KGYpP3RoaXMua2V5SG9va3M6e30pLGU9aC5wcm9wcz90aGlzLnByb3BzLmNvbmNhdChoLnByb3BzKTp0aGlzLnByb3BzLGE9bmV3IG4uRXZlbnQoZyksYj1lLmxlbmd0aDt3aGlsZShiLS0pYz1lW2JdLGFbY109Z1tjXTtyZXR1cm4gYS50YXJnZXR8fChhLnRhcmdldD1nLnNyY0VsZW1lbnR8fGQpLDM9PT1hLnRhcmdldC5ub2RlVHlwZSYmKGEudGFyZ2V0PWEudGFyZ2V0LnBhcmVudE5vZGUpLGEubWV0YUtleT0hIWEubWV0YUtleSxoLmZpbHRlcj9oLmZpbHRlcihhLGcpOmF9LHByb3BzOiJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBkZXRhaWwgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoIi5zcGxpdCgiICIpLGZpeEhvb2tzOnt9LGtleUhvb2tzOntwcm9wczoiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZSIuc3BsaXQoIiAiKSxmaWx0ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbD09YS53aGljaCYmKGEud2hpY2g9bnVsbCE9Yi5jaGFyQ29kZT9iLmNoYXJDb2RlOmIua2V5Q29kZSksYX19LG1vdXNlSG9va3M6e3Byb3BzOiJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnQiLnNwbGl0KCIgIiksZmlsdGVyOmZ1bmN0aW9uKGEsYil7dmFyIGMsZSxmLGc9Yi5idXR0b24saD1iLmZyb21FbGVtZW50O3JldHVybiBudWxsPT1hLnBhZ2VYJiZudWxsIT1iLmNsaWVudFgmJihlPWEudGFyZ2V0Lm93bmVyRG9jdW1lbnR8fGQsZj1lLmRvY3VtZW50RWxlbWVudCxjPWUuYm9keSxhLnBhZ2VYPWIuY2xpZW50WCsoZiYmZi5zY3JvbGxMZWZ0fHxjJiZjLnNjcm9sbExlZnR8fDApLShmJiZmLmNsaWVudExlZnR8fGMmJmMuY2xpZW50TGVmdHx8MCksYS5wYWdlWT1iLmNsaWVudFkrKGYmJmYuc2Nyb2xsVG9wfHxjJiZjLnNjcm9sbFRvcHx8MCktKGYmJmYuY2xpZW50VG9wfHxjJiZjLmNsaWVudFRvcHx8MCkpLCFhLnJlbGF0ZWRUYXJnZXQmJmgmJihhLnJlbGF0ZWRUYXJnZXQ9aD09PWEudGFyZ2V0P2IudG9FbGVtZW50OmgpLGEud2hpY2h8fHZvaWQgMD09PWd8fChhLndoaWNoPTEmZz8xOjImZz8zOjQmZz8yOjApLGF9fSxzcGVjaWFsOntsb2FkOntub0J1YmJsZTohMH0sZm9jdXM6e3RyaWdnZXI6ZnVuY3Rpb24oKXtpZih0aGlzIT09cmEoKSYmdGhpcy5mb2N1cyl0cnl7cmV0dXJuIHRoaXMuZm9jdXMoKSwhMX1jYXRjaChhKXt9fSxkZWxlZ2F0ZVR5cGU6ImZvY3VzaW4ifSxibHVyOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXM9PT1yYSgpJiZ0aGlzLmJsdXI/KHRoaXMuYmx1cigpLCExKTp2b2lkIDB9LGRlbGVnYXRlVHlwZToiZm9jdXNvdXQifSxjbGljazp7dHJpZ2dlcjpmdW5jdGlvbigpe3JldHVybiBuLm5vZGVOYW1lKHRoaXMsImlucHV0IikmJiJjaGVja2JveCI9PT10aGlzLnR5cGUmJnRoaXMuY2xpY2s/KHRoaXMuY2xpY2soKSwhMSk6dm9pZCAwfSxfZGVmYXVsdDpmdW5jdGlvbihhKXtyZXR1cm4gbi5ub2RlTmFtZShhLnRhcmdldCwiYSIpfX0sYmVmb3JldW5sb2FkOntwb3N0RGlzcGF0Y2g6ZnVuY3Rpb24oYSl7dm9pZCAwIT09YS5yZXN1bHQmJmEub3JpZ2luYWxFdmVudCYmKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZT1hLnJlc3VsdCl9fX0sc2ltdWxhdGU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW4uZXh0ZW5kKG5ldyBuLkV2ZW50LGMse3R5cGU6YSxpc1NpbXVsYXRlZDohMH0pO24uZXZlbnQudHJpZ2dlcihkLG51bGwsYiksZC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmYy5wcmV2ZW50RGVmYXVsdCgpfX0sbi5yZW1vdmVFdmVudD1kLnJlbW92ZUV2ZW50TGlzdGVuZXI/ZnVuY3Rpb24oYSxiLGMpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lciYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsYyl9OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD0ib24iK2I7YS5kZXRhY2hFdmVudCYmKCJ1bmRlZmluZWQiPT10eXBlb2YgYVtkXSYmKGFbZF09bnVsbCksYS5kZXRhY2hFdmVudChkLGMpKX0sbi5FdmVudD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzIGluc3RhbmNlb2Ygbi5FdmVudD8oYSYmYS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9YSx0aGlzLnR5cGU9YS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWEuZGVmYXVsdFByZXZlbnRlZHx8dm9pZCAwPT09YS5kZWZhdWx0UHJldmVudGVkJiZhLnJldHVyblZhbHVlPT09ITE/cGE6cWEpOnRoaXMudHlwZT1hLGImJm4uZXh0ZW5kKHRoaXMsYiksdGhpcy50aW1lU3RhbXA9YSYmYS50aW1lU3RhbXB8fG4ubm93KCksdm9pZCh0aGlzW24uZXhwYW5kb109ITApKTpuZXcgbi5FdmVudChhLGIpfSxuLkV2ZW50LnByb3RvdHlwZT17Y29uc3RydWN0b3I6bi5FdmVudCxpc0RlZmF1bHRQcmV2ZW50ZWQ6cWEsaXNQcm9wYWdhdGlvblN0b3BwZWQ6cWEsaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6cWEscHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9cGEsYSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOmEucmV0dXJuVmFsdWU9ITEpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1wYSxhJiYhdGhpcy5pc1NpbXVsYXRlZCYmKGEuc3RvcFByb3BhZ2F0aW9uJiZhLnN0b3BQcm9wYWdhdGlvbigpLGEuY2FuY2VsQnViYmxlPSEwKX0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9cGEsYSYmYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24mJmEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdGhpcy5zdG9wUHJvcGFnYXRpb24oKX19LG4uZWFjaCh7bW91c2VlbnRlcjoibW91c2VvdmVyIixtb3VzZWxlYXZlOiJtb3VzZW91dCIscG9pbnRlcmVudGVyOiJwb2ludGVyb3ZlciIscG9pbnRlcmxlYXZlOiJwb2ludGVyb3V0In0sZnVuY3Rpb24oYSxiKXtuLmV2ZW50LnNwZWNpYWxbYV09e2RlbGVnYXRlVHlwZTpiLGJpbmRUeXBlOmIsaGFuZGxlOmZ1bmN0aW9uKGEpe3ZhciBjLGQ9dGhpcyxlPWEucmVsYXRlZFRhcmdldCxmPWEuaGFuZGxlT2JqO3JldHVybighZXx8ZSE9PWQmJiFuLmNvbnRhaW5zKGQsZSkpJiYoYS50eXBlPWYub3JpZ1R5cGUsYz1mLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGEudHlwZT1iKSxjfX19KSxsLnN1Ym1pdHx8KG4uZXZlbnQuc3BlY2lhbC5zdWJtaXQ9e3NldHVwOmZ1bmN0aW9uKCl7cmV0dXJuIG4ubm9kZU5hbWUodGhpcywiZm9ybSIpPyExOnZvaWQgbi5ldmVudC5hZGQodGhpcywiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0IixmdW5jdGlvbihhKXt2YXIgYj1hLnRhcmdldCxjPW4ubm9kZU5hbWUoYiwiaW5wdXQiKXx8bi5ub2RlTmFtZShiLCJidXR0b24iKT9uLnByb3AoYiwiZm9ybSIpOnZvaWQgMDtjJiYhbi5fZGF0YShjLCJzdWJtaXQiKSYmKG4uZXZlbnQuYWRkKGMsInN1Ym1pdC5fc3VibWl0IixmdW5jdGlvbihhKXthLl9zdWJtaXRCdWJibGU9ITB9KSxuLl9kYXRhKGMsInN1Ym1pdCIsITApKX0pfSxwb3N0RGlzcGF0Y2g6ZnVuY3Rpb24oYSl7YS5fc3VibWl0QnViYmxlJiYoZGVsZXRlIGEuX3N1Ym1pdEJ1YmJsZSx0aGlzLnBhcmVudE5vZGUmJiFhLmlzVHJpZ2dlciYmbi5ldmVudC5zaW11bGF0ZSgic3VibWl0Iix0aGlzLnBhcmVudE5vZGUsYSkpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3JldHVybiBuLm5vZGVOYW1lKHRoaXMsImZvcm0iKT8hMTp2b2lkIG4uZXZlbnQucmVtb3ZlKHRoaXMsIi5fc3VibWl0Iil9fSksbC5jaGFuZ2V8fChuLmV2ZW50LnNwZWNpYWwuY2hhbmdlPXtzZXR1cDpmdW5jdGlvbigpe3JldHVybiBrYS50ZXN0KHRoaXMubm9kZU5hbWUpPygoImNoZWNrYm94Ij09PXRoaXMudHlwZXx8InJhZGlvIj09PXRoaXMudHlwZSkmJihuLmV2ZW50LmFkZCh0aGlzLCJwcm9wZXJ0eWNoYW5nZS5fY2hhbmdlIixmdW5jdGlvbihhKXsiY2hlY2tlZCI9PT1hLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lJiYodGhpcy5fanVzdENoYW5nZWQ9ITApfSksbi5ldmVudC5hZGQodGhpcywiY2xpY2suX2NoYW5nZSIsZnVuY3Rpb24oYSl7dGhpcy5fanVzdENoYW5nZWQmJiFhLmlzVHJpZ2dlciYmKHRoaXMuX2p1c3RDaGFuZ2VkPSExKSxuLmV2ZW50LnNpbXVsYXRlKCJjaGFuZ2UiLHRoaXMsYSl9KSksITEpOnZvaWQgbi5ldmVudC5hZGQodGhpcywiYmVmb3JlYWN0aXZhdGUuX2NoYW5nZSIsZnVuY3Rpb24oYSl7dmFyIGI9YS50YXJnZXQ7a2EudGVzdChiLm5vZGVOYW1lKSYmIW4uX2RhdGEoYiwiY2hhbmdlIikmJihuLmV2ZW50LmFkZChiLCJjaGFuZ2UuX2NoYW5nZSIsZnVuY3Rpb24oYSl7IXRoaXMucGFyZW50Tm9kZXx8YS5pc1NpbXVsYXRlZHx8YS5pc1RyaWdnZXJ8fG4uZXZlbnQuc2ltdWxhdGUoImNoYW5nZSIsdGhpcy5wYXJlbnROb2RlLGEpfSksbi5fZGF0YShiLCJjaGFuZ2UiLCEwKSl9KX0saGFuZGxlOmZ1bmN0aW9uKGEpe3ZhciBiPWEudGFyZ2V0O3JldHVybiB0aGlzIT09Ynx8YS5pc1NpbXVsYXRlZHx8YS5pc1RyaWdnZXJ8fCJyYWRpbyIhPT1iLnR5cGUmJiJjaGVja2JveCIhPT1iLnR5cGU/YS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dm9pZCAwfSx0ZWFyZG93bjpmdW5jdGlvbigpe3JldHVybiBuLmV2ZW50LnJlbW92ZSh0aGlzLCIuX2NoYW5nZSIpLCFrYS50ZXN0KHRoaXMubm9kZU5hbWUpfX0pLGwuZm9jdXNpbnx8bi5lYWNoKHtmb2N1czoiZm9jdXNpbiIsYmx1cjoiZm9jdXNvdXQifSxmdW5jdGlvbihhLGIpe3ZhciBjPWZ1bmN0aW9uKGEpe24uZXZlbnQuc2ltdWxhdGUoYixhLnRhcmdldCxuLmV2ZW50LmZpeChhKSl9O24uZXZlbnQuc3BlY2lhbFtiXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgZD10aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMsZT1uLl9kYXRhKGQsYik7ZXx8ZC5hZGRFdmVudExpc3RlbmVyKGEsYywhMCksbi5fZGF0YShkLGIsKGV8fDApKzEpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3ZhciBkPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcyxlPW4uX2RhdGEoZCxiKS0xO2U/bi5fZGF0YShkLGIsZSk6KGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLGMsITApLG4uX3JlbW92ZURhdGEoZCxiKSl9fX0pLG4uZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gc2EodGhpcyxhLGIsYyxkKX0sb25lOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBzYSh0aGlzLGEsYixjLGQsMSl9LG9mZjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtpZihhJiZhLnByZXZlbnREZWZhdWx0JiZhLmhhbmRsZU9iailyZXR1cm4gZD1hLmhhbmRsZU9iaixuKGEuZGVsZWdhdGVUYXJnZXQpLm9mZihkLm5hbWVzcGFjZT9kLm9yaWdUeXBlKyIuIitkLm5hbWVzcGFjZTpkLm9yaWdUeXBlLGQuc2VsZWN0b3IsZC5oYW5kbGVyKSx0aGlzO2lmKCJvYmplY3QiPT10eXBlb2YgYSl7Zm9yKGUgaW4gYSl0aGlzLm9mZihlLGIsYVtlXSk7cmV0dXJuIHRoaXN9cmV0dXJuKGI9PT0hMXx8ImZ1bmN0aW9uIj09dHlwZW9mIGIpJiYoYz1iLGI9dm9pZCAwKSxjPT09ITEmJihjPXFhKSx0aGlzLmVhY2goZnVuY3Rpb24oKXtuLmV2ZW50LnJlbW92ZSh0aGlzLGEsYyxiKX0pfSx0cmlnZ2VyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe24uZXZlbnQudHJpZ2dlcihhLGIsdGhpcyl9KX0sdHJpZ2dlckhhbmRsZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzWzBdO3JldHVybiBjP24uZXZlbnQudHJpZ2dlcihhLGIsYywhMCk6dm9pZCAwfX0pO3ZhciB0YT0vIGpRdWVyeVxkKz0iKD86bnVsbHxcZCspIi9nLHVhPW5ldyBSZWdFeHAoIjwoPzoiK2JhKyIpW1xccy8+XSIsImkiKSx2YT0vPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXHc6LV0rKVtePl0qKVwvPi9naSx3YT0vPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSx4YT0vY2hlY2tlZFxzKig/OltePV18PVxzKi5jaGVja2VkLikvaSx5YT0vXnRydWVcLyguKikvLHphPS9eXHMqPCEoPzpcW0NEQVRBXFt8LS0pfCg/OlxdXF18LS0pPlxzKiQvZyxBYT1jYShkKSxCYT1BYS5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoImRpdiIpKTtmdW5jdGlvbiBDYShhLGIpe3JldHVybiBuLm5vZGVOYW1lKGEsInRhYmxlIikmJm4ubm9kZU5hbWUoMTEhPT1iLm5vZGVUeXBlP2I6Yi5maXJzdENoaWxkLCJ0ciIpP2EuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInRib2R5IilbMF18fGEuYXBwZW5kQ2hpbGQoYS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5IikpOmF9ZnVuY3Rpb24gRGEoYSl7cmV0dXJuIGEudHlwZT0obnVsbCE9PW4uZmluZC5hdHRyKGEsInR5cGUiKSkrIi8iK2EudHlwZSxhfWZ1bmN0aW9uIEVhKGEpe3ZhciBiPXlhLmV4ZWMoYS50eXBlKTtyZXR1cm4gYj9hLnR5cGU9YlsxXTphLnJlbW92ZUF0dHJpYnV0ZSgidHlwZSIpLGF9ZnVuY3Rpb24gRmEoYSxiKXtpZigxPT09Yi5ub2RlVHlwZSYmbi5oYXNEYXRhKGEpKXt2YXIgYyxkLGUsZj1uLl9kYXRhKGEpLGc9bi5fZGF0YShiLGYpLGg9Zi5ldmVudHM7aWYoaCl7ZGVsZXRlIGcuaGFuZGxlLGcuZXZlbnRzPXt9O2ZvcihjIGluIGgpZm9yKGQ9MCxlPWhbY10ubGVuZ3RoO2U+ZDtkKyspbi5ldmVudC5hZGQoYixjLGhbY11bZF0pfWcuZGF0YSYmKGcuZGF0YT1uLmV4dGVuZCh7fSxnLmRhdGEpKX19ZnVuY3Rpb24gR2EoYSxiKXt2YXIgYyxkLGU7aWYoMT09PWIubm9kZVR5cGUpe2lmKGM9Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCFsLm5vQ2xvbmVFdmVudCYmYltuLmV4cGFuZG9dKXtlPW4uX2RhdGEoYik7Zm9yKGQgaW4gZS5ldmVudHMpbi5yZW1vdmVFdmVudChiLGQsZS5oYW5kbGUpO2IucmVtb3ZlQXR0cmlidXRlKG4uZXhwYW5kbyl9InNjcmlwdCI9PT1jJiZiLnRleHQhPT1hLnRleHQ/KERhKGIpLnRleHQ9YS50ZXh0LEVhKGIpKToib2JqZWN0Ij09PWM/KGIucGFyZW50Tm9kZSYmKGIub3V0ZXJIVE1MPWEub3V0ZXJIVE1MKSxsLmh0bWw1Q2xvbmUmJmEuaW5uZXJIVE1MJiYhbi50cmltKGIuaW5uZXJIVE1MKSYmKGIuaW5uZXJIVE1MPWEuaW5uZXJIVE1MKSk6ImlucHV0Ij09PWMmJloudGVzdChhLnR5cGUpPyhiLmRlZmF1bHRDaGVja2VkPWIuY2hlY2tlZD1hLmNoZWNrZWQsYi52YWx1ZSE9PWEudmFsdWUmJihiLnZhbHVlPWEudmFsdWUpKToib3B0aW9uIj09PWM/Yi5kZWZhdWx0U2VsZWN0ZWQ9Yi5zZWxlY3RlZD1hLmRlZmF1bHRTZWxlY3RlZDooImlucHV0Ij09PWN8fCJ0ZXh0YXJlYSI9PT1jKSYmKGIuZGVmYXVsdFZhbHVlPWEuZGVmYXVsdFZhbHVlKX19ZnVuY3Rpb24gSGEoYSxiLGMsZCl7Yj1mLmFwcGx5KFtdLGIpO3ZhciBlLGcsaCxpLGosayxtPTAsbz1hLmxlbmd0aCxwPW8tMSxxPWJbMF0scj1uLmlzRnVuY3Rpb24ocSk7aWYocnx8bz4xJiYic3RyaW5nIj09dHlwZW9mIHEmJiFsLmNoZWNrQ2xvbmUmJnhhLnRlc3QocSkpcmV0dXJuIGEuZWFjaChmdW5jdGlvbihlKXt2YXIgZj1hLmVxKGUpO3ImJihiWzBdPXEuY2FsbCh0aGlzLGUsZi5odG1sKCkpKSxIYShmLGIsYyxkKX0pO2lmKG8mJihrPWphKGIsYVswXS5vd25lckRvY3VtZW50LCExLGEsZCksZT1rLmZpcnN0Q2hpbGQsMT09PWsuY2hpbGROb2Rlcy5sZW5ndGgmJihrPWUpLGV8fGQpKXtmb3IoaT1uLm1hcChlYShrLCJzY3JpcHQiKSxEYSksaD1pLmxlbmd0aDtvPm07bSsrKWc9ayxtIT09cCYmKGc9bi5jbG9uZShnLCEwLCEwKSxoJiZuLm1lcmdlKGksZWEoZywic2NyaXB0IikpKSxjLmNhbGwoYVttXSxnLG0pO2lmKGgpZm9yKGo9aVtpLmxlbmd0aC0xXS5vd25lckRvY3VtZW50LG4ubWFwKGksRWEpLG09MDtoPm07bSsrKWc9aVttXSxfLnRlc3QoZy50eXBlfHwiIikmJiFuLl9kYXRhKGcsImdsb2JhbEV2YWwiKSYmbi5jb250YWlucyhqLGcpJiYoZy5zcmM/bi5fZXZhbFVybCYmbi5fZXZhbFVybChnLnNyYyk6bi5nbG9iYWxFdmFsKChnLnRleHR8fGcudGV4dENvbnRlbnR8fGcuaW5uZXJIVE1MfHwiIikucmVwbGFjZSh6YSwiIikpKTtrPWU9bnVsbH1yZXR1cm4gYX1mdW5jdGlvbiBJYShhLGIsYyl7Zm9yKHZhciBkLGU9Yj9uLmZpbHRlcihiLGEpOmEsZj0wO251bGwhPShkPWVbZl0pO2YrKyljfHwxIT09ZC5ub2RlVHlwZXx8bi5jbGVhbkRhdGEoZWEoZCkpLGQucGFyZW50Tm9kZSYmKGMmJm4uY29udGFpbnMoZC5vd25lckRvY3VtZW50LGQpJiZmYShlYShkLCJzY3JpcHQiKSksZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpKTtyZXR1cm4gYX1uLmV4dGVuZCh7aHRtbFByZWZpbHRlcjpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKHZhLCI8JDE+PC8kMj4iKX0sY2xvbmU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGgsaT1uLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKTtpZihsLmh0bWw1Q2xvbmV8fG4uaXNYTUxEb2MoYSl8fCF1YS50ZXN0KCI8IithLm5vZGVOYW1lKyI+Iik/Zj1hLmNsb25lTm9kZSghMCk6KEJhLmlubmVySFRNTD1hLm91dGVySFRNTCxCYS5yZW1vdmVDaGlsZChmPUJhLmZpcnN0Q2hpbGQpKSwhKGwubm9DbG9uZUV2ZW50JiZsLm5vQ2xvbmVDaGVja2VkfHwxIT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlfHxuLmlzWE1MRG9jKGEpKSlmb3IoZD1lYShmKSxoPWVhKGEpLGc9MDtudWxsIT0oZT1oW2ddKTsrK2cpZFtnXSYmR2EoZSxkW2ddKTtpZihiKWlmKGMpZm9yKGg9aHx8ZWEoYSksZD1kfHxlYShmKSxnPTA7bnVsbCE9KGU9aFtnXSk7ZysrKUZhKGUsZFtnXSk7ZWxzZSBGYShhLGYpO3JldHVybiBkPWVhKGYsInNjcmlwdCIpLGQubGVuZ3RoPjAmJmZhKGQsIWkmJmVhKGEsInNjcmlwdCIpKSxkPWg9ZT1udWxsLGZ9LGNsZWFuRGF0YTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgZCxlLGYsZyxoPTAsaT1uLmV4cGFuZG8saj1uLmNhY2hlLGs9bC5hdHRyaWJ1dGVzLG09bi5ldmVudC5zcGVjaWFsO251bGwhPShkPWFbaF0pO2grKylpZigoYnx8TShkKSkmJihmPWRbaV0sZz1mJiZqW2ZdKSl7aWYoZy5ldmVudHMpZm9yKGUgaW4gZy5ldmVudHMpbVtlXT9uLmV2ZW50LnJlbW92ZShkLGUpOm4ucmVtb3ZlRXZlbnQoZCxlLGcuaGFuZGxlKTtqW2ZdJiYoZGVsZXRlIGpbZl0sa3x8InVuZGVmaW5lZCI9PXR5cGVvZiBkLnJlbW92ZUF0dHJpYnV0ZT9kW2ldPXZvaWQgMDpkLnJlbW92ZUF0dHJpYnV0ZShpKSxjLnB1c2goZikpfX19KSxuLmZuLmV4dGVuZCh7ZG9tTWFuaXA6SGEsZGV0YWNoOmZ1bmN0aW9uKGEpe3JldHVybiBJYSh0aGlzLGEsITApfSxyZW1vdmU6ZnVuY3Rpb24oYSl7cmV0dXJuIElhKHRoaXMsYSl9LHRleHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIFkodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwPT09YT9uLnRleHQodGhpcyk6dGhpcy5lbXB0eSgpLmFwcGVuZCgodGhpc1swXSYmdGhpc1swXS5vd25lckRvY3VtZW50fHxkKS5jcmVhdGVUZXh0Tm9kZShhKSl9LG51bGwsYSxhcmd1bWVudHMubGVuZ3RoKX0sYXBwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIEhhKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGEpe2lmKDE9PT10aGlzLm5vZGVUeXBlfHwxMT09PXRoaXMubm9kZVR5cGV8fDk9PT10aGlzLm5vZGVUeXBlKXt2YXIgYj1DYSh0aGlzLGEpO2IuYXBwZW5kQ2hpbGQoYSl9fSl9LHByZXBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gSGEodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oYSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciBiPUNhKHRoaXMsYSk7Yi5pbnNlcnRCZWZvcmUoYSxiLmZpcnN0Q2hpbGQpfX0pfSxiZWZvcmU6ZnVuY3Rpb24oKXtyZXR1cm4gSGEodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsdGhpcyl9KX0sYWZ0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gSGEodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsdGhpcy5uZXh0U2libGluZyl9KX0sZW1wdHk6ZnVuY3Rpb24oKXtmb3IodmFyIGEsYj0wO251bGwhPShhPXRoaXNbYl0pO2IrKyl7MT09PWEubm9kZVR5cGUmJm4uY2xlYW5EYXRhKGVhKGEsITEpKTt3aGlsZShhLmZpcnN0Q2hpbGQpYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO2Eub3B0aW9ucyYmbi5ub2RlTmFtZShhLCJzZWxlY3QiKSYmKGEub3B0aW9ucy5sZW5ndGg9MCl9cmV0dXJuIHRoaXN9LGNsb25lOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9bnVsbD09YT8hMTphLGI9bnVsbD09Yj9hOmIsdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gbi5jbG9uZSh0aGlzLGEsYil9KX0saHRtbDpmdW5jdGlvbihhKXtyZXR1cm4gWSh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXNbMF18fHt9LGM9MCxkPXRoaXMubGVuZ3RoO2lmKHZvaWQgMD09PWEpcmV0dXJuIDE9PT1iLm5vZGVUeXBlP2IuaW5uZXJIVE1MLnJlcGxhY2UodGEsIiIpOnZvaWQgMDtpZigic3RyaW5nIj09dHlwZW9mIGEmJiF3YS50ZXN0KGEpJiYobC5odG1sU2VyaWFsaXplfHwhdWEudGVzdChhKSkmJihsLmxlYWRpbmdXaGl0ZXNwYWNlfHwhYWEudGVzdChhKSkmJiFkYVsoJC5leGVjKGEpfHxbIiIsIiJdKVsxXS50b0xvd2VyQ2FzZSgpXSl7YT1uLmh0bWxQcmVmaWx0ZXIoYSk7dHJ5e2Zvcig7ZD5jO2MrKyliPXRoaXNbY118fHt9LDE9PT1iLm5vZGVUeXBlJiYobi5jbGVhbkRhdGEoZWEoYiwhMSkpLGIuaW5uZXJIVE1MPWEpO2I9MH1jYXRjaChlKXt9fWImJnRoaXMuZW1wdHkoKS5hcHBlbmQoYSl9LG51bGwsYSxhcmd1bWVudHMubGVuZ3RoKX0scmVwbGFjZVdpdGg6ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gSGEodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5wYXJlbnROb2RlO24uaW5BcnJheSh0aGlzLGEpPDAmJihuLmNsZWFuRGF0YShlYSh0aGlzKSksYyYmYy5yZXBsYWNlQ2hpbGQoYix0aGlzKSl9LGEpfX0pLG4uZWFjaCh7YXBwZW5kVG86ImFwcGVuZCIscHJlcGVuZFRvOiJwcmVwZW5kIixpbnNlcnRCZWZvcmU6ImJlZm9yZSIsaW5zZXJ0QWZ0ZXI6ImFmdGVyIixyZXBsYWNlQWxsOiJyZXBsYWNlV2l0aCJ9LGZ1bmN0aW9uKGEsYil7bi5mblthXT1mdW5jdGlvbihhKXtmb3IodmFyIGMsZD0wLGU9W10sZj1uKGEpLGg9Zi5sZW5ndGgtMTtoPj1kO2QrKyljPWQ9PT1oP3RoaXM6dGhpcy5jbG9uZSghMCksbihmW2RdKVtiXShjKSxnLmFwcGx5KGUsYy5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGUpfX0pO3ZhciBKYSxLYT17SFRNTDoiYmxvY2siLEJPRFk6ImJsb2NrIn07ZnVuY3Rpb24gTGEoYSxiKXt2YXIgYz1uKGIuY3JlYXRlRWxlbWVudChhKSkuYXBwZW5kVG8oYi5ib2R5KSxkPW4uY3NzKGNbMF0sImRpc3BsYXkiKTtyZXR1cm4gYy5kZXRhY2goKSxkfWZ1bmN0aW9uIE1hKGEpe3ZhciBiPWQsYz1LYVthXTtyZXR1cm4gY3x8KGM9TGEoYSxiKSwibm9uZSIhPT1jJiZjfHwoSmE9KEphfHxuKCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+IikpLmFwcGVuZFRvKGIuZG9jdW1lbnRFbGVtZW50KSxiPShKYVswXS5jb250ZW50V2luZG93fHxKYVswXS5jb250ZW50RG9jdW1lbnQpLmRvY3VtZW50LGIud3JpdGUoKSxiLmNsb3NlKCksYz1MYShhLGIpLEphLmRldGFjaCgpKSxLYVthXT1jKSxjfXZhciBOYT0vXm1hcmdpbi8sT2E9bmV3IFJlZ0V4cCgiXigiK1QrIikoPyFweClbYS16JV0rJCIsImkiKSxQYT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGc9e307Zm9yKGYgaW4gYilnW2ZdPWEuc3R5bGVbZl0sYS5zdHlsZVtmXT1iW2ZdO2U9Yy5hcHBseShhLGR8fFtdKTtmb3IoZiBpbiBiKWEuc3R5bGVbZl09Z1tmXTtyZXR1cm4gZX0sUWE9ZC5kb2N1bWVudEVsZW1lbnQ7IWZ1bmN0aW9uKCl7dmFyIGIsYyxlLGYsZyxoLGk9ZC5jcmVhdGVFbGVtZW50KCJkaXYiKSxqPWQuY3JlYXRlRWxlbWVudCgiZGl2Iik7aWYoai5zdHlsZSl7ai5zdHlsZS5jc3NUZXh0PSJmbG9hdDpsZWZ0O29wYWNpdHk6LjUiLGwub3BhY2l0eT0iMC41Ij09PWouc3R5bGUub3BhY2l0eSxsLmNzc0Zsb2F0PSEhai5zdHlsZS5jc3NGbG9hdCxqLnN0eWxlLmJhY2tncm91bmRDbGlwPSJjb250ZW50LWJveCIsai5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwPSIiLGwuY2xlYXJDbG9uZVN0eWxlPSJjb250ZW50LWJveCI9PT1qLnN0eWxlLmJhY2tncm91bmRDbGlwLGk9ZC5jcmVhdGVFbGVtZW50KCJkaXYiKSxpLnN0eWxlLmNzc1RleHQ9ImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7cGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlIixqLmlubmVySFRNTD0iIixpLmFwcGVuZENoaWxkKGopLGwuYm94U2l6aW5nPSIiPT09ai5zdHlsZS5ib3hTaXppbmd8fCIiPT09ai5zdHlsZS5Nb3pCb3hTaXppbmd8fCIiPT09ai5zdHlsZS5XZWJraXRCb3hTaXppbmcsbi5leHRlbmQobCx7cmVsaWFibGVIaWRkZW5PZmZzZXRzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWImJmsoKSxmfSxib3hTaXppbmdSZWxpYWJsZTpmdW5jdGlvbigpe3JldHVybiBudWxsPT1iJiZrKCksZX0scGl4ZWxNYXJnaW5SaWdodDpmdW5jdGlvbigpe3JldHVybiBudWxsPT1iJiZrKCksY30scGl4ZWxQb3NpdGlvbjpmdW5jdGlvbigpe3JldHVybiBudWxsPT1iJiZrKCksYn0scmVsaWFibGVNYXJnaW5SaWdodDpmdW5jdGlvbigpe3JldHVybiBudWxsPT1iJiZrKCksZ30scmVsaWFibGVNYXJnaW5MZWZ0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWImJmsoKSxofX0pO2Z1bmN0aW9uIGsoKXt2YXIgayxsLG09ZC5kb2N1bWVudEVsZW1lbnQ7bS5hcHBlbmRDaGlsZChpKSxqLnN0eWxlLmNzc1RleHQ9Ii13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO21hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7dG9wOjElO3dpZHRoOjUwJSIsYj1lPWg9ITEsYz1nPSEwLGEuZ2V0Q29tcHV0ZWRTdHlsZSYmKGw9YS5nZXRDb21wdXRlZFN0eWxlKGopLGI9IjElIiE9PShsfHx7fSkudG9wLGg9IjJweCI9PT0obHx8e30pLm1hcmdpbkxlZnQsZT0iNHB4Ij09PShsfHx7d2lkdGg6IjRweCJ9KS53aWR0aCxqLnN0eWxlLm1hcmdpblJpZ2h0PSI1MCUiLGM9IjRweCI9PT0obHx8e21hcmdpblJpZ2h0OiI0cHgifSkubWFyZ2luUmlnaHQsaz1qLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudCgiZGl2IikpLGsuc3R5bGUuY3NzVGV4dD1qLnN0eWxlLmNzc1RleHQ9Ii13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MCIsay5zdHlsZS5tYXJnaW5SaWdodD1rLnN0eWxlLndpZHRoPSIwIixqLnN0eWxlLndpZHRoPSIxcHgiLGc9IXBhcnNlRmxvYXQoKGEuZ2V0Q29tcHV0ZWRTdHlsZShrKXx8e30pLm1hcmdpblJpZ2h0KSxqLnJlbW92ZUNoaWxkKGspKSxqLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGY9MD09PWouZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgsZiYmKGouc3R5bGUuZGlzcGxheT0iIixqLmlubmVySFRNTD0iPHRhYmxlPjx0cj48dGQ+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPiIsaz1qLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJ0ZCIpLGtbMF0uc3R5bGUuY3NzVGV4dD0ibWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowO2Rpc3BsYXk6bm9uZSIsZj0wPT09a1swXS5vZmZzZXRIZWlnaHQsZiYmKGtbMF0uc3R5bGUuZGlzcGxheT0iIixrWzFdLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGY9MD09PWtbMF0ub2Zmc2V0SGVpZ2h0KSksbS5yZW1vdmVDaGlsZChpKX19fSgpO3ZhciBSYSxTYSxUYT0vXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87YS5nZXRDb21wdXRlZFN0eWxlPyhSYT1mdW5jdGlvbihiKXt2YXIgYz1iLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7cmV0dXJuIGMmJmMub3BlbmVyfHwoYz1hKSxjLmdldENvbXB1dGVkU3R5bGUoYil9LFNhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuc3R5bGU7cmV0dXJuIGM9Y3x8UmEoYSksZz1jP2MuZ2V0UHJvcGVydHlWYWx1ZShiKXx8Y1tiXTp2b2lkIDAsIiIhPT1nJiZ2b2lkIDAhPT1nfHxuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKXx8KGc9bi5zdHlsZShhLGIpKSxjJiYhbC5waXhlbE1hcmdpblJpZ2h0KCkmJk9hLnRlc3QoZykmJk5hLnRlc3QoYikmJihkPWgud2lkdGgsZT1oLm1pbldpZHRoLGY9aC5tYXhXaWR0aCxoLm1pbldpZHRoPWgubWF4V2lkdGg9aC53aWR0aD1nLGc9Yy53aWR0aCxoLndpZHRoPWQsaC5taW5XaWR0aD1lLGgubWF4V2lkdGg9Ziksdm9pZCAwPT09Zz9nOmcrIiJ9KTpRYS5jdXJyZW50U3R5bGUmJihSYT1mdW5jdGlvbihhKXtyZXR1cm4gYS5jdXJyZW50U3R5bGV9LFNhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuc3R5bGU7cmV0dXJuIGM9Y3x8UmEoYSksZz1jP2NbYl06dm9pZCAwLG51bGw9PWcmJmgmJmhbYl0mJihnPWhbYl0pLE9hLnRlc3QoZykmJiFUYS50ZXN0KGIpJiYoZD1oLmxlZnQsZT1hLnJ1bnRpbWVTdHlsZSxmPWUmJmUubGVmdCxmJiYoZS5sZWZ0PWEuY3VycmVudFN0eWxlLmxlZnQpLGgubGVmdD0iZm9udFNpemUiPT09Yj8iMWVtIjpnLGc9aC5waXhlbExlZnQrInB4IixoLmxlZnQ9ZCxmJiYoZS5sZWZ0PWYpKSx2b2lkIDA9PT1nP2c6ZysiInx8ImF1dG8ifSk7ZnVuY3Rpb24gVWEoYSxiKXtyZXR1cm57Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEoKT92b2lkIGRlbGV0ZSB0aGlzLmdldDoodGhpcy5nZXQ9YikuYXBwbHkodGhpcyxhcmd1bWVudHMpfX19dmFyIFZhPS9hbHBoYVwoW14pXSpcKS9pLFdhPS9vcGFjaXR5XHMqPVxzKihbXildKikvaSxYYT0vXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sWWE9bmV3IFJlZ0V4cCgiXigiK1QrIikoLiopJCIsImkiKSxaYT17cG9zaXRpb246ImFic29sdXRlIix2aXNpYmlsaXR5OiJoaWRkZW4iLGRpc3BsYXk6ImJsb2NrIn0sJGE9e2xldHRlclNwYWNpbmc6IjAiLGZvbnRXZWlnaHQ6IjQwMCJ9LF9hPVsiV2Via2l0IiwiTyIsIk1veiIsIm1zIl0sYWI9ZC5jcmVhdGVFbGVtZW50KCJkaXYiKS5zdHlsZTtmdW5jdGlvbiBiYihhKXtpZihhIGluIGFiKXJldHVybiBhO3ZhciBiPWEuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zbGljZSgxKSxjPV9hLmxlbmd0aDt3aGlsZShjLS0paWYoYT1fYVtjXStiLGEgaW4gYWIpcmV0dXJuIGF9ZnVuY3Rpb24gY2IoYSxiKXtmb3IodmFyIGMsZCxlLGY9W10sZz0wLGg9YS5sZW5ndGg7aD5nO2crKylkPWFbZ10sZC5zdHlsZSYmKGZbZ109bi5fZGF0YShkLCJvbGRkaXNwbGF5IiksYz1kLnN0eWxlLmRpc3BsYXksYj8oZltnXXx8Im5vbmUiIT09Y3x8KGQuc3R5bGUuZGlzcGxheT0iIiksIiI9PT1kLnN0eWxlLmRpc3BsYXkmJlcoZCkmJihmW2ddPW4uX2RhdGEoZCwib2xkZGlzcGxheSIsTWEoZC5ub2RlTmFtZSkpKSk6KGU9VyhkKSwoYyYmIm5vbmUiIT09Y3x8IWUpJiZuLl9kYXRhKGQsIm9sZGRpc3BsYXkiLGU/YzpuLmNzcyhkLCJkaXNwbGF5IikpKSk7Zm9yKGc9MDtoPmc7ZysrKWQ9YVtnXSxkLnN0eWxlJiYoYiYmIm5vbmUiIT09ZC5zdHlsZS5kaXNwbGF5JiYiIiE9PWQuc3R5bGUuZGlzcGxheXx8KGQuc3R5bGUuZGlzcGxheT1iP2ZbZ118fCIiOiJub25lIikpO3JldHVybiBhfWZ1bmN0aW9uIGRiKGEsYixjKXt2YXIgZD1ZYS5leGVjKGIpO3JldHVybiBkP01hdGgubWF4KDAsZFsxXS0oY3x8MCkpKyhkWzJdfHwicHgiKTpifWZ1bmN0aW9uIGViKGEsYixjLGQsZSl7Zm9yKHZhciBmPWM9PT0oZD8iYm9yZGVyIjoiY29udGVudCIpPzQ6IndpZHRoIj09PWI/MTowLGc9MDs0PmY7Zis9MikibWFyZ2luIj09PWMmJihnKz1uLmNzcyhhLGMrVltmXSwhMCxlKSksZD8oImNvbnRlbnQiPT09YyYmKGctPW4uY3NzKGEsInBhZGRpbmciK1ZbZl0sITAsZSkpLCJtYXJnaW4iIT09YyYmKGctPW4uY3NzKGEsImJvcmRlciIrVltmXSsiV2lkdGgiLCEwLGUpKSk6KGcrPW4uY3NzKGEsInBhZGRpbmciK1ZbZl0sITAsZSksInBhZGRpbmciIT09YyYmKGcrPW4uY3NzKGEsImJvcmRlciIrVltmXSsiV2lkdGgiLCEwLGUpKSk7cmV0dXJuIGd9ZnVuY3Rpb24gZmIoYixjLGUpe3ZhciBmPSEwLGc9IndpZHRoIj09PWM/Yi5vZmZzZXRXaWR0aDpiLm9mZnNldEhlaWdodCxoPVJhKGIpLGk9bC5ib3hTaXppbmcmJiJib3JkZXItYm94Ij09PW4uY3NzKGIsImJveFNpemluZyIsITEsaCk7aWYoZC5tc0Z1bGxzY3JlZW5FbGVtZW50JiZhLnRvcCE9PWEmJmIuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgmJihnPU1hdGgucm91bmQoMTAwKmIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbY10pKSwwPj1nfHxudWxsPT1nKXtpZihnPVNhKGIsYyxoKSwoMD5nfHxudWxsPT1nKSYmKGc9Yi5zdHlsZVtjXSksT2EudGVzdChnKSlyZXR1cm4gZztmPWkmJihsLmJveFNpemluZ1JlbGlhYmxlKCl8fGc9PT1iLnN0eWxlW2NdKSxnPXBhcnNlRmxvYXQoZyl8fDB9cmV0dXJuIGcrZWIoYixjLGV8fChpPyJib3JkZXIiOiJjb250ZW50IiksZixoKSsicHgifW4uZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGEsYil7aWYoYil7dmFyIGM9U2EoYSwib3BhY2l0eSIpO3JldHVybiIiPT09Yz8iMSI6Y319fX0sY3NzTnVtYmVyOnthbmltYXRpb25JdGVyYXRpb25Db3VudDohMCxjb2x1bW5Db3VudDohMCxmaWxsT3BhY2l0eTohMCxmbGV4R3JvdzohMCxmbGV4U2hyaW5rOiEwLGZvbnRXZWlnaHQ6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwfSxjc3NQcm9wczp7ImZsb2F0IjpsLmNzc0Zsb2F0PyJjc3NGbG9hdCI6InN0eWxlRmxvYXQifSxzdHlsZTpmdW5jdGlvbihhLGIsYyxkKXtpZihhJiYzIT09YS5ub2RlVHlwZSYmOCE9PWEubm9kZVR5cGUmJmEuc3R5bGUpe3ZhciBlLGYsZyxoPW4uY2FtZWxDYXNlKGIpLGk9YS5zdHlsZTtpZihiPW4uY3NzUHJvcHNbaF18fChuLmNzc1Byb3BzW2hdPWJiKGgpfHxoKSxnPW4uY3NzSG9va3NbYl18fG4uY3NzSG9va3NbaF0sdm9pZCAwPT09YylyZXR1cm4gZyYmImdldCJpbiBnJiZ2b2lkIDAhPT0oZT1nLmdldChhLCExLGQpKT9lOmlbYl07aWYoZj10eXBlb2YgYywic3RyaW5nIj09PWYmJihlPVUuZXhlYyhjKSkmJmVbMV0mJihjPVgoYSxiLGUpLGY9Im51bWJlciIpLG51bGwhPWMmJmM9PT1jJiYoIm51bWJlciI9PT1mJiYoYys9ZSYmZVszXXx8KG4uY3NzTnVtYmVyW2hdPyIiOiJweCIpKSxsLmNsZWFyQ2xvbmVTdHlsZXx8IiIhPT1jfHwwIT09Yi5pbmRleE9mKCJiYWNrZ3JvdW5kIil8fChpW2JdPSJpbmhlcml0IiksIShnJiYic2V0ImluIGcmJnZvaWQgMD09PShjPWcuc2V0KGEsYyxkKSkpKSl0cnl7aVtiXT1jfWNhdGNoKGope319fSxjc3M6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnLGg9bi5jYW1lbENhc2UoYik7cmV0dXJuIGI9bi5jc3NQcm9wc1toXXx8KG4uY3NzUHJvcHNbaF09YmIoaCl8fGgpLGc9bi5jc3NIb29rc1tiXXx8bi5jc3NIb29rc1toXSxnJiYiZ2V0ImluIGcmJihmPWcuZ2V0KGEsITAsYykpLHZvaWQgMD09PWYmJihmPVNhKGEsYixkKSksIm5vcm1hbCI9PT1mJiZiIGluICRhJiYoZj0kYVtiXSksIiI9PT1jfHxjPyhlPXBhcnNlRmxvYXQoZiksYz09PSEwfHxpc0Zpbml0ZShlKT9lfHwwOmYpOmZ9fSksbi5lYWNoKFsiaGVpZ2h0Iiwid2lkdGgiXSxmdW5jdGlvbihhLGIpe24uY3NzSG9va3NbYl09e2dldDpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGM/WGEudGVzdChuLmNzcyhhLCJkaXNwbGF5IikpJiYwPT09YS5vZmZzZXRXaWR0aD9QYShhLFphLGZ1bmN0aW9uKCl7cmV0dXJuIGZiKGEsYixkKX0pOmZiKGEsYixkKTp2b2lkIDB9LHNldDpmdW5jdGlvbihhLGMsZCl7dmFyIGU9ZCYmUmEoYSk7cmV0dXJuIGRiKGEsYyxkP2ViKGEsYixkLGwuYm94U2l6aW5nJiYiYm9yZGVyLWJveCI9PT1uLmNzcyhhLCJib3hTaXppbmciLCExLGUpLGUpOjApfX19KSxsLm9wYWNpdHl8fChuLmNzc0hvb2tzLm9wYWNpdHk9e2dldDpmdW5jdGlvbihhLGIpe3JldHVybiBXYS50ZXN0KChiJiZhLmN1cnJlbnRTdHlsZT9hLmN1cnJlbnRTdHlsZS5maWx0ZXI6YS5zdHlsZS5maWx0ZXIpfHwiIik/LjAxKnBhcnNlRmxvYXQoUmVnRXhwLiQxKSsiIjpiPyIxIjoiIn0sc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5zdHlsZSxkPWEuY3VycmVudFN0eWxlLGU9bi5pc051bWVyaWMoYik/ImFscGhhKG9wYWNpdHk9IisxMDAqYisiKSI6IiIsZj1kJiZkLmZpbHRlcnx8Yy5maWx0ZXJ8fCIiO2Muem9vbT0xLChiPj0xfHwiIj09PWIpJiYiIj09PW4udHJpbShmLnJlcGxhY2UoVmEsIiIpKSYmYy5yZW1vdmVBdHRyaWJ1dGUmJihjLnJlbW92ZUF0dHJpYnV0ZSgiZmlsdGVyIiksIiI9PT1ifHxkJiYhZC5maWx0ZXIpfHwoYy5maWx0ZXI9VmEudGVzdChmKT9mLnJlcGxhY2UoVmEsZSk6ZisiICIrZSl9fSksbi5jc3NIb29rcy5tYXJnaW5SaWdodD1VYShsLnJlbGlhYmxlTWFyZ2luUmlnaHQsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj9QYShhLHtkaXNwbGF5OiJpbmxpbmUtYmxvY2sifSxTYSxbYSwibWFyZ2luUmlnaHQiXSk6dm9pZCAwfSksbi5jc3NIb29rcy5tYXJnaW5MZWZ0PVVhKGwucmVsaWFibGVNYXJnaW5MZWZ0LGZ1bmN0aW9uKGEsYil7CnJldHVybiBiPyhwYXJzZUZsb2F0KFNhKGEsIm1hcmdpbkxlZnQiKSl8fChuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKT9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQtUGEoYSx7bWFyZ2luTGVmdDowfSxmdW5jdGlvbigpe3JldHVybiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnR9KTowKSkrInB4Ijp2b2lkIDB9KSxuLmVhY2goe21hcmdpbjoiIixwYWRkaW5nOiIiLGJvcmRlcjoiV2lkdGgifSxmdW5jdGlvbihhLGIpe24uY3NzSG9va3NbYStiXT17ZXhwYW5kOmZ1bmN0aW9uKGMpe2Zvcih2YXIgZD0wLGU9e30sZj0ic3RyaW5nIj09dHlwZW9mIGM/Yy5zcGxpdCgiICIpOltjXTs0PmQ7ZCsrKWVbYStWW2RdK2JdPWZbZF18fGZbZC0yXXx8ZlswXTtyZXR1cm4gZX19LE5hLnRlc3QoYSl8fChuLmNzc0hvb2tzW2ErYl0uc2V0PWRiKX0pLG4uZm4uZXh0ZW5kKHtjc3M6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gWSh0aGlzLGZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9e30sZz0wO2lmKG4uaXNBcnJheShiKSl7Zm9yKGQ9UmEoYSksZT1iLmxlbmd0aDtlPmc7ZysrKWZbYltnXV09bi5jc3MoYSxiW2ddLCExLGQpO3JldHVybiBmfXJldHVybiB2b2lkIDAhPT1jP24uc3R5bGUoYSxiLGMpOm4uY3NzKGEsYil9LGEsYixhcmd1bWVudHMubGVuZ3RoPjEpfSxzaG93OmZ1bmN0aW9uKCl7cmV0dXJuIGNiKHRoaXMsITApfSxoaWRlOmZ1bmN0aW9uKCl7cmV0dXJuIGNiKHRoaXMpfSx0b2dnbGU6ZnVuY3Rpb24oYSl7cmV0dXJuImJvb2xlYW4iPT10eXBlb2YgYT9hP3RoaXMuc2hvdygpOnRoaXMuaGlkZSgpOnRoaXMuZWFjaChmdW5jdGlvbigpe1codGhpcyk/bih0aGlzKS5zaG93KCk6bih0aGlzKS5oaWRlKCl9KX19KTtmdW5jdGlvbiBnYihhLGIsYyxkLGUpe3JldHVybiBuZXcgZ2IucHJvdG90eXBlLmluaXQoYSxiLGMsZCxlKX1uLlR3ZWVuPWdiLGdiLnByb3RvdHlwZT17Y29uc3RydWN0b3I6Z2IsaW5pdDpmdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5lbGVtPWEsdGhpcy5wcm9wPWMsdGhpcy5lYXNpbmc9ZXx8bi5lYXNpbmcuX2RlZmF1bHQsdGhpcy5vcHRpb25zPWIsdGhpcy5zdGFydD10aGlzLm5vdz10aGlzLmN1cigpLHRoaXMuZW5kPWQsdGhpcy51bml0PWZ8fChuLmNzc051bWJlcltjXT8iIjoicHgiKX0sY3VyOmZ1bmN0aW9uKCl7dmFyIGE9Z2IucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIGEmJmEuZ2V0P2EuZ2V0KHRoaXMpOmdiLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyl9LHJ1bjpmdW5jdGlvbihhKXt2YXIgYixjPWdiLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiB0aGlzLm9wdGlvbnMuZHVyYXRpb24/dGhpcy5wb3M9Yj1uLmVhc2luZ1t0aGlzLmVhc2luZ10oYSx0aGlzLm9wdGlvbnMuZHVyYXRpb24qYSwwLDEsdGhpcy5vcHRpb25zLmR1cmF0aW9uKTp0aGlzLnBvcz1iPWEsdGhpcy5ub3c9KHRoaXMuZW5kLXRoaXMuc3RhcnQpKmIrdGhpcy5zdGFydCx0aGlzLm9wdGlvbnMuc3RlcCYmdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sdGhpcy5ub3csdGhpcyksYyYmYy5zZXQ/Yy5zZXQodGhpcyk6Z2IucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSx0aGlzfX0sZ2IucHJvdG90eXBlLmluaXQucHJvdG90eXBlPWdiLnByb3RvdHlwZSxnYi5wcm9wSG9va3M9e19kZWZhdWx0OntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuIDEhPT1hLmVsZW0ubm9kZVR5cGV8fG51bGwhPWEuZWxlbVthLnByb3BdJiZudWxsPT1hLmVsZW0uc3R5bGVbYS5wcm9wXT9hLmVsZW1bYS5wcm9wXTooYj1uLmNzcyhhLmVsZW0sYS5wcm9wLCIiKSxiJiYiYXV0byIhPT1iP2I6MCl9LHNldDpmdW5jdGlvbihhKXtuLmZ4LnN0ZXBbYS5wcm9wXT9uLmZ4LnN0ZXBbYS5wcm9wXShhKToxIT09YS5lbGVtLm5vZGVUeXBlfHxudWxsPT1hLmVsZW0uc3R5bGVbbi5jc3NQcm9wc1thLnByb3BdXSYmIW4uY3NzSG9va3NbYS5wcm9wXT9hLmVsZW1bYS5wcm9wXT1hLm5vdzpuLnN0eWxlKGEuZWxlbSxhLnByb3AsYS5ub3crYS51bml0KX19fSxnYi5wcm9wSG9va3Muc2Nyb2xsVG9wPWdiLnByb3BIb29rcy5zY3JvbGxMZWZ0PXtzZXQ6ZnVuY3Rpb24oYSl7YS5lbGVtLm5vZGVUeXBlJiZhLmVsZW0ucGFyZW50Tm9kZSYmKGEuZWxlbVthLnByb3BdPWEubm93KX19LG4uZWFzaW5nPXtsaW5lYXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LHN3aW5nOmZ1bmN0aW9uKGEpe3JldHVybi41LU1hdGguY29zKGEqTWF0aC5QSSkvMn0sX2RlZmF1bHQ6InN3aW5nIn0sbi5meD1nYi5wcm90b3R5cGUuaW5pdCxuLmZ4LnN0ZXA9e307dmFyIGhiLGliLGpiPS9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxrYj0vcXVldWVIb29rcyQvO2Z1bmN0aW9uIGxiKCl7cmV0dXJuIGEuc2V0VGltZW91dChmdW5jdGlvbigpe2hiPXZvaWQgMH0pLGhiPW4ubm93KCl9ZnVuY3Rpb24gbWIoYSxiKXt2YXIgYyxkPXtoZWlnaHQ6YX0sZT0wO2ZvcihiPWI/MTowOzQ+ZTtlKz0yLWIpYz1WW2VdLGRbIm1hcmdpbiIrY109ZFsicGFkZGluZyIrY109YTtyZXR1cm4gYiYmKGQub3BhY2l0eT1kLndpZHRoPWEpLGR9ZnVuY3Rpb24gbmIoYSxiLGMpe2Zvcih2YXIgZCxlPShxYi50d2VlbmVyc1tiXXx8W10pLmNvbmNhdChxYi50d2VlbmVyc1siKiJdKSxmPTAsZz1lLmxlbmd0aDtnPmY7ZisrKWlmKGQ9ZVtmXS5jYWxsKGMsYixhKSlyZXR1cm4gZH1mdW5jdGlvbiBvYihhLGIsYyl7dmFyIGQsZSxmLGcsaCxpLGosayxtPXRoaXMsbz17fSxwPWEuc3R5bGUscT1hLm5vZGVUeXBlJiZXKGEpLHI9bi5fZGF0YShhLCJmeHNob3ciKTtjLnF1ZXVlfHwoaD1uLl9xdWV1ZUhvb2tzKGEsImZ4IiksbnVsbD09aC51bnF1ZXVlZCYmKGgudW5xdWV1ZWQ9MCxpPWguZW1wdHkuZmlyZSxoLmVtcHR5LmZpcmU9ZnVuY3Rpb24oKXtoLnVucXVldWVkfHxpKCl9KSxoLnVucXVldWVkKyssbS5hbHdheXMoZnVuY3Rpb24oKXttLmFsd2F5cyhmdW5jdGlvbigpe2gudW5xdWV1ZWQtLSxuLnF1ZXVlKGEsImZ4IikubGVuZ3RofHxoLmVtcHR5LmZpcmUoKX0pfSkpLDE9PT1hLm5vZGVUeXBlJiYoImhlaWdodCJpbiBifHwid2lkdGgiaW4gYikmJihjLm92ZXJmbG93PVtwLm92ZXJmbG93LHAub3ZlcmZsb3dYLHAub3ZlcmZsb3dZXSxqPW4uY3NzKGEsImRpc3BsYXkiKSxrPSJub25lIj09PWo/bi5fZGF0YShhLCJvbGRkaXNwbGF5Iil8fE1hKGEubm9kZU5hbWUpOmosImlubGluZSI9PT1rJiYibm9uZSI9PT1uLmNzcyhhLCJmbG9hdCIpJiYobC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0JiYiaW5saW5lIiE9PU1hKGEubm9kZU5hbWUpP3Auem9vbT0xOnAuZGlzcGxheT0iaW5saW5lLWJsb2NrIikpLGMub3ZlcmZsb3cmJihwLm92ZXJmbG93PSJoaWRkZW4iLGwuc2hyaW5rV3JhcEJsb2NrcygpfHxtLmFsd2F5cyhmdW5jdGlvbigpe3Aub3ZlcmZsb3c9Yy5vdmVyZmxvd1swXSxwLm92ZXJmbG93WD1jLm92ZXJmbG93WzFdLHAub3ZlcmZsb3dZPWMub3ZlcmZsb3dbMl19KSk7Zm9yKGQgaW4gYilpZihlPWJbZF0samIuZXhlYyhlKSl7aWYoZGVsZXRlIGJbZF0sZj1mfHwidG9nZ2xlIj09PWUsZT09PShxPyJoaWRlIjoic2hvdyIpKXtpZigic2hvdyIhPT1lfHwhcnx8dm9pZCAwPT09cltkXSljb250aW51ZTtxPSEwfW9bZF09ciYmcltkXXx8bi5zdHlsZShhLGQpfWVsc2Ugaj12b2lkIDA7aWYobi5pc0VtcHR5T2JqZWN0KG8pKSJpbmxpbmUiPT09KCJub25lIj09PWo/TWEoYS5ub2RlTmFtZSk6aikmJihwLmRpc3BsYXk9aik7ZWxzZXtyPyJoaWRkZW4iaW4gciYmKHE9ci5oaWRkZW4pOnI9bi5fZGF0YShhLCJmeHNob3ciLHt9KSxmJiYoci5oaWRkZW49IXEpLHE/bihhKS5zaG93KCk6bS5kb25lKGZ1bmN0aW9uKCl7bihhKS5oaWRlKCl9KSxtLmRvbmUoZnVuY3Rpb24oKXt2YXIgYjtuLl9yZW1vdmVEYXRhKGEsImZ4c2hvdyIpO2ZvcihiIGluIG8pbi5zdHlsZShhLGIsb1tiXSl9KTtmb3IoZCBpbiBvKWc9bmIocT9yW2RdOjAsZCxtKSxkIGluIHJ8fChyW2RdPWcuc3RhcnQscSYmKGcuZW5kPWcuc3RhcnQsZy5zdGFydD0id2lkdGgiPT09ZHx8ImhlaWdodCI9PT1kPzE6MCkpfX1mdW5jdGlvbiBwYihhLGIpe3ZhciBjLGQsZSxmLGc7Zm9yKGMgaW4gYSlpZihkPW4uY2FtZWxDYXNlKGMpLGU9YltkXSxmPWFbY10sbi5pc0FycmF5KGYpJiYoZT1mWzFdLGY9YVtjXT1mWzBdKSxjIT09ZCYmKGFbZF09ZixkZWxldGUgYVtjXSksZz1uLmNzc0hvb2tzW2RdLGcmJiJleHBhbmQiaW4gZyl7Zj1nLmV4cGFuZChmKSxkZWxldGUgYVtkXTtmb3IoYyBpbiBmKWMgaW4gYXx8KGFbY109ZltjXSxiW2NdPWUpfWVsc2UgYltkXT1lfWZ1bmN0aW9uIHFiKGEsYixjKXt2YXIgZCxlLGY9MCxnPXFiLnByZWZpbHRlcnMubGVuZ3RoLGg9bi5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSBpLmVsZW19KSxpPWZ1bmN0aW9uKCl7aWYoZSlyZXR1cm4hMTtmb3IodmFyIGI9aGJ8fGxiKCksYz1NYXRoLm1heCgwLGouc3RhcnRUaW1lK2ouZHVyYXRpb24tYiksZD1jL2ouZHVyYXRpb258fDAsZj0xLWQsZz0wLGk9ai50d2VlbnMubGVuZ3RoO2k+ZztnKyspai50d2VlbnNbZ10ucnVuKGYpO3JldHVybiBoLm5vdGlmeVdpdGgoYSxbaixmLGNdKSwxPmYmJmk/YzooaC5yZXNvbHZlV2l0aChhLFtqXSksITEpfSxqPWgucHJvbWlzZSh7ZWxlbTphLHByb3BzOm4uZXh0ZW5kKHt9LGIpLG9wdHM6bi5leHRlbmQoITAse3NwZWNpYWxFYXNpbmc6e30sZWFzaW5nOm4uZWFzaW5nLl9kZWZhdWx0fSxjKSxvcmlnaW5hbFByb3BlcnRpZXM6YixvcmlnaW5hbE9wdGlvbnM6YyxzdGFydFRpbWU6aGJ8fGxiKCksZHVyYXRpb246Yy5kdXJhdGlvbix0d2VlbnM6W10sY3JlYXRlVHdlZW46ZnVuY3Rpb24oYixjKXt2YXIgZD1uLlR3ZWVuKGEsai5vcHRzLGIsYyxqLm9wdHMuc3BlY2lhbEVhc2luZ1tiXXx8ai5vcHRzLmVhc2luZyk7cmV0dXJuIGoudHdlZW5zLnB1c2goZCksZH0sc3RvcDpmdW5jdGlvbihiKXt2YXIgYz0wLGQ9Yj9qLnR3ZWVucy5sZW5ndGg6MDtpZihlKXJldHVybiB0aGlzO2ZvcihlPSEwO2Q+YztjKyspai50d2VlbnNbY10ucnVuKDEpO3JldHVybiBiPyhoLm5vdGlmeVdpdGgoYSxbaiwxLDBdKSxoLnJlc29sdmVXaXRoKGEsW2osYl0pKTpoLnJlamVjdFdpdGgoYSxbaixiXSksdGhpc319KSxrPWoucHJvcHM7Zm9yKHBiKGssai5vcHRzLnNwZWNpYWxFYXNpbmcpO2c+ZjtmKyspaWYoZD1xYi5wcmVmaWx0ZXJzW2ZdLmNhbGwoaixhLGssai5vcHRzKSlyZXR1cm4gbi5pc0Z1bmN0aW9uKGQuc3RvcCkmJihuLl9xdWV1ZUhvb2tzKGouZWxlbSxqLm9wdHMucXVldWUpLnN0b3A9bi5wcm94eShkLnN0b3AsZCkpLGQ7cmV0dXJuIG4ubWFwKGssbmIsaiksbi5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkmJmoub3B0cy5zdGFydC5jYWxsKGEsaiksbi5meC50aW1lcihuLmV4dGVuZChpLHtlbGVtOmEsYW5pbTpqLHF1ZXVlOmoub3B0cy5xdWV1ZX0pKSxqLnByb2dyZXNzKGoub3B0cy5wcm9ncmVzcykuZG9uZShqLm9wdHMuZG9uZSxqLm9wdHMuY29tcGxldGUpLmZhaWwoai5vcHRzLmZhaWwpLmFsd2F5cyhqLm9wdHMuYWx3YXlzKX1uLkFuaW1hdGlvbj1uLmV4dGVuZChxYix7dHdlZW5lcnM6eyIqIjpbZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNyZWF0ZVR3ZWVuKGEsYik7cmV0dXJuIFgoYy5lbGVtLGEsVS5leGVjKGIpLGMpLGN9XX0sdHdlZW5lcjpmdW5jdGlvbihhLGIpe24uaXNGdW5jdGlvbihhKT8oYj1hLGE9WyIqIl0pOmE9YS5tYXRjaChHKTtmb3IodmFyIGMsZD0wLGU9YS5sZW5ndGg7ZT5kO2QrKyljPWFbZF0scWIudHdlZW5lcnNbY109cWIudHdlZW5lcnNbY118fFtdLHFiLnR3ZWVuZXJzW2NdLnVuc2hpZnQoYil9LHByZWZpbHRlcnM6W29iXSxwcmVmaWx0ZXI6ZnVuY3Rpb24oYSxiKXtiP3FiLnByZWZpbHRlcnMudW5zaGlmdChhKTpxYi5wcmVmaWx0ZXJzLnB1c2goYSl9fSksbi5zcGVlZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YSYmIm9iamVjdCI9PXR5cGVvZiBhP24uZXh0ZW5kKHt9LGEpOntjb21wbGV0ZTpjfHwhYyYmYnx8bi5pc0Z1bmN0aW9uKGEpJiZhLGR1cmF0aW9uOmEsZWFzaW5nOmMmJmJ8fGImJiFuLmlzRnVuY3Rpb24oYikmJmJ9O3JldHVybiBkLmR1cmF0aW9uPW4uZngub2ZmPzA6Im51bWJlciI9PXR5cGVvZiBkLmR1cmF0aW9uP2QuZHVyYXRpb246ZC5kdXJhdGlvbiBpbiBuLmZ4LnNwZWVkcz9uLmZ4LnNwZWVkc1tkLmR1cmF0aW9uXTpuLmZ4LnNwZWVkcy5fZGVmYXVsdCwobnVsbD09ZC5xdWV1ZXx8ZC5xdWV1ZT09PSEwKSYmKGQucXVldWU9ImZ4IiksZC5vbGQ9ZC5jb21wbGV0ZSxkLmNvbXBsZXRlPWZ1bmN0aW9uKCl7bi5pc0Z1bmN0aW9uKGQub2xkKSYmZC5vbGQuY2FsbCh0aGlzKSxkLnF1ZXVlJiZuLmRlcXVldWUodGhpcyxkLnF1ZXVlKX0sZH0sbi5mbi5leHRlbmQoe2ZhZGVUbzpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5maWx0ZXIoVykuY3NzKCJvcGFjaXR5IiwwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7b3BhY2l0eTpifSxhLGMsZCl9LGFuaW1hdGU6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bi5pc0VtcHR5T2JqZWN0KGEpLGY9bi5zcGVlZChiLGMsZCksZz1mdW5jdGlvbigpe3ZhciBiPXFiKHRoaXMsbi5leHRlbmQoe30sYSksZik7KGV8fG4uX2RhdGEodGhpcywiZmluaXNoIikpJiZiLnN0b3AoITApfTtyZXR1cm4gZy5maW5pc2g9ZyxlfHxmLnF1ZXVlPT09ITE/dGhpcy5lYWNoKGcpOnRoaXMucXVldWUoZi5xdWV1ZSxnKX0sc3RvcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5zdG9wO2RlbGV0ZSBhLnN0b3AsYihjKX07cmV0dXJuInN0cmluZyIhPXR5cGVvZiBhJiYoYz1iLGI9YSxhPXZvaWQgMCksYiYmYSE9PSExJiZ0aGlzLnF1ZXVlKGF8fCJmeCIsW10pLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPSEwLGU9bnVsbCE9YSYmYSsicXVldWVIb29rcyIsZj1uLnRpbWVycyxnPW4uX2RhdGEodGhpcyk7aWYoZSlnW2VdJiZnW2VdLnN0b3AmJmQoZ1tlXSk7ZWxzZSBmb3IoZSBpbiBnKWdbZV0mJmdbZV0uc3RvcCYma2IudGVzdChlKSYmZChnW2VdKTtmb3IoZT1mLmxlbmd0aDtlLS07KWZbZV0uZWxlbSE9PXRoaXN8fG51bGwhPWEmJmZbZV0ucXVldWUhPT1hfHwoZltlXS5hbmltLnN0b3AoYyksYj0hMSxmLnNwbGljZShlLDEpKTsoYnx8IWMpJiZuLmRlcXVldWUodGhpcyxhKX0pfSxmaW5pc2g6ZnVuY3Rpb24oYSl7cmV0dXJuIGEhPT0hMSYmKGE9YXx8ImZ4IiksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGIsYz1uLl9kYXRhKHRoaXMpLGQ9Y1thKyJxdWV1ZSJdLGU9Y1thKyJxdWV1ZUhvb2tzIl0sZj1uLnRpbWVycyxnPWQ/ZC5sZW5ndGg6MDtmb3IoYy5maW5pc2g9ITAsbi5xdWV1ZSh0aGlzLGEsW10pLGUmJmUuc3RvcCYmZS5zdG9wLmNhbGwodGhpcywhMCksYj1mLmxlbmd0aDtiLS07KWZbYl0uZWxlbT09PXRoaXMmJmZbYl0ucXVldWU9PT1hJiYoZltiXS5hbmltLnN0b3AoITApLGYuc3BsaWNlKGIsMSkpO2ZvcihiPTA7Zz5iO2IrKylkW2JdJiZkW2JdLmZpbmlzaCYmZFtiXS5maW5pc2guY2FsbCh0aGlzKTtkZWxldGUgYy5maW5pc2h9KX19KSxuLmVhY2goWyJ0b2dnbGUiLCJzaG93IiwiaGlkZSJdLGZ1bmN0aW9uKGEsYil7dmFyIGM9bi5mbltiXTtuLmZuW2JdPWZ1bmN0aW9uKGEsZCxlKXtyZXR1cm4gbnVsbD09YXx8ImJvb2xlYW4iPT10eXBlb2YgYT9jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUobWIoYiwhMCksYSxkLGUpfX0pLG4uZWFjaCh7c2xpZGVEb3duOm1iKCJzaG93Iiksc2xpZGVVcDptYigiaGlkZSIpLHNsaWRlVG9nZ2xlOm1iKCJ0b2dnbGUiKSxmYWRlSW46e29wYWNpdHk6InNob3cifSxmYWRlT3V0OntvcGFjaXR5OiJoaWRlIn0sZmFkZVRvZ2dsZTp7b3BhY2l0eToidG9nZ2xlIn19LGZ1bmN0aW9uKGEsYil7bi5mblthXT1mdW5jdGlvbihhLGMsZCl7cmV0dXJuIHRoaXMuYW5pbWF0ZShiLGEsYyxkKX19KSxuLnRpbWVycz1bXSxuLmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgYSxiPW4udGltZXJzLGM9MDtmb3IoaGI9bi5ub3coKTtjPGIubGVuZ3RoO2MrKylhPWJbY10sYSgpfHxiW2NdIT09YXx8Yi5zcGxpY2UoYy0tLDEpO2IubGVuZ3RofHxuLmZ4LnN0b3AoKSxoYj12b2lkIDB9LG4uZngudGltZXI9ZnVuY3Rpb24oYSl7bi50aW1lcnMucHVzaChhKSxhKCk/bi5meC5zdGFydCgpOm4udGltZXJzLnBvcCgpfSxuLmZ4LmludGVydmFsPTEzLG4uZnguc3RhcnQ9ZnVuY3Rpb24oKXtpYnx8KGliPWEuc2V0SW50ZXJ2YWwobi5meC50aWNrLG4uZnguaW50ZXJ2YWwpKX0sbi5meC5zdG9wPWZ1bmN0aW9uKCl7YS5jbGVhckludGVydmFsKGliKSxpYj1udWxsfSxuLmZ4LnNwZWVkcz17c2xvdzo2MDAsZmFzdDoyMDAsX2RlZmF1bHQ6NDAwfSxuLmZuLmRlbGF5PWZ1bmN0aW9uKGIsYyl7cmV0dXJuIGI9bi5meD9uLmZ4LnNwZWVkc1tiXXx8YjpiLGM9Y3x8ImZ4Iix0aGlzLnF1ZXVlKGMsZnVuY3Rpb24oYyxkKXt2YXIgZT1hLnNldFRpbWVvdXQoYyxiKTtkLnN0b3A9ZnVuY3Rpb24oKXthLmNsZWFyVGltZW91dChlKX19KX0sZnVuY3Rpb24oKXt2YXIgYSxiPWQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKSxjPWQuY3JlYXRlRWxlbWVudCgiZGl2IiksZT1kLmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIpLGY9ZS5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpKTtjPWQuY3JlYXRlRWxlbWVudCgiZGl2IiksYy5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsInQiKSxjLmlubmVySFRNTD0iICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+IixhPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKVswXSxiLnNldEF0dHJpYnV0ZSgidHlwZSIsImNoZWNrYm94IiksYy5hcHBlbmRDaGlsZChiKSxhPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKVswXSxhLnN0eWxlLmNzc1RleHQ9InRvcDoxcHgiLGwuZ2V0U2V0QXR0cmlidXRlPSJ0IiE9PWMuY2xhc3NOYW1lLGwuc3R5bGU9L3RvcC8udGVzdChhLmdldEF0dHJpYnV0ZSgic3R5bGUiKSksbC5ocmVmTm9ybWFsaXplZD0iL2EiPT09YS5nZXRBdHRyaWJ1dGUoImhyZWYiKSxsLmNoZWNrT249ISFiLnZhbHVlLGwub3B0U2VsZWN0ZWQ9Zi5zZWxlY3RlZCxsLmVuY3R5cGU9ISFkLmNyZWF0ZUVsZW1lbnQoImZvcm0iKS5lbmN0eXBlLGUuZGlzYWJsZWQ9ITAsbC5vcHREaXNhYmxlZD0hZi5kaXNhYmxlZCxiPWQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKSxiLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIiKSxsLmlucHV0PSIiPT09Yi5nZXRBdHRyaWJ1dGUoInZhbHVlIiksYi52YWx1ZT0idCIsYi5zZXRBdHRyaWJ1dGUoInR5cGUiLCJyYWRpbyIpLGwucmFkaW9WYWx1ZT0idCI9PT1iLnZhbHVlfSgpO3ZhciByYj0vXHIvZztuLmZuLmV4dGVuZCh7dmFsOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPXRoaXNbMF07e2lmKGFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGQ9bi5pc0Z1bmN0aW9uKGEpLHRoaXMuZWFjaChmdW5jdGlvbihjKXt2YXIgZTsxPT09dGhpcy5ub2RlVHlwZSYmKGU9ZD9hLmNhbGwodGhpcyxjLG4odGhpcykudmFsKCkpOmEsbnVsbD09ZT9lPSIiOiJudW1iZXIiPT10eXBlb2YgZT9lKz0iIjpuLmlzQXJyYXkoZSkmJihlPW4ubWFwKGUsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/IiI6YSsiIn0pKSxiPW4udmFsSG9va3NbdGhpcy50eXBlXXx8bi52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLGImJiJzZXQiaW4gYiYmdm9pZCAwIT09Yi5zZXQodGhpcyxlLCJ2YWx1ZSIpfHwodGhpcy52YWx1ZT1lKSl9KTtpZihlKXJldHVybiBiPW4udmFsSG9va3NbZS50eXBlXXx8bi52YWxIb29rc1tlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLGImJiJnZXQiaW4gYiYmdm9pZCAwIT09KGM9Yi5nZXQoZSwidmFsdWUiKSk/YzooYz1lLnZhbHVlLCJzdHJpbmciPT10eXBlb2YgYz9jLnJlcGxhY2UocmIsIiIpOm51bGw9PWM/IiI6Yyl9fX0pLG4uZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9bi5maW5kLmF0dHIoYSwidmFsdWUiKTtyZXR1cm4gbnVsbCE9Yj9iOm4udHJpbShuLnRleHQoYSkpfX0sc2VsZWN0OntnZXQ6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiLGMsZD1hLm9wdGlvbnMsZT1hLnNlbGVjdGVkSW5kZXgsZj0ic2VsZWN0LW9uZSI9PT1hLnR5cGV8fDA+ZSxnPWY/bnVsbDpbXSxoPWY/ZSsxOmQubGVuZ3RoLGk9MD5lP2g6Zj9lOjA7aD5pO2krKylpZihjPWRbaV0sKGMuc2VsZWN0ZWR8fGk9PT1lKSYmKGwub3B0RGlzYWJsZWQ/IWMuZGlzYWJsZWQ6bnVsbD09PWMuZ2V0QXR0cmlidXRlKCJkaXNhYmxlZCIpKSYmKCFjLnBhcmVudE5vZGUuZGlzYWJsZWR8fCFuLm5vZGVOYW1lKGMucGFyZW50Tm9kZSwib3B0Z3JvdXAiKSkpe2lmKGI9bihjKS52YWwoKSxmKXJldHVybiBiO2cucHVzaChiKX1yZXR1cm4gZ30sc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPWEub3B0aW9ucyxmPW4ubWFrZUFycmF5KGIpLGc9ZS5sZW5ndGg7d2hpbGUoZy0tKWlmKGQ9ZVtnXSxuLmluQXJyYXkobi52YWxIb29rcy5vcHRpb24uZ2V0KGQpLGYpPj0wKXRyeXtkLnNlbGVjdGVkPWM9ITB9Y2F0Y2goaCl7ZC5zY3JvbGxIZWlnaHR9ZWxzZSBkLnNlbGVjdGVkPSExO3JldHVybiBjfHwoYS5zZWxlY3RlZEluZGV4PS0xKSxlfX19fSksbi5lYWNoKFsicmFkaW8iLCJjaGVja2JveCJdLGZ1bmN0aW9uKCl7bi52YWxIb29rc1t0aGlzXT17c2V0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIG4uaXNBcnJheShiKT9hLmNoZWNrZWQ9bi5pbkFycmF5KG4oYSkudmFsKCksYik+LTE6dm9pZCAwfX0sbC5jaGVja09ufHwobi52YWxIb29rc1t0aGlzXS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PT1hLmdldEF0dHJpYnV0ZSgidmFsdWUiKT8ib24iOmEudmFsdWV9KX0pO3ZhciBzYix0Yix1Yj1uLmV4cHIuYXR0ckhhbmRsZSx2Yj0vXig/OmNoZWNrZWR8c2VsZWN0ZWQpJC9pLHdiPWwuZ2V0U2V0QXR0cmlidXRlLHhiPWwuaW5wdXQ7bi5mbi5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gWSh0aGlzLG4uYXR0cixhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bi5yZW1vdmVBdHRyKHRoaXMsYSl9KX19KSxuLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPWEubm9kZVR5cGU7aWYoMyE9PWYmJjghPT1mJiYyIT09ZilyZXR1cm4idW5kZWZpbmVkIj09dHlwZW9mIGEuZ2V0QXR0cmlidXRlP24ucHJvcChhLGIsYyk6KDE9PT1mJiZuLmlzWE1MRG9jKGEpfHwoYj1iLnRvTG93ZXJDYXNlKCksZT1uLmF0dHJIb29rc1tiXXx8KG4uZXhwci5tYXRjaC5ib29sLnRlc3QoYik/dGI6c2IpKSx2b2lkIDAhPT1jP251bGw9PT1jP3ZvaWQgbi5yZW1vdmVBdHRyKGEsYik6ZSYmInNldCJpbiBlJiZ2b2lkIDAhPT0oZD1lLnNldChhLGMsYikpP2Q6KGEuc2V0QXR0cmlidXRlKGIsYysiIiksYyk6ZSYmImdldCJpbiBlJiZudWxsIT09KGQ9ZS5nZXQoYSxiKSk/ZDooZD1uLmZpbmQuYXR0cihhLGIpLG51bGw9PWQ/dm9pZCAwOmQpKX0sYXR0ckhvb2tzOnt0eXBlOntzZXQ6ZnVuY3Rpb24oYSxiKXtpZighbC5yYWRpb1ZhbHVlJiYicmFkaW8iPT09YiYmbi5ub2RlTmFtZShhLCJpbnB1dCIpKXt2YXIgYz1hLnZhbHVlO3JldHVybiBhLnNldEF0dHJpYnV0ZSgidHlwZSIsYiksYyYmKGEudmFsdWU9YyksYn19fX0scmVtb3ZlQXR0cjpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZT0wLGY9YiYmYi5tYXRjaChHKTtpZihmJiYxPT09YS5ub2RlVHlwZSl3aGlsZShjPWZbZSsrXSlkPW4ucHJvcEZpeFtjXXx8YyxuLmV4cHIubWF0Y2guYm9vbC50ZXN0KGMpP3hiJiZ3Ynx8IXZiLnRlc3QoYyk/YVtkXT0hMTphW24uY2FtZWxDYXNlKCJkZWZhdWx0LSIrYyldPWFbZF09ITE6bi5hdHRyKGEsYywiIiksYS5yZW1vdmVBdHRyaWJ1dGUod2I/YzpkKX19KSx0Yj17c2V0OmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYj09PSExP24ucmVtb3ZlQXR0cihhLGMpOnhiJiZ3Ynx8IXZiLnRlc3QoYyk/YS5zZXRBdHRyaWJ1dGUoIXdiJiZuLnByb3BGaXhbY118fGMsYyk6YVtuLmNhbWVsQ2FzZSgiZGVmYXVsdC0iK2MpXT1hW2NdPSEwLGN9fSxuLmVhY2gobi5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cdysvZyksZnVuY3Rpb24oYSxiKXt2YXIgYz11YltiXXx8bi5maW5kLmF0dHI7eGImJndifHwhdmIudGVzdChiKT91YltiXT1mdW5jdGlvbihhLGIsZCl7dmFyIGUsZjtyZXR1cm4gZHx8KGY9dWJbYl0sdWJbYl09ZSxlPW51bGwhPWMoYSxiLGQpP2IudG9Mb3dlckNhc2UoKTpudWxsLHViW2JdPWYpLGV9OnViW2JdPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYz92b2lkIDA6YVtuLmNhbWVsQ2FzZSgiZGVmYXVsdC0iK2IpXT9iLnRvTG93ZXJDYXNlKCk6bnVsbH19KSx4YiYmd2J8fChuLmF0dHJIb29rcy52YWx1ZT17c2V0OmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbi5ub2RlTmFtZShhLCJpbnB1dCIpP3ZvaWQoYS5kZWZhdWx0VmFsdWU9Yik6c2ImJnNiLnNldChhLGIsYyl9fSksd2J8fChzYj17c2V0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLmdldEF0dHJpYnV0ZU5vZGUoYyk7cmV0dXJuIGR8fGEuc2V0QXR0cmlidXRlTm9kZShkPWEub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUoYykpLGQudmFsdWU9Yis9IiIsInZhbHVlIj09PWN8fGI9PT1hLmdldEF0dHJpYnV0ZShjKT9iOnZvaWQgMH19LHViLmlkPXViLm5hbWU9dWIuY29vcmRzPWZ1bmN0aW9uKGEsYixjKXt2YXIgZDtyZXR1cm4gYz92b2lkIDA6KGQ9YS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSYmIiIhPT1kLnZhbHVlP2QudmFsdWU6bnVsbH0sbi52YWxIb29rcy5idXR0b249e2dldDpmdW5jdGlvbihhLGIpe3ZhciBjPWEuZ2V0QXR0cmlidXRlTm9kZShiKTtyZXR1cm4gYyYmYy5zcGVjaWZpZWQ/Yy52YWx1ZTp2b2lkIDB9LHNldDpzYi5zZXR9LG4uYXR0ckhvb2tzLmNvbnRlbnRlZGl0YWJsZT17c2V0OmZ1bmN0aW9uKGEsYixjKXtzYi5zZXQoYSwiIj09PWI/ITE6YixjKX19LG4uZWFjaChbIndpZHRoIiwiaGVpZ2h0Il0sZnVuY3Rpb24oYSxiKXtuLmF0dHJIb29rc1tiXT17c2V0OmZ1bmN0aW9uKGEsYyl7cmV0dXJuIiI9PT1jPyhhLnNldEF0dHJpYnV0ZShiLCJhdXRvIiksYyk6dm9pZCAwfX19KSksbC5zdHlsZXx8KG4uYXR0ckhvb2tzLnN0eWxlPXtnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3R5bGUuY3NzVGV4dHx8dm9pZCAwfSxzZXQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zdHlsZS5jc3NUZXh0PWIrIiJ9fSk7dmFyIHliPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pLHpiPS9eKD86YXxhcmVhKSQvaTtuLmZuLmV4dGVuZCh7cHJvcDpmdW5jdGlvbihhLGIpe3JldHVybiBZKHRoaXMsbi5wcm9wLGEsYixhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVQcm9wOmZ1bmN0aW9uKGEpe3JldHVybiBhPW4ucHJvcEZpeFthXXx8YSx0aGlzLmVhY2goZnVuY3Rpb24oKXt0cnl7dGhpc1thXT12b2lkIDAsZGVsZXRlIHRoaXNbYV19Y2F0Y2goYil7fX0pfX0pLG4uZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9YS5ub2RlVHlwZTtpZigzIT09ZiYmOCE9PWYmJjIhPT1mKXJldHVybiAxPT09ZiYmbi5pc1hNTERvYyhhKXx8KGI9bi5wcm9wRml4W2JdfHxiLGU9bi5wcm9wSG9va3NbYl0pLHZvaWQgMCE9PWM/ZSYmInNldCJpbiBlJiZ2b2lkIDAhPT0oZD1lLnNldChhLGMsYikpP2Q6YVtiXT1jOmUmJiJnZXQiaW4gZSYmbnVsbCE9PShkPWUuZ2V0KGEsYikpP2Q6YVtiXX0scHJvcEhvb2tzOnt0YWJJbmRleDp7Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiPW4uZmluZC5hdHRyKGEsInRhYmluZGV4Iik7cmV0dXJuIGI/cGFyc2VJbnQoYiwxMCk6eWIudGVzdChhLm5vZGVOYW1lKXx8emIudGVzdChhLm5vZGVOYW1lKSYmYS5ocmVmPzA6LTF9fX0scHJvcEZpeDp7ImZvciI6Imh0bWxGb3IiLCJjbGFzcyI6ImNsYXNzTmFtZSJ9fSksbC5ocmVmTm9ybWFsaXplZHx8bi5lYWNoKFsiaHJlZiIsInNyYyJdLGZ1bmN0aW9uKGEsYil7bi5wcm9wSG9va3NbYl09e2dldDpmdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoYiw0KX19fSksbC5vcHRTZWxlY3RlZHx8KG4ucHJvcEhvb2tzLnNlbGVjdGVkPXtnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO3JldHVybiBiJiYoYi5zZWxlY3RlZEluZGV4LGIucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpLG51bGx9fSksbi5lYWNoKFsidGFiSW5kZXgiLCJyZWFkT25seSIsIm1heExlbmd0aCIsImNlbGxTcGFjaW5nIiwiY2VsbFBhZGRpbmciLCJyb3dTcGFuIiwiY29sU3BhbiIsInVzZU1hcCIsImZyYW1lQm9yZGVyIiwiY29udGVudEVkaXRhYmxlIl0sZnVuY3Rpb24oKXtuLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXT10aGlzfSksbC5lbmN0eXBlfHwobi5wcm9wRml4LmVuY3R5cGU9ImVuY29kaW5nIik7dmFyIEFiPS9bXHRcclxuXGZdL2c7ZnVuY3Rpb24gQmIoYSl7cmV0dXJuIG4uYXR0cihhLCJjbGFzcyIpfHwiIn1uLmZuLmV4dGVuZCh7YWRkQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGgsaT0wO2lmKG4uaXNGdW5jdGlvbihhKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpe24odGhpcykuYWRkQ2xhc3MoYS5jYWxsKHRoaXMsYixCYih0aGlzKSkpfSk7aWYoInN0cmluZyI9PXR5cGVvZiBhJiZhKXtiPWEubWF0Y2goRyl8fFtdO3doaWxlKGM9dGhpc1tpKytdKWlmKGU9QmIoYyksZD0xPT09Yy5ub2RlVHlwZSYmKCIgIitlKyIgIikucmVwbGFjZShBYiwiICIpKXtnPTA7d2hpbGUoZj1iW2crK10pZC5pbmRleE9mKCIgIitmKyIgIik8MCYmKGQrPWYrIiAiKTtoPW4udHJpbShkKSxlIT09aCYmbi5hdHRyKGMsImNsYXNzIixoKX19cmV0dXJuIHRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoLGk9MDtpZihuLmlzRnVuY3Rpb24oYSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXtuKHRoaXMpLnJlbW92ZUNsYXNzKGEuY2FsbCh0aGlzLGIsQmIodGhpcykpKX0pO2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmF0dHIoImNsYXNzIiwiIik7aWYoInN0cmluZyI9PXR5cGVvZiBhJiZhKXtiPWEubWF0Y2goRyl8fFtdO3doaWxlKGM9dGhpc1tpKytdKWlmKGU9QmIoYyksZD0xPT09Yy5ub2RlVHlwZSYmKCIgIitlKyIgIikucmVwbGFjZShBYiwiICIpKXtnPTA7d2hpbGUoZj1iW2crK10pd2hpbGUoZC5pbmRleE9mKCIgIitmKyIgIik+LTEpZD1kLnJlcGxhY2UoIiAiK2YrIiAiLCIgIik7aD1uLnRyaW0oZCksZSE9PWgmJm4uYXR0cihjLCJjbGFzcyIsaCl9fXJldHVybiB0aGlzfSx0b2dnbGVDbGFzczpmdW5jdGlvbihhLGIpe3ZhciBjPXR5cGVvZiBhO3JldHVybiJib29sZWFuIj09dHlwZW9mIGImJiJzdHJpbmciPT09Yz9iP3RoaXMuYWRkQ2xhc3MoYSk6dGhpcy5yZW1vdmVDbGFzcyhhKTpuLmlzRnVuY3Rpb24oYSk/dGhpcy5lYWNoKGZ1bmN0aW9uKGMpe24odGhpcykudG9nZ2xlQ2xhc3MoYS5jYWxsKHRoaXMsYyxCYih0aGlzKSxiKSxiKX0pOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiLGQsZSxmO2lmKCJzdHJpbmciPT09Yyl7ZD0wLGU9bih0aGlzKSxmPWEubWF0Y2goRyl8fFtdO3doaWxlKGI9ZltkKytdKWUuaGFzQ2xhc3MoYik/ZS5yZW1vdmVDbGFzcyhiKTplLmFkZENsYXNzKGIpfWVsc2Uodm9pZCAwPT09YXx8ImJvb2xlYW4iPT09YykmJihiPUJiKHRoaXMpLGImJm4uX2RhdGEodGhpcywiX19jbGFzc05hbWVfXyIsYiksbi5hdHRyKHRoaXMsImNsYXNzIixifHxhPT09ITE/IiI6bi5fZGF0YSh0aGlzLCJfX2NsYXNzTmFtZV9fIil8fCIiKSl9KX0saGFzQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkPTA7Yj0iICIrYSsiICI7d2hpbGUoYz10aGlzW2QrK10paWYoMT09PWMubm9kZVR5cGUmJigiICIrQmIoYykrIiAiKS5yZXBsYWNlKEFiLCIgIikuaW5kZXhPZihiKT4tMSlyZXR1cm4hMDtyZXR1cm4hMX19KSxuLmVhY2goImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnUiLnNwbGl0KCIgIiksZnVuY3Rpb24oYSxiKXtuLmZuW2JdPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MD90aGlzLm9uKGIsbnVsbCxhLGMpOnRoaXMudHJpZ2dlcihiKX19KSxuLmZuLmV4dGVuZCh7aG92ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYnx8YSl9fSk7dmFyIENiPWEubG9jYXRpb24sRGI9bi5ub3coKSxFYj0vXD8vLEZiPS8oLCl8KFxbfHspfCh9fF0pfCIoPzpbXiJcXFxyXG5dfFxcWyJcXFwvYmZucnRdfFxcdVtcZGEtZkEtRl17NH0pKiJccyo6P3x0cnVlfGZhbHNlfG51bGx8LT8oPyEwXGQpXGQrKD86XC5cZCt8KSg/OltlRV1bKy1dP1xkK3wpL2c7bi5wYXJzZUpTT049ZnVuY3Rpb24oYil7aWYoYS5KU09OJiZhLkpTT04ucGFyc2UpcmV0dXJuIGEuSlNPTi5wYXJzZShiKyIiKTt2YXIgYyxkPW51bGwsZT1uLnRyaW0oYisiIik7cmV0dXJuIGUmJiFuLnRyaW0oZS5yZXBsYWNlKEZiLGZ1bmN0aW9uKGEsYixlLGYpe3JldHVybiBjJiZiJiYoZD0wKSwwPT09ZD9hOihjPWV8fGIsZCs9IWYtIWUsIiIpfSkpP0Z1bmN0aW9uKCJyZXR1cm4gIitlKSgpOm4uZXJyb3IoIkludmFsaWQgSlNPTjogIitiKX0sbi5wYXJzZVhNTD1mdW5jdGlvbihiKXt2YXIgYyxkO2lmKCFifHwic3RyaW5nIiE9dHlwZW9mIGIpcmV0dXJuIG51bGw7dHJ5e2EuRE9NUGFyc2VyPyhkPW5ldyBhLkRPTVBhcnNlcixjPWQucGFyc2VGcm9tU3RyaW5nKGIsInRleHQveG1sIikpOihjPW5ldyBhLkFjdGl2ZVhPYmplY3QoIk1pY3Jvc29mdC5YTUxET00iKSxjLmFzeW5jPSJmYWxzZSIsYy5sb2FkWE1MKGIpKX1jYXRjaChlKXtjPXZvaWQgMH1yZXR1cm4gYyYmYy5kb2N1bWVudEVsZW1lbnQmJiFjLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJwYXJzZXJlcnJvciIpLmxlbmd0aHx8bi5lcnJvcigiSW52YWxpZCBYTUw6ICIrYiksY307dmFyIEdiPS8jLiokLyxIYj0vKFs/Jl0pXz1bXiZdKi8sSWI9L14oLio/KTpbIFx0XSooW15cclxuXSopXHI/JC9nbSxKYj0vXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxLYj0vXig/OkdFVHxIRUFEKSQvLExiPS9eXC9cLy8sTWI9L14oW1x3ListXSs6KSg/OlwvXC8oPzpbXlwvPyNdKkB8KShbXlwvPyM6XSopKD86OihcZCspfCl8KS8sTmI9e30sT2I9e30sUGI9IiovIi5jb25jYXQoIioiKSxRYj1DYi5ocmVmLFJiPU1iLmV4ZWMoUWIudG9Mb3dlckNhc2UoKSl8fFtdO2Z1bmN0aW9uIFNiKGEpe3JldHVybiBmdW5jdGlvbihiLGMpeyJzdHJpbmciIT10eXBlb2YgYiYmKGM9YixiPSIqIik7dmFyIGQsZT0wLGY9Yi50b0xvd2VyQ2FzZSgpLm1hdGNoKEcpfHxbXTtpZihuLmlzRnVuY3Rpb24oYykpd2hpbGUoZD1mW2UrK10pIisiPT09ZC5jaGFyQXQoMCk/KGQ9ZC5zbGljZSgxKXx8IioiLChhW2RdPWFbZF18fFtdKS51bnNoaWZ0KGMpKTooYVtkXT1hW2RdfHxbXSkucHVzaChjKX19ZnVuY3Rpb24gVGIoYSxiLGMsZCl7dmFyIGU9e30sZj1hPT09T2I7ZnVuY3Rpb24gZyhoKXt2YXIgaTtyZXR1cm4gZVtoXT0hMCxuLmVhY2goYVtoXXx8W10sZnVuY3Rpb24oYSxoKXt2YXIgaj1oKGIsYyxkKTtyZXR1cm4ic3RyaW5nIiE9dHlwZW9mIGp8fGZ8fGVbal0/Zj8hKGk9aik6dm9pZCAwOihiLmRhdGFUeXBlcy51bnNoaWZ0KGopLGcoaiksITEpfSksaX1yZXR1cm4gZyhiLmRhdGFUeXBlc1swXSl8fCFlWyIqIl0mJmcoIioiKX1mdW5jdGlvbiBVYihhLGIpe3ZhciBjLGQsZT1uLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9uc3x8e307Zm9yKGQgaW4gYil2b2lkIDAhPT1iW2RdJiYoKGVbZF0/YTpjfHwoYz17fSkpW2RdPWJbZF0pO3JldHVybiBjJiZuLmV4dGVuZCghMCxhLGMpLGF9ZnVuY3Rpb24gVmIoYSxiLGMpe3ZhciBkLGUsZixnLGg9YS5jb250ZW50cyxpPWEuZGF0YVR5cGVzO3doaWxlKCIqIj09PWlbMF0paS5zaGlmdCgpLHZvaWQgMD09PWUmJihlPWEubWltZVR5cGV8fGIuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtVHlwZSIpKTtpZihlKWZvcihnIGluIGgpaWYoaFtnXSYmaFtnXS50ZXN0KGUpKXtpLnVuc2hpZnQoZyk7YnJlYWt9aWYoaVswXWluIGMpZj1pWzBdO2Vsc2V7Zm9yKGcgaW4gYyl7aWYoIWlbMF18fGEuY29udmVydGVyc1tnKyIgIitpWzBdXSl7Zj1nO2JyZWFrfWR8fChkPWcpfWY9Znx8ZH1yZXR1cm4gZj8oZiE9PWlbMF0mJmkudW5zaGlmdChmKSxjW2ZdKTp2b2lkIDB9ZnVuY3Rpb24gV2IoYSxiLGMsZCl7dmFyIGUsZixnLGgsaSxqPXt9LGs9YS5kYXRhVHlwZXMuc2xpY2UoKTtpZihrWzFdKWZvcihnIGluIGEuY29udmVydGVycylqW2cudG9Mb3dlckNhc2UoKV09YS5jb252ZXJ0ZXJzW2ddO2Y9ay5zaGlmdCgpO3doaWxlKGYpaWYoYS5yZXNwb25zZUZpZWxkc1tmXSYmKGNbYS5yZXNwb25zZUZpZWxkc1tmXV09YiksIWkmJmQmJmEuZGF0YUZpbHRlciYmKGI9YS5kYXRhRmlsdGVyKGIsYS5kYXRhVHlwZSkpLGk9ZixmPWsuc2hpZnQoKSlpZigiKiI9PT1mKWY9aTtlbHNlIGlmKCIqIiE9PWkmJmkhPT1mKXtpZihnPWpbaSsiICIrZl18fGpbIiogIitmXSwhZylmb3IoZSBpbiBqKWlmKGg9ZS5zcGxpdCgiICIpLGhbMV09PT1mJiYoZz1qW2krIiAiK2hbMF1dfHxqWyIqICIraFswXV0pKXtnPT09ITA/Zz1qW2VdOmpbZV0hPT0hMCYmKGY9aFswXSxrLnVuc2hpZnQoaFsxXSkpO2JyZWFrfWlmKGchPT0hMClpZihnJiZhWyJ0aHJvd3MiXSliPWcoYik7ZWxzZSB0cnl7Yj1nKGIpfWNhdGNoKGwpe3JldHVybntzdGF0ZToicGFyc2VyZXJyb3IiLGVycm9yOmc/bDoiTm8gY29udmVyc2lvbiBmcm9tICIraSsiIHRvICIrZn19fXJldHVybntzdGF0ZToic3VjY2VzcyIsZGF0YTpifX1uLmV4dGVuZCh7YWN0aXZlOjAsbGFzdE1vZGlmaWVkOnt9LGV0YWc6e30sYWpheFNldHRpbmdzOnt1cmw6UWIsdHlwZToiR0VUIixpc0xvY2FsOkpiLnRlc3QoUmJbMV0pLGdsb2JhbDohMCxwcm9jZXNzRGF0YTohMCxhc3luYzohMCxjb250ZW50VHlwZToiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04IixhY2NlcHRzOnsiKiI6UGIsdGV4dDoidGV4dC9wbGFpbiIsaHRtbDoidGV4dC9odG1sIix4bWw6ImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwiLGpzb246ImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCJ9LGNvbnRlbnRzOnt4bWw6L1xieG1sXGIvLGh0bWw6L1xiaHRtbC8sanNvbjovXGJqc29uXGIvfSxyZXNwb25zZUZpZWxkczp7eG1sOiJyZXNwb25zZVhNTCIsdGV4dDoicmVzcG9uc2VUZXh0Iixqc29uOiJyZXNwb25zZUpTT04ifSxjb252ZXJ0ZXJzOnsiKiB0ZXh0IjpTdHJpbmcsInRleHQgaHRtbCI6ITAsInRleHQganNvbiI6bi5wYXJzZUpTT04sInRleHQgeG1sIjpuLnBhcnNlWE1MfSxmbGF0T3B0aW9uczp7dXJsOiEwLGNvbnRleHQ6ITB9fSxhamF4U2V0dXA6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj9VYihVYihhLG4uYWpheFNldHRpbmdzKSxiKTpVYihuLmFqYXhTZXR0aW5ncyxhKX0sYWpheFByZWZpbHRlcjpTYihOYiksYWpheFRyYW5zcG9ydDpTYihPYiksYWpheDpmdW5jdGlvbihiLGMpeyJvYmplY3QiPT10eXBlb2YgYiYmKGM9YixiPXZvaWQgMCksYz1jfHx7fTt2YXIgZCxlLGYsZyxoLGksaixrLGw9bi5hamF4U2V0dXAoe30sYyksbT1sLmNvbnRleHR8fGwsbz1sLmNvbnRleHQmJihtLm5vZGVUeXBlfHxtLmpxdWVyeSk/bihtKTpuLmV2ZW50LHA9bi5EZWZlcnJlZCgpLHE9bi5DYWxsYmFja3MoIm9uY2UgbWVtb3J5Iikscj1sLnN0YXR1c0NvZGV8fHt9LHM9e30sdD17fSx1PTAsdj0iY2FuY2VsZWQiLHc9e3JlYWR5U3RhdGU6MCxnZXRSZXNwb25zZUhlYWRlcjpmdW5jdGlvbihhKXt2YXIgYjtpZigyPT09dSl7aWYoIWspe2s9e307d2hpbGUoYj1JYi5leGVjKGcpKWtbYlsxXS50b0xvd2VyQ2FzZSgpXT1iWzJdfWI9a1thLnRvTG93ZXJDYXNlKCldfXJldHVybiBudWxsPT1iP251bGw6Yn0sZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIDI9PT11P2c6bnVsbH0sc2V0UmVxdWVzdEhlYWRlcjpmdW5jdGlvbihhLGIpe3ZhciBjPWEudG9Mb3dlckNhc2UoKTtyZXR1cm4gdXx8KGE9dFtjXT10W2NdfHxhLHNbYV09YiksdGhpc30sb3ZlcnJpZGVNaW1lVHlwZTpmdW5jdGlvbihhKXtyZXR1cm4gdXx8KGwubWltZVR5cGU9YSksdGhpc30sc3RhdHVzQ29kZTpmdW5jdGlvbihhKXt2YXIgYjtpZihhKWlmKDI+dSlmb3IoYiBpbiBhKXJbYl09W3JbYl0sYVtiXV07ZWxzZSB3LmFsd2F5cyhhW3cuc3RhdHVzXSk7cmV0dXJuIHRoaXN9LGFib3J0OmZ1bmN0aW9uKGEpe3ZhciBiPWF8fHY7cmV0dXJuIGomJmouYWJvcnQoYikseSgwLGIpLHRoaXN9fTtpZihwLnByb21pc2UodykuY29tcGxldGU9cS5hZGQsdy5zdWNjZXNzPXcuZG9uZSx3LmVycm9yPXcuZmFpbCxsLnVybD0oKGJ8fGwudXJsfHxRYikrIiIpLnJlcGxhY2UoR2IsIiIpLnJlcGxhY2UoTGIsUmJbMV0rIi8vIiksbC50eXBlPWMubWV0aG9kfHxjLnR5cGV8fGwubWV0aG9kfHxsLnR5cGUsbC5kYXRhVHlwZXM9bi50cmltKGwuZGF0YVR5cGV8fCIqIikudG9Mb3dlckNhc2UoKS5tYXRjaChHKXx8WyIiXSxudWxsPT1sLmNyb3NzRG9tYWluJiYoZD1NYi5leGVjKGwudXJsLnRvTG93ZXJDYXNlKCkpLGwuY3Jvc3NEb21haW49ISghZHx8ZFsxXT09PVJiWzFdJiZkWzJdPT09UmJbMl0mJihkWzNdfHwoImh0dHA6Ij09PWRbMV0/IjgwIjoiNDQzIikpPT09KFJiWzNdfHwoImh0dHA6Ij09PVJiWzFdPyI4MCI6IjQ0MyIpKSkpLGwuZGF0YSYmbC5wcm9jZXNzRGF0YSYmInN0cmluZyIhPXR5cGVvZiBsLmRhdGEmJihsLmRhdGE9bi5wYXJhbShsLmRhdGEsbC50cmFkaXRpb25hbCkpLFRiKE5iLGwsYyx3KSwyPT09dSlyZXR1cm4gdztpPW4uZXZlbnQmJmwuZ2xvYmFsLGkmJjA9PT1uLmFjdGl2ZSsrJiZuLmV2ZW50LnRyaWdnZXIoImFqYXhTdGFydCIpLGwudHlwZT1sLnR5cGUudG9VcHBlckNhc2UoKSxsLmhhc0NvbnRlbnQ9IUtiLnRlc3QobC50eXBlKSxmPWwudXJsLGwuaGFzQ29udGVudHx8KGwuZGF0YSYmKGY9bC51cmwrPShFYi50ZXN0KGYpPyImIjoiPyIpK2wuZGF0YSxkZWxldGUgbC5kYXRhKSxsLmNhY2hlPT09ITEmJihsLnVybD1IYi50ZXN0KGYpP2YucmVwbGFjZShIYiwiJDFfPSIrRGIrKyk6ZisoRWIudGVzdChmKT8iJiI6Ij8iKSsiXz0iK0RiKyspKSxsLmlmTW9kaWZpZWQmJihuLmxhc3RNb2RpZmllZFtmXSYmdy5zZXRSZXF1ZXN0SGVhZGVyKCJJZi1Nb2RpZmllZC1TaW5jZSIsbi5sYXN0TW9kaWZpZWRbZl0pLG4uZXRhZ1tmXSYmdy5zZXRSZXF1ZXN0SGVhZGVyKCJJZi1Ob25lLU1hdGNoIixuLmV0YWdbZl0pKSwobC5kYXRhJiZsLmhhc0NvbnRlbnQmJmwuY29udGVudFR5cGUhPT0hMXx8Yy5jb250ZW50VHlwZSkmJncuc2V0UmVxdWVzdEhlYWRlcigiQ29udGVudC1UeXBlIixsLmNvbnRlbnRUeXBlKSx3LnNldFJlcXVlc3RIZWFkZXIoIkFjY2VwdCIsbC5kYXRhVHlwZXNbMF0mJmwuYWNjZXB0c1tsLmRhdGFUeXBlc1swXV0/bC5hY2NlcHRzW2wuZGF0YVR5cGVzWzBdXSsoIioiIT09bC5kYXRhVHlwZXNbMF0/IiwgIitQYisiOyBxPTAuMDEiOiIiKTpsLmFjY2VwdHNbIioiXSk7Zm9yKGUgaW4gbC5oZWFkZXJzKXcuc2V0UmVxdWVzdEhlYWRlcihlLGwuaGVhZGVyc1tlXSk7aWYobC5iZWZvcmVTZW5kJiYobC5iZWZvcmVTZW5kLmNhbGwobSx3LGwpPT09ITF8fDI9PT11KSlyZXR1cm4gdy5hYm9ydCgpO3Y9ImFib3J0Ijtmb3IoZSBpbntzdWNjZXNzOjEsZXJyb3I6MSxjb21wbGV0ZToxfSl3W2VdKGxbZV0pO2lmKGo9VGIoT2IsbCxjLHcpKXtpZih3LnJlYWR5U3RhdGU9MSxpJiZvLnRyaWdnZXIoImFqYXhTZW5kIixbdyxsXSksMj09PXUpcmV0dXJuIHc7bC5hc3luYyYmbC50aW1lb3V0PjAmJihoPWEuc2V0VGltZW91dChmdW5jdGlvbigpe3cuYWJvcnQoInRpbWVvdXQiKX0sbC50aW1lb3V0KSk7dHJ5e3U9MSxqLnNlbmQocyx5KX1jYXRjaCh4KXtpZighKDI+dSkpdGhyb3cgeDt5KC0xLHgpfX1lbHNlIHkoLTEsIk5vIFRyYW5zcG9ydCIpO2Z1bmN0aW9uIHkoYixjLGQsZSl7dmFyIGsscyx0LHYseCx5PWM7MiE9PXUmJih1PTIsaCYmYS5jbGVhclRpbWVvdXQoaCksaj12b2lkIDAsZz1lfHwiIix3LnJlYWR5U3RhdGU9Yj4wPzQ6MCxrPWI+PTIwMCYmMzAwPmJ8fDMwND09PWIsZCYmKHY9VmIobCx3LGQpKSx2PVdiKGwsdix3LGspLGs/KGwuaWZNb2RpZmllZCYmKHg9dy5nZXRSZXNwb25zZUhlYWRlcigiTGFzdC1Nb2RpZmllZCIpLHgmJihuLmxhc3RNb2RpZmllZFtmXT14KSx4PXcuZ2V0UmVzcG9uc2VIZWFkZXIoImV0YWciKSx4JiYobi5ldGFnW2ZdPXgpKSwyMDQ9PT1ifHwiSEVBRCI9PT1sLnR5cGU/eT0ibm9jb250ZW50IjozMDQ9PT1iP3k9Im5vdG1vZGlmaWVkIjooeT12LnN0YXRlLHM9di5kYXRhLHQ9di5lcnJvcixrPSF0KSk6KHQ9eSwoYnx8IXkpJiYoeT0iZXJyb3IiLDA+YiYmKGI9MCkpKSx3LnN0YXR1cz1iLHcuc3RhdHVzVGV4dD0oY3x8eSkrIiIsaz9wLnJlc29sdmVXaXRoKG0sW3MseSx3XSk6cC5yZWplY3RXaXRoKG0sW3cseSx0XSksdy5zdGF0dXNDb2RlKHIpLHI9dm9pZCAwLGkmJm8udHJpZ2dlcihrPyJhamF4U3VjY2VzcyI6ImFqYXhFcnJvciIsW3csbCxrP3M6dF0pLHEuZmlyZVdpdGgobSxbdyx5XSksaSYmKG8udHJpZ2dlcigiYWpheENvbXBsZXRlIixbdyxsXSksLS1uLmFjdGl2ZXx8bi5ldmVudC50cmlnZ2VyKCJhamF4U3RvcCIpKSl9cmV0dXJuIHd9LGdldEpTT046ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuLmdldChhLGIsYywianNvbiIpfSxnZXRTY3JpcHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbi5nZXQoYSx2b2lkIDAsYiwic2NyaXB0Iil9fSksbi5lYWNoKFsiZ2V0IiwicG9zdCJdLGZ1bmN0aW9uKGEsYil7bltiXT1mdW5jdGlvbihhLGMsZCxlKXtyZXR1cm4gbi5pc0Z1bmN0aW9uKGMpJiYoZT1lfHxkLGQ9YyxjPXZvaWQgMCksbi5hamF4KG4uZXh0ZW5kKHt1cmw6YSx0eXBlOmIsZGF0YVR5cGU6ZSxkYXRhOmMsc3VjY2VzczpkfSxuLmlzUGxhaW5PYmplY3QoYSkmJmEpKX19KSxuLl9ldmFsVXJsPWZ1bmN0aW9uKGEpe3JldHVybiBuLmFqYXgoe3VybDphLHR5cGU6IkdFVCIsZGF0YVR5cGU6InNjcmlwdCIsY2FjaGU6ITAsYXN5bmM6ITEsZ2xvYmFsOiExLCJ0aHJvd3MiOiEwfSl9LG4uZm4uZXh0ZW5kKHt3cmFwQWxsOmZ1bmN0aW9uKGEpe2lmKG4uaXNGdW5jdGlvbihhKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpe24odGhpcykud3JhcEFsbChhLmNhbGwodGhpcyxiKSl9KTtpZih0aGlzWzBdKXt2YXIgYj1uKGEsdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCk7dGhpc1swXS5wYXJlbnROb2RlJiZiLmluc2VydEJlZm9yZSh0aGlzWzBdKSxiLm1hcChmdW5jdGlvbigpe3ZhciBhPXRoaXM7d2hpbGUoYS5maXJzdENoaWxkJiYxPT09YS5maXJzdENoaWxkLm5vZGVUeXBlKWE9YS5maXJzdENoaWxkO3JldHVybiBhfSkuYXBwZW5kKHRoaXMpfXJldHVybiB0aGlzfSx3cmFwSW5uZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIG4uaXNGdW5jdGlvbihhKT90aGlzLmVhY2goZnVuY3Rpb24oYil7bih0aGlzKS53cmFwSW5uZXIoYS5jYWxsKHRoaXMsYikpfSk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9bih0aGlzKSxjPWIuY29udGVudHMoKTtjLmxlbmd0aD9jLndyYXBBbGwoYSk6Yi5hcHBlbmQoYSl9KX0sd3JhcDpmdW5jdGlvbihhKXt2YXIgYj1uLmlzRnVuY3Rpb24oYSk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjKXtuKHRoaXMpLndyYXBBbGwoYj9hLmNhbGwodGhpcyxjKTphKX0pfSx1bndyYXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCl7bi5ub2RlTmFtZSh0aGlzLCJib2R5Iil8fG4odGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKX0pLmVuZCgpfX0pO2Z1bmN0aW9uIFhiKGEpe3JldHVybiBhLnN0eWxlJiZhLnN0eWxlLmRpc3BsYXl8fG4uY3NzKGEsImRpc3BsYXkiKX1mdW5jdGlvbiBZYihhKXt3aGlsZShhJiYxPT09YS5ub2RlVHlwZSl7aWYoIm5vbmUiPT09WGIoYSl8fCJoaWRkZW4iPT09YS50eXBlKXJldHVybiEwO2E9YS5wYXJlbnROb2RlfXJldHVybiExfW4uZXhwci5maWx0ZXJzLmhpZGRlbj1mdW5jdGlvbihhKXtyZXR1cm4gbC5yZWxpYWJsZUhpZGRlbk9mZnNldHMoKT9hLm9mZnNldFdpZHRoPD0wJiZhLm9mZnNldEhlaWdodDw9MCYmIWEuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg6WWIoYSl9LG4uZXhwci5maWx0ZXJzLnZpc2libGU9ZnVuY3Rpb24oYSl7cmV0dXJuIW4uZXhwci5maWx0ZXJzLmhpZGRlbihhKX07dmFyIFpiPS8lMjAvZywkYj0vXFtcXSQvLF9iPS9ccj9cbi9nLGFjPS9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxiYz0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24gY2MoYSxiLGMsZCl7dmFyIGU7aWYobi5pc0FycmF5KGIpKW4uZWFjaChiLGZ1bmN0aW9uKGIsZSl7Y3x8JGIudGVzdChhKT9kKGEsZSk6Y2MoYSsiWyIrKCJvYmplY3QiPT10eXBlb2YgZSYmbnVsbCE9ZT9iOiIiKSsiXSIsZSxjLGQpfSk7ZWxzZSBpZihjfHwib2JqZWN0IiE9PW4udHlwZShiKSlkKGEsYik7ZWxzZSBmb3IoZSBpbiBiKWNjKGErIlsiK2UrIl0iLGJbZV0sYyxkKX1uLnBhcmFtPWZ1bmN0aW9uKGEsYil7dmFyIGMsZD1bXSxlPWZ1bmN0aW9uKGEsYil7Yj1uLmlzRnVuY3Rpb24oYik/YigpOm51bGw9PWI/IiI6YixkW2QubGVuZ3RoXT1lbmNvZGVVUklDb21wb25lbnQoYSkrIj0iK2VuY29kZVVSSUNvbXBvbmVudChiKX07aWYodm9pZCAwPT09YiYmKGI9bi5hamF4U2V0dGluZ3MmJm4uYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSxuLmlzQXJyYXkoYSl8fGEuanF1ZXJ5JiYhbi5pc1BsYWluT2JqZWN0KGEpKW4uZWFjaChhLGZ1bmN0aW9uKCl7ZSh0aGlzLm5hbWUsdGhpcy52YWx1ZSl9KTtlbHNlIGZvcihjIGluIGEpY2MoYyxhW2NdLGIsZSk7cmV0dXJuIGQuam9pbigiJiIpLnJlcGxhY2UoWmIsIisiKX0sbi5mbi5leHRlbmQoe3NlcmlhbGl6ZTpmdW5jdGlvbigpe3JldHVybiBuLnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSl9LHNlcmlhbGl6ZUFycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7dmFyIGE9bi5wcm9wKHRoaXMsImVsZW1lbnRzIik7cmV0dXJuIGE/bi5tYWtlQXJyYXkoYSk6dGhpc30pLmZpbHRlcihmdW5jdGlvbigpe3ZhciBhPXRoaXMudHlwZTtyZXR1cm4gdGhpcy5uYW1lJiYhbih0aGlzKS5pcygiOmRpc2FibGVkIikmJmJjLnRlc3QodGhpcy5ub2RlTmFtZSkmJiFhYy50ZXN0KGEpJiYodGhpcy5jaGVja2VkfHwhWi50ZXN0KGEpKX0pLm1hcChmdW5jdGlvbihhLGIpe3ZhciBjPW4odGhpcykudmFsKCk7cmV0dXJuIG51bGw9PWM/bnVsbDpuLmlzQXJyYXkoYyk/bi5tYXAoYyxmdW5jdGlvbihhKXtyZXR1cm57bmFtZTpiLm5hbWUsdmFsdWU6YS5yZXBsYWNlKF9iLCJcclxuIil9fSk6e25hbWU6Yi5uYW1lLHZhbHVlOmMucmVwbGFjZShfYiwiXHJcbiIpfX0pLmdldCgpfX0pLG4uYWpheFNldHRpbmdzLnhocj12b2lkIDAhPT1hLkFjdGl2ZVhPYmplY3Q/ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0xvY2FsP2hjKCk6ZC5kb2N1bWVudE1vZGU+OD9nYygpOi9eKGdldHxwb3N0fGhlYWR8cHV0fGRlbGV0ZXxvcHRpb25zKSQvaS50ZXN0KHRoaXMudHlwZSkmJmdjKCl8fGhjKCl9OmdjO3ZhciBkYz0wLGVjPXt9LGZjPW4uYWpheFNldHRpbmdzLnhocigpO2EuYXR0YWNoRXZlbnQmJmEuYXR0YWNoRXZlbnQoIm9udW5sb2FkIixmdW5jdGlvbigpe2Zvcih2YXIgYSBpbiBlYyllY1thXSh2b2lkIDAsITApfSksbC5jb3JzPSEhZmMmJiJ3aXRoQ3JlZGVudGlhbHMiaW4gZmMsZmM9bC5hamF4PSEhZmMsZmMmJm4uYWpheFRyYW5zcG9ydChmdW5jdGlvbihiKXtpZighYi5jcm9zc0RvbWFpbnx8bC5jb3JzKXt2YXIgYztyZXR1cm57c2VuZDpmdW5jdGlvbihkLGUpe3ZhciBmLGc9Yi54aHIoKSxoPSsrZGM7aWYoZy5vcGVuKGIudHlwZSxiLnVybCxiLmFzeW5jLGIudXNlcm5hbWUsYi5wYXNzd29yZCksYi54aHJGaWVsZHMpZm9yKGYgaW4gYi54aHJGaWVsZHMpZ1tmXT1iLnhockZpZWxkc1tmXTtiLm1pbWVUeXBlJiZnLm92ZXJyaWRlTWltZVR5cGUmJmcub3ZlcnJpZGVNaW1lVHlwZShiLm1pbWVUeXBlKSxiLmNyb3NzRG9tYWlufHxkWyJYLVJlcXVlc3RlZC1XaXRoIl18fChkWyJYLVJlcXVlc3RlZC1XaXRoIl09IlhNTEh0dHBSZXF1ZXN0Iik7Zm9yKGYgaW4gZCl2b2lkIDAhPT1kW2ZdJiZnLnNldFJlcXVlc3RIZWFkZXIoZixkW2ZdKyIiKTtnLnNlbmQoYi5oYXNDb250ZW50JiZiLmRhdGF8fG51bGwpLGM9ZnVuY3Rpb24oYSxkKXt2YXIgZixpLGo7aWYoYyYmKGR8fDQ9PT1nLnJlYWR5U3RhdGUpKWlmKGRlbGV0ZSBlY1toXSxjPXZvaWQgMCxnLm9ucmVhZHlzdGF0ZWNoYW5nZT1uLm5vb3AsZCk0IT09Zy5yZWFkeVN0YXRlJiZnLmFib3J0KCk7ZWxzZXtqPXt9LGY9Zy5zdGF0dXMsInN0cmluZyI9PXR5cGVvZiBnLnJlc3BvbnNlVGV4dCYmKGoudGV4dD1nLnJlc3BvbnNlVGV4dCk7dHJ5e2k9Zy5zdGF0dXNUZXh0fWNhdGNoKGspe2k9IiJ9Znx8IWIuaXNMb2NhbHx8Yi5jcm9zc0RvbWFpbj8xMjIzPT09ZiYmKGY9MjA0KTpmPWoudGV4dD8yMDA6NDA0fWomJmUoZixpLGosZy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSl9LGIuYXN5bmM/ND09PWcucmVhZHlTdGF0ZT9hLnNldFRpbWVvdXQoYyk6Zy5vbnJlYWR5c3RhdGVjaGFuZ2U9ZWNbaF09YzpjKCl9LGFib3J0OmZ1bmN0aW9uKCl7YyYmYyh2b2lkIDAsITApfX19fSk7ZnVuY3Rpb24gZ2MoKXt0cnl7cmV0dXJuIG5ldyBhLlhNTEh0dHBSZXF1ZXN0fWNhdGNoKGIpe319ZnVuY3Rpb24gaGMoKXt0cnl7cmV0dXJuIG5ldyBhLkFjdGl2ZVhPYmplY3QoIk1pY3Jvc29mdC5YTUxIVFRQIil9Y2F0Y2goYil7fX1uLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oYSl7YS5jcm9zc0RvbWFpbiYmKGEuY29udGVudHMuc2NyaXB0PSExKX0pLG4uYWpheFNldHVwKHthY2NlcHRzOntzY3JpcHQ6InRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0In0sY29udGVudHM6e3NjcmlwdDovXGIoPzpqYXZhfGVjbWEpc2NyaXB0XGIvfSxjb252ZXJ0ZXJzOnsidGV4dCBzY3JpcHQiOmZ1bmN0aW9uKGEpe3JldHVybiBuLmdsb2JhbEV2YWwoYSksYX19fSksbi5hamF4UHJlZmlsdGVyKCJzY3JpcHQiLGZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEuY2FjaGUmJihhLmNhY2hlPSExKSxhLmNyb3NzRG9tYWluJiYoYS50eXBlPSJHRVQiLGEuZ2xvYmFsPSExKX0pLG4uYWpheFRyYW5zcG9ydCgic2NyaXB0IixmdW5jdGlvbihhKXtpZihhLmNyb3NzRG9tYWluKXt2YXIgYixjPWQuaGVhZHx8bigiaGVhZCIpWzBdfHxkLmRvY3VtZW50RWxlbWVudDtyZXR1cm57c2VuZDpmdW5jdGlvbihlLGYpe2I9ZC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKSxiLmFzeW5jPSEwLGEuc2NyaXB0Q2hhcnNldCYmKGIuY2hhcnNldD1hLnNjcmlwdENoYXJzZXQpLGIuc3JjPWEudXJsLGIub25sb2FkPWIub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKGEsYyl7KGN8fCFiLnJlYWR5U3RhdGV8fC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoYi5yZWFkeVN0YXRlKSkmJihiLm9ubG9hZD1iLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLGIucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLGI9bnVsbCxjfHxmKDIwMCwic3VjY2VzcyIpKX0sYy5pbnNlcnRCZWZvcmUoYixjLmZpcnN0Q2hpbGQpfSxhYm9ydDpmdW5jdGlvbigpe2ImJmIub25sb2FkKHZvaWQgMCwhMCl9fX19KTt2YXIgaWM9W10samM9Lyg9KVw/KD89JnwkKXxcP1w/LztuLmFqYXhTZXR1cCh7anNvbnA6ImNhbGxiYWNrIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9aWMucG9wKCl8fG4uZXhwYW5kbysiXyIrRGIrKztyZXR1cm4gdGhpc1thXT0hMCxhfX0pLG4uYWpheFByZWZpbHRlcigianNvbiBqc29ucCIsZnVuY3Rpb24oYixjLGQpe3ZhciBlLGYsZyxoPWIuanNvbnAhPT0hMSYmKGpjLnRlc3QoYi51cmwpPyJ1cmwiOiJzdHJpbmciPT10eXBlb2YgYi5kYXRhJiYwPT09KGIuY29udGVudFR5cGV8fCIiKS5pbmRleE9mKCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQiKSYmamMudGVzdChiLmRhdGEpJiYiZGF0YSIpO3JldHVybiBofHwianNvbnAiPT09Yi5kYXRhVHlwZXNbMF0/KGU9Yi5qc29ucENhbGxiYWNrPW4uaXNGdW5jdGlvbihiLmpzb25wQ2FsbGJhY2spP2IuanNvbnBDYWxsYmFjaygpOmIuanNvbnBDYWxsYmFjayxoP2JbaF09YltoXS5yZXBsYWNlKGpjLCIkMSIrZSk6Yi5qc29ucCE9PSExJiYoYi51cmwrPShFYi50ZXN0KGIudXJsKT8iJiI6Ij8iKStiLmpzb25wKyI9IitlKSxiLmNvbnZlcnRlcnNbInNjcmlwdCBqc29uIl09ZnVuY3Rpb24oKXtyZXR1cm4gZ3x8bi5lcnJvcihlKyIgd2FzIG5vdCBjYWxsZWQiKSxnWzBdfSxiLmRhdGFUeXBlc1swXT0ianNvbiIsZj1hW2VdLGFbZV09ZnVuY3Rpb24oKXtnPWFyZ3VtZW50c30sZC5hbHdheXMoZnVuY3Rpb24oKXt2b2lkIDA9PT1mP24oYSkucmVtb3ZlUHJvcChlKTphW2VdPWYsYltlXSYmKGIuanNvbnBDYWxsYmFjaz1jLmpzb25wQ2FsbGJhY2ssaWMucHVzaChlKSksZyYmbi5pc0Z1bmN0aW9uKGYpJiZmKGdbMF0pLGc9Zj12b2lkIDB9KSwic2NyaXB0Iik6dm9pZCAwfSksbC5jcmVhdGVIVE1MRG9jdW1lbnQ9ZnVuY3Rpb24oKXtpZighZC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQpcmV0dXJuITE7dmFyIGE9ZC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIiIpO3JldHVybiBhLmJvZHkuaW5uZXJIVE1MPSI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPiIsMj09PWEuYm9keS5jaGlsZE5vZGVzLmxlbmd0aH0oKSxuLnBhcnNlSFRNTD1mdW5jdGlvbihhLGIsYyl7aWYoIWF8fCJzdHJpbmciIT10eXBlb2YgYSlyZXR1cm4gbnVsbDsiYm9vbGVhbiI9PXR5cGVvZiBiJiYoYz1iLGI9ITEpLGI9Ynx8KGwuY3JlYXRlSFRNTERvY3VtZW50P2QuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCIiKTpkKTt2YXIgZT14LmV4ZWMoYSksZj0hYyYmW107cmV0dXJuIGU/W2IuY3JlYXRlRWxlbWVudChlWzFdKV06KGU9amEoW2FdLGIsZiksZiYmZi5sZW5ndGgmJm4oZikucmVtb3ZlKCksbi5tZXJnZShbXSxlLmNoaWxkTm9kZXMpKX07dmFyIGtjPW4uZm4ubG9hZDtuLmZuLmxvYWQ9ZnVuY3Rpb24oYSxiLGMpe2lmKCJzdHJpbmciIT10eXBlb2YgYSYma2MpcmV0dXJuIGtjLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgZCxlLGYsZz10aGlzLGg9YS5pbmRleE9mKCIgIik7cmV0dXJuIGg+LTEmJihkPW4udHJpbShhLnNsaWNlKGgsYS5sZW5ndGgpKSxhPWEuc2xpY2UoMCxoKSksbi5pc0Z1bmN0aW9uKGIpPyhjPWIsYj12b2lkIDApOmImJiJvYmplY3QiPT10eXBlb2YgYiYmKGU9IlBPU1QiKSxnLmxlbmd0aD4wJiZuLmFqYXgoe3VybDphLHR5cGU6ZXx8IkdFVCIsZGF0YVR5cGU6Imh0bWwiLGRhdGE6Yn0pLmRvbmUoZnVuY3Rpb24oYSl7Zj1hcmd1bWVudHMsZy5odG1sKGQ/bigiPGRpdj4iKS5hcHBlbmQobi5wYXJzZUhUTUwoYSkpLmZpbmQoZCk6YSl9KS5hbHdheXMoYyYmZnVuY3Rpb24oYSxiKXtnLmVhY2goZnVuY3Rpb24oKXtjLmFwcGx5KGcsZnx8W2EucmVzcG9uc2VUZXh0LGIsYV0pfSl9KSx0aGlzfSxuLmVhY2goWyJhamF4U3RhcnQiLCJhamF4U3RvcCIsImFqYXhDb21wbGV0ZSIsImFqYXhFcnJvciIsImFqYXhTdWNjZXNzIiwiYWpheFNlbmQiXSxmdW5jdGlvbihhLGIpe24uZm5bYl09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMub24oYixhKX19KSxuLmV4cHIuZmlsdGVycy5hbmltYXRlZD1mdW5jdGlvbihhKXtyZXR1cm4gbi5ncmVwKG4udGltZXJzLGZ1bmN0aW9uKGIpe3JldHVybiBhPT09Yi5lbGVtfSkubGVuZ3RofTtmdW5jdGlvbiBsYyhhKXtyZXR1cm4gbi5pc1dpbmRvdyhhKT9hOjk9PT1hLm5vZGVUeXBlP2EuZGVmYXVsdFZpZXd8fGEucGFyZW50V2luZG93OiExfW4ub2Zmc2V0PXtzZXRPZmZzZXQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGgsaSxqLGs9bi5jc3MoYSwicG9zaXRpb24iKSxsPW4oYSksbT17fTsic3RhdGljIj09PWsmJihhLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSIpLGg9bC5vZmZzZXQoKSxmPW4uY3NzKGEsInRvcCIpLGk9bi5jc3MoYSwibGVmdCIpLGo9KCJhYnNvbHV0ZSI9PT1rfHwiZml4ZWQiPT09aykmJm4uaW5BcnJheSgiYXV0byIsW2YsaV0pPi0xLGo/KGQ9bC5wb3NpdGlvbigpLGc9ZC50b3AsZT1kLmxlZnQpOihnPXBhcnNlRmxvYXQoZil8fDAsZT1wYXJzZUZsb2F0KGkpfHwwKSxuLmlzRnVuY3Rpb24oYikmJihiPWIuY2FsbChhLGMsbi5leHRlbmQoe30saCkpKSxudWxsIT1iLnRvcCYmKG0udG9wPWIudG9wLWgudG9wK2cpLG51bGwhPWIubGVmdCYmKG0ubGVmdD1iLmxlZnQtaC5sZWZ0K2UpLCJ1c2luZyJpbiBiP2IudXNpbmcuY2FsbChhLG0pOmwuY3NzKG0pfX0sbi5mbi5leHRlbmQoe29mZnNldDpmdW5jdGlvbihhKXtpZihhcmd1bWVudHMubGVuZ3RoKXJldHVybiB2b2lkIDA9PT1hP3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKGIpe24ub2Zmc2V0LnNldE9mZnNldCh0aGlzLGEsYil9KTt2YXIgYixjLGQ9e3RvcDowLGxlZnQ6MH0sZT10aGlzWzBdLGY9ZSYmZS5vd25lckRvY3VtZW50O2lmKGYpcmV0dXJuIGI9Zi5kb2N1bWVudEVsZW1lbnQsbi5jb250YWlucyhiLGUpPygidW5kZWZpbmVkIiE9dHlwZW9mIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0JiYoZD1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxjPWxjKGYpLHt0b3A6ZC50b3ArKGMucGFnZVlPZmZzZXR8fGIuc2Nyb2xsVG9wKS0oYi5jbGllbnRUb3B8fDApLGxlZnQ6ZC5sZWZ0KyhjLnBhZ2VYT2Zmc2V0fHxiLnNjcm9sbExlZnQpLShiLmNsaWVudExlZnR8fDApfSk6ZH0scG9zaXRpb246ZnVuY3Rpb24oKXtpZih0aGlzWzBdKXt2YXIgYSxiLGM9e3RvcDowLGxlZnQ6MH0sZD10aGlzWzBdO3JldHVybiJmaXhlZCI9PT1uLmNzcyhkLCJwb3NpdGlvbiIpP2I9ZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTooYT10aGlzLm9mZnNldFBhcmVudCgpLGI9dGhpcy5vZmZzZXQoKSxuLm5vZGVOYW1lKGFbMF0sImh0bWwiKXx8KGM9YS5vZmZzZXQoKSksYy50b3ArPW4uY3NzKGFbMF0sImJvcmRlclRvcFdpZHRoIiwhMCksYy5sZWZ0Kz1uLmNzcyhhWzBdLCJib3JkZXJMZWZ0V2lkdGgiLCEwKSkse3RvcDpiLnRvcC1jLnRvcC1uLmNzcyhkLCJtYXJnaW5Ub3AiLCEwKSxsZWZ0OmIubGVmdC1jLmxlZnQtbi5jc3MoZCwibWFyZ2luTGVmdCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPXRoaXMub2Zmc2V0UGFyZW50O3doaWxlKGEmJiFuLm5vZGVOYW1lKGEsImh0bWwiKSYmInN0YXRpYyI9PT1uLmNzcyhhLCJwb3NpdGlvbiIpKWE9YS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGF8fFFhfSl9fSksbi5lYWNoKHtzY3JvbGxMZWZ0OiJwYWdlWE9mZnNldCIsc2Nyb2xsVG9wOiJwYWdlWU9mZnNldCJ9LGZ1bmN0aW9uKGEsYil7dmFyIGM9L1kvLnRlc3QoYik7bi5mblthXT1mdW5jdGlvbihkKXtyZXR1cm4gWSh0aGlzLGZ1bmN0aW9uKGEsZCxlKXt2YXIgZj1sYyhhKTtyZXR1cm4gdm9pZCAwPT09ZT9mP2IgaW4gZj9mW2JdOmYuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W2RdOmFbZF06dm9pZChmP2Yuc2Nyb2xsVG8oYz9uKGYpLnNjcm9sbExlZnQoKTplLGM/ZTpuKGYpLnNjcm9sbFRvcCgpKTphW2RdPWUpOwp9LGEsZCxhcmd1bWVudHMubGVuZ3RoLG51bGwpfX0pLG4uZWFjaChbInRvcCIsImxlZnQiXSxmdW5jdGlvbihhLGIpe24uY3NzSG9va3NbYl09VWEobC5waXhlbFBvc2l0aW9uLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGM/KGM9U2EoYSxiKSxPYS50ZXN0KGMpP24oYSkucG9zaXRpb24oKVtiXSsicHgiOmMpOnZvaWQgMH0pfSksbi5lYWNoKHtIZWlnaHQ6ImhlaWdodCIsV2lkdGg6IndpZHRoIn0sZnVuY3Rpb24oYSxiKXtuLmVhY2goe3BhZGRpbmc6ImlubmVyIithLGNvbnRlbnQ6YiwiIjoib3V0ZXIiK2F9LGZ1bmN0aW9uKGMsZCl7bi5mbltkXT1mdW5jdGlvbihkLGUpe3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgmJihjfHwiYm9vbGVhbiIhPXR5cGVvZiBkKSxnPWN8fChkPT09ITB8fGU9PT0hMD8ibWFyZ2luIjoiYm9yZGVyIik7cmV0dXJuIFkodGhpcyxmdW5jdGlvbihiLGMsZCl7dmFyIGU7cmV0dXJuIG4uaXNXaW5kb3coYik/Yi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbImNsaWVudCIrYV06OT09PWIubm9kZVR5cGU/KGU9Yi5kb2N1bWVudEVsZW1lbnQsTWF0aC5tYXgoYi5ib2R5WyJzY3JvbGwiK2FdLGVbInNjcm9sbCIrYV0sYi5ib2R5WyJvZmZzZXQiK2FdLGVbIm9mZnNldCIrYV0sZVsiY2xpZW50IithXSkpOnZvaWQgMD09PWQ/bi5jc3MoYixjLGcpOm4uc3R5bGUoYixjLGQsZyl9LGIsZj9kOnZvaWQgMCxmLG51bGwpfX0pfSksbi5mbi5leHRlbmQoe2JpbmQ6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLm9uKGEsbnVsbCxiLGMpfSx1bmJpbmQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vZmYoYSxudWxsLGIpfSxkZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5vbihiLGEsYyxkKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMub2ZmKGEsIioqIik6dGhpcy5vZmYoYixhfHwiKioiLGMpfX0pLG4uZm4uc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aH0sbi5mbi5hbmRTZWxmPW4uZm4uYWRkQmFjaywiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoImpxdWVyeSIsW10sZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciBtYz1hLmpRdWVyeSxuYz1hLiQ7cmV0dXJuIG4ubm9Db25mbGljdD1mdW5jdGlvbihiKXtyZXR1cm4gYS4kPT09biYmKGEuJD1uYyksYiYmYS5qUXVlcnk9PT1uJiYoYS5qUXVlcnk9bWMpLG59LGJ8fChhLmpRdWVyeT1hLiQ9biksbn0pOwo=" type="text/javascript"> </script>
<!-- <script src="http://code.jquery.com/jquery-migrate-1.2.1.min.js" type="text/javascript"></script> -->

<script type="text/javascript">
  $(document).ready( function () {
    $("a[href^='http']:not([href*='" + location.hostname + "'])").attr('target', '_blank');
  });
</script>

<script type="text/javascript">
$(function(){
    var contentHeight = $("html, body").height();
    var windowHeight = $(window).height();
    var target = $("#TOC");
    var targetHeight = target.outerHeight();
    var targetPosition = target.position();
    var library = $("#CONTENT");
    var libraryHeight = library.outerHeight();
    var libraryPosition = library.position();
    var footer = $("#FOOTER");
    var footerHeight = footer.outerHeight();

    //adhoc
    target.css({position:"fixed", top: targetPosition.top - 1});
    target.css({position:"fixed", left: targetPosition.left - 1});

    target.outerHeight(Math.max(targetHeight, windowHeight - footerHeight));

    $(window).resize(function(){
        windowHeight = $(this).height();
        target.outerHeight(Math.max(targetHeight, windowHeight - footerHeight));
    });
    $(window).scroll(function(){
        var scrollTop = $(this).scrollTop();
        var visibleBottom = scrollTop + windowHeight;
        var targetBottom = targetPosition.top + targetHeight;
        var margin = Math.max(0, windowHeight - targetHeight) + footerHeight;
        
        if(scrollTop >= targetPosition.top){
          if(targetHeight > windowHeight){
            if(targetBottom <= visibleBottom){
					    //alert("t");
              target.css({position:"fixed", top : -targetBottom + windowHeight + 1});
              //console.log(target.position());
            }else{
              target.css({position:"fixed", top: -scrollTop});
              //console.log(target.position().top + " " + (-targetBottom) + " " + windowHeight);
            }
          }else{
            target.css({position:"fixed", top: 0});
          }
        }else{
          target.css({position:"fixed", top: targetPosition.top - 1}); //default
        }
    });
});
</script>
			</head>
	<body>
								<div id="TOC_WRAP">
			<nav id="TOC">
				<ul>
<li><a href="#template"><span class="toc-section-number">1</span> Template</a><ul>
<li><a href="#template"><span class="toc-section-number">1.1</span> 簡単なテンプレ</a></li>
<li><a href="#Scanner"><span class="toc-section-number">1.2</span> 自作Scanner</a></li>
<li><a href="#ConstantValues"><span class="toc-section-number">1.3</span> 定数</a></li>
<li><a href="#ArrayHelper"><span class="toc-section-number">1.4</span> 配列ヘルパ関数</a></li>
<li><a href="#upperbound"><span class="toc-section-number">1.5</span> UpperBound</a></li>
<li><a href="#lowerbound"><span class="toc-section-number">1.6</span> LowerBound</a></li>
</ul></li>
<li><a href="#datastructure"><span class="toc-section-number">2</span> DataStructure</a><ul>
<li><a href="#UnionFind"><span class="toc-section-number">2.1</span> Union-Find</a></li>
<li><a href="#WeightedUnionFind"><span class="toc-section-number">2.2</span> 重み付きUnion-Find</a></li>
<li><a href="#SumSegmentTree"><span class="toc-section-number">2.3</span> SegmentTree (単一加算と総和)</a></li>
<li><a href="#BIT"><span class="toc-section-number">2.4</span> BIT (単一加算と総和)</a></li>
<li><a href="#PersistentDynamicSumSegmentTree"><span class="toc-section-number">2.5</span> 動的永続SegmentTree (単一加算と総和)</a></li>
<li><a href="#LasyAddSumSegmentTree"><span class="toc-section-number">2.6</span> 遅延評価 SegmentTree (区間加算と総和)</a></li>
<li><a href="#LazySetSumSegmentTree"><span class="toc-section-number">2.7</span> 遅延評価 SegmentTree (範囲更新と総和)</a></li>
<li><a href="#RangeAddRangeMinimumQuerySegmentTree"><span class="toc-section-number">2.8</span> 範囲加算RMQ(SegmentTree)</a></li>
<li><a href="#StarrySkyTree"><span class="toc-section-number">2.9</span> StarrySkyTree</a></li>
<li><a href="#SparseTable"><span class="toc-section-number">2.10</span> SparseTable(RMQ)</a></li>
<li><a href="#RMNthQSegTree"><span class="toc-section-number">2.11</span> n番目の最小値(SegmentTree)</a></li>
<li><a href="#RMNthQWave"><span class="toc-section-number">2.12</span> n番目の最小値(Waveletっぽい)</a></li>
</ul></li>
<li><a href="#graph"><span class="toc-section-number">3</span> Graph</a><ul>
<li><a href="#AdjMat"><span class="toc-section-number">3.1</span> 隣接行列</a></li>
<li><a href="#AdjList"><span class="toc-section-number">3.2</span> 隣接リスト</a></li>
<li><a href="#FindCycle"><span class="toc-section-number">3.3</span> 閉路検出</a></li>
<li><a href="#TopologicalSort"><span class="toc-section-number">3.4</span> トポロジカルソート</a></li>
<li><a href="#WarshallFloydPathRestore"><span class="toc-section-number">3.5</span> ワーシャルフロイド(パス復元)</a></li>
<li><a href="#WarshallFloyd"><span class="toc-section-number">3.6</span> SCC(WarshallFloyd)</a></li>
<li><a href="#MinimumSteinerTree"><span class="toc-section-number">3.7</span> 最小シュタイナー木</a></li>
<li><a href="#OfflineLCA"><span class="toc-section-number">3.8</span> オフライン最小共通先祖</a></li>
<li><a href="#MinimumCutStoerWagner"><span class="toc-section-number">3.9</span> 全域最小カット</a></li>
</ul></li>
<li><a href="#math"><span class="toc-section-number">4</span> Math</a><ul>
<li><a href="#GCDux5fANDux5fLCM"><span class="toc-section-number">4.1</span> GCD, LCM</a></li>
<li><a href="#nextpermutation"><span class="toc-section-number">4.2</span> nextPermutation</a></li>
<li><a href="#Rational"><span class="toc-section-number">4.3</span> 有理数</a></li>
<li><a href="#BigRational"><span class="toc-section-number">4.4</span> 有理数</a></li>
</ul></li>
<li><a href="#mod"><span class="toc-section-number">5</span> Mod</a><ul>
<li><a href="#BinaryPowerMethodMOD"><span class="toc-section-number">5.1</span> 累乗 (mod m)</a></li>
<li><a href="#InvModP"><span class="toc-section-number">5.2</span> 逆元 (mod p)</a></li>
<li><a href="#EnumInvModP"><span class="toc-section-number">5.3</span> 逆元列挙 (mod p)</a></li>
<li><a href="#InvModM"><span class="toc-section-number">5.4</span> 逆元 (mod m)</a></li>
<li><a href="#ChineseRemainder"><span class="toc-section-number">5.5</span> 中国剰余定理</a></li>
<li><a href="#EulerPhiFunction"><span class="toc-section-number">5.6</span> オイラーのφ関数</a></li>
<li><a href="#EnumEulerPhiFunction"><span class="toc-section-number">5.7</span> オイラーのφ関数(列挙)</a></li>
<li><a href="#CarmichaelLambdaFunction"><span class="toc-section-number">5.8</span> カーマイケルのλ関数</a></li>
</ul></li>
<li><a href="#dimrealgeometry"><span class="toc-section-number">6</span> 2DimRealGeometry</a><ul>
<li><a href="#TwoDimBasis"><span class="toc-section-number">6.1</span> 基本データ構造</a></li>
</ul></li>
<li><a href="#dimintgeometry"><span class="toc-section-number">7</span> 2DimIntGeometry</a><ul>
<li><a href="#TwoIntDimPoint"><span class="toc-section-number">7.1</span> 2次元の点</a></li>
<li><a href="#TwoIntDimPoint"><span class="toc-section-number">7.2</span> 2次元の点</a></li>
</ul></li>
<li><a href="#string"><span class="toc-section-number">8</span> String</a><ul>
<li><a href="#ShiftAnd"><span class="toc-section-number">8.1</span> Shift And</a></li>
<li><a href="#rollingux5fhash"><span class="toc-section-number">8.2</span> Rolling Hash</a></li>
</ul></li>
<li><a href="#puzzle"><span class="toc-section-number">9</span> Puzzle</a><ul>
<li><a href="#Nim"><span class="toc-section-number">9.1</span> Nim(山N個, 制限無し)</a></li>
<li><a href="#misere-nim-ux5c71nux500b-ux5236ux9650ux306aux3057"><span class="toc-section-number">9.2</span> Misere Nim (山N個, 制限なし)</a></li>
<li><a href="#Dice"><span class="toc-section-number">9.3</span> サイコロ</a></li>
</ul></li>
</ul>
			</nav>
		</div>
				<div id="CONTENT">
			<h1 class="title">
				底辺ライブラリ(Teihen Library) 
				<span style="font-size:50%;">
					By もにょ～ん(@_monyone)
				</span>
			</h1>
			<hr>
			<h1 id="template"><span class="header-section-number">1</span> Template</h1>
<h2 id="template"><span class="header-section-number">1.1</span> 簡単なテンプレ</h2>
<p>入力が少ない(n &lt; 100000)場合はJava標準の Scanner で大丈夫.</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.util.Scanner;</span>

<span class="kw">public</span> <span class="kw">class</span> Main {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">debug</span>(Object <span class="kw">... </span>objs){
        System.<span class="fu">out</span>.<span class="fu">println</span>(Arrays.<span class="fu">toString</span>(objs));
    }

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args){
        Scanner sc = <span class="kw">new</span> Scanner(System.<span class="fu">in</span>);
        <span class="co">// input here</span>
        sc.<span class="fu">close</span>();
    }
}</code></pre></div>
<h2 id="Scanner"><span class="header-section-number">1.2</span> 自作Scanner</h2>
<p>入力が多い場合は, Java標準のScannerでは間に合わない. なので, 正規表現を使わないScannerを自作する必要がある.</p>
<h3 id="source-code-1" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> Scanner <span class="kw">implements</span> AutoCloseable {
    <span class="kw">private</span> BufferedReader br;
    <span class="kw">private</span> StringTokenizer tok;

    <span class="kw">public</span> Scanner(InputStream is) {
        br = <span class="kw">new</span> BufferedReader(<span class="kw">new</span> InputStreamReader(is));
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">getLine</span>() {
        <span class="kw">try</span> {
            <span class="kw">while</span> (!<span class="fu">hasNext</span>()) {tok = <span class="kw">new</span> StringTokenizer(br.<span class="fu">readLine</span>());}
        } <span class="kw">catch</span>(IOException e){ <span class="co">/* ignore */</span> }
    }

    <span class="kw">private</span> <span class="dt">boolean</span> <span class="fu">hasNext</span>() {
        <span class="kw">return</span> tok != <span class="kw">null</span> &amp;&amp; tok.<span class="fu">hasMoreTokens</span>();
    }

    <span class="kw">public</span> String <span class="fu">next</span>() {
        <span class="fu">getLine</span>(); <span class="kw">return</span> tok.<span class="fu">nextToken</span>();
    }

    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">nextInt</span>(){
        <span class="kw">return</span> Integer.<span class="fu">parseInt</span>(<span class="fu">next</span>());
    }
    <span class="co">// 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略</span>

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">close</span>() {
        <span class="kw">try</span>{ br.<span class="fu">close</span>(); } <span class="kw">catch</span> (IOException e){ <span class="co">/*ignore*/</span> }
    }
}</code></pre></div>
<h2 id="ConstantValues"><span class="header-section-number">1.3</span> 定数</h2>
<p>よく使う定数(INF, EPS等)</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">int</span> INF = Integer.<span class="fu">MAX_VALUE</span> / <span class="dv">2</span> - <span class="dv">1</span>;</code></pre></div>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">long</span> INF = Long.<span class="fu">MAX_VALUE</span> / <span class="dv">2</span> - <span class="dv">1</span>;</code></pre></div>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">double</span> EPS = <span class="fl">1e-9</span>;</code></pre></div>
<h2 id="ArrayHelper"><span class="header-section-number">1.4</span> 配列ヘルパ関数</h2>
<p>java.util.Arrays は弱いので, 適宜ヘルパ関数を定義しておくと便利.</p>
<h3 id="source-code-1" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> &lt;T&gt; <span class="dt">void</span> <span class="fu">swap</span>(T[] array, <span class="dt">int</span> fst, <span class="dt">int</span> snd){
    T tmp = array[fst];
    array[fst] = array[snd];
    array[snd] = tmp;
}</code></pre></div>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> &lt;T&gt; <span class="dt">void</span> <span class="fu">reverse</span>(T[] array, <span class="dt">int</span> begin, <span class="dt">int</span> end){ <span class="co">// [begin, end)</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = begin, j = end - <span class="dv">1</span>; i &lt; j; i++, j--) { <span class="fu">swap</span>(array, i, j); }
}</code></pre></div>
<h2 id="upperbound"><span class="header-section-number">1.5</span> UpperBound</h2>
<p>java.util.Arrays.binarySearch() は重複がある場合にどれを指すかは未定義. なので C++ の upper_bound() と似たようなものを独自定義する.</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> &lt;T <span class="kw">extends</span> Comparable&lt;? <span class="kw">super</span> T&gt;&gt; <span class="dt">int</span> <span class="fu">upper_bound</span>(T[] array, T key){
    <span class="dt">int</span> lower = -<span class="dv">1</span>, upper = array.<span class="fu">length</span>;
    <span class="co">// keep array[lower] &lt;= key &amp;&amp; key &lt; array[upper]</span>
    <span class="kw">while</span>(upper - lower &gt; <span class="dv">1</span>){
        <span class="dt">final</span> <span class="dt">int</span> mid = (lower + upper) / <span class="dv">2</span>;
        <span class="dt">final</span> <span class="dt">int</span> comp = array[mid].<span class="fu">compareTo</span>(key);

        <span class="kw">if</span>(comp &lt;= <span class="dv">0</span>){ lower = mid; }
        <span class="kw">else</span> <span class="kw">if</span>(comp &gt; <span class="dv">0</span>){ upper = mid;}
    }

    <span class="kw">return</span> upper;
}</code></pre></div>
<h2 id="lowerbound"><span class="header-section-number">1.6</span> LowerBound</h2>
<p>java.util.Arrays.binarySearch() は重複がある場合にどれを指すかは未定義. なので C++ の lower_bound() と似たようなものを独自定義する.</p>
<h3 id="source-code-1" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> &lt;T <span class="kw">extends</span> Comparable&lt;? <span class="kw">super</span> T&gt;&gt; <span class="dt">int</span> <span class="fu">lower_bound</span>(T[] array, T key){
    <span class="dt">int</span> lower = -<span class="dv">1</span>, upper = array.<span class="fu">length</span>;
    <span class="co">// keep array[lower] &lt; key &amp;&amp; key &lt;= array[upper]</span>
    <span class="kw">while</span>(upper - lower &gt; <span class="dv">1</span>){
        <span class="dt">final</span> <span class="dt">int</span> mid = (lower + upper) / <span class="dv">2</span>;
        <span class="dt">final</span> <span class="dt">int</span> comp = array[mid].<span class="fu">compareTo</span>(key);

        <span class="kw">if</span>(comp &lt; <span class="dv">0</span>){ lower = mid; }
        <span class="kw">else</span> <span class="kw">if</span>(comp &gt;= <span class="dv">0</span>){ upper = mid;}
    }

    <span class="kw">return</span> upper;
}</code></pre></div>
<h1 id="datastructure"><span class="header-section-number">2</span> DataStructure</h1>
<h2 id="UnionFind"><span class="header-section-number">2.1</span> Union-Find</h2>
<p>素集合管理用のデータ構造. 超頻出データ構造.</p>
<h3 id="ux7528ux9014" class="unnumbered">用途</h3>
<ul>
<li><p>グラフの連結成分の管理</p></li>
</ul>
<h3 id="ux8a08ux7b97ux91cf" class="unnumbered">計算量</h3>
<p>経路圧縮 + ランク併合 で アッカーマン関数の逆関数になる.</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> UnionFind{
    <span class="dt">int</span>[] par; <span class="co">//</span>
    
    <span class="kw">public</span> <span class="fu">UnionFind</span>(<span class="dt">int</span> n){
        par = <span class="kw">new</span> <span class="dt">int</span>[n];
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){ par[i] = -<span class="dv">1</span>; }
    }
    
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">find</span>(<span class="dt">int</span> x){
        <span class="kw">if</span>(par[x] &lt; <span class="dv">0</span>){
            <span class="kw">return</span> x;
        }<span class="kw">else</span>{
            <span class="kw">return</span> par[x] = <span class="fu">find</span>(par[x]);
        }
    }
    
    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">union</span>(<span class="dt">int</span> x, <span class="dt">int</span> y){
        x = <span class="fu">find</span>(x);
        y = <span class="fu">find</span>(y);
        
        <span class="kw">if</span>(x != y){
            <span class="kw">if</span>(par[y] &lt; par[x]) {  <span class="co">// 多い方が根になるようにスワップする.</span>
                <span class="dt">int</span> tmp = x; x = y; y = tmp;
            }
            par[x] += par[y];
            par[y] = x;
            <span class="kw">return</span> <span class="kw">true</span>;
        }<span class="kw">else</span>{
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    
    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">same</span>(<span class="dt">int</span> x, <span class="dt">int</span> y){
        <span class="kw">return</span> <span class="fu">find</span>(x) == <span class="fu">find</span>(y);
    }
    
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">size</span>(<span class="dt">int</span> x){
        <span class="kw">return</span> -par[<span class="fu">find</span>(x)];
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<ul>
<li><p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_A">AOJ DSL-1-A (Disjoint Set: Union Find Tree)</a></p></li>
</ul>
<h2 id="WeightedUnionFind"><span class="header-section-number">2.2</span> 重み付きUnion-Find</h2>
<p>UnionFindで同時にグループ内の重みを管理する. 同一グループで比較可能な値がオンラインで与えられる場合に使える.</p>
<h3 id="ux7528ux9014" class="unnumbered">用途</h3>
<ul>
<li><p>オンラインで比較した情報が渡される場合 (天秤とか)</p></li>
</ul>
<h3 id="ux8a08ux7b97ux91cf" class="unnumbered">計算量</h3>
<p>経路圧縮 + ランク併合 を使ってるため, アッカーマン関数の逆関数になる.</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> WeightedUnionFind{
    <span class="dt">int</span>[] par; <span class="co">// 親の番号</span>
    <span class="dt">int</span>[] ws;  <span class="co">// 親との重みの差</span>
    
    <span class="kw">public</span> <span class="fu">WeightedUnionFind</span>(<span class="dt">int</span> n){
        par = <span class="kw">new</span> <span class="dt">int</span>[n];
        ws  = <span class="kw">new</span> <span class="dt">int</span>[n];
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){ par[i] = -<span class="dv">1</span>; }
    }
    
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">find</span>(<span class="dt">int</span> x){
        <span class="kw">if</span>(par[x] &lt; <span class="dv">0</span>){
            <span class="kw">return</span> x;
        }<span class="kw">else</span>{
            <span class="dt">final</span> <span class="dt">int</span> parent = <span class="fu">find</span>(par[x]);
            ws[x] += ws[par[x]];
            <span class="kw">return</span> par[x] = parent;
        }
    }
    
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">weight</span>(<span class="dt">int</span> x){
        <span class="fu">find</span>(x); 
        <span class="kw">return</span> ws[x];
    }
    
    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">union</span>(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> w){ <span class="co">// x &lt;-(w)- y (x + w = y)</span>
        w += <span class="fu">weight</span>(x); 
        w -= <span class="fu">weight</span>(y);
        x = <span class="fu">find</span>(x); y = <span class="fu">find</span>(y);
        
        <span class="kw">if</span>(x != y){
            <span class="kw">if</span>(par[y] &lt; par[x]) {  <span class="co">// 多い方が根になるようにスワップする.</span>
                <span class="dt">int</span> tmp = x; x = y; y = tmp; w = -w;
            }
            par[x] += par[y]; par[y] = x;
            ws[y] = w;
            <span class="kw">return</span> <span class="kw">true</span>;
        }<span class="kw">else</span>{
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    
    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">same</span>(<span class="dt">int</span> x, <span class="dt">int</span> y){
        <span class="kw">return</span> <span class="fu">find</span>(x) == <span class="fu">find</span>(y);
    }
    
    <span class="kw">public</span> Integer <span class="fu">diff</span>(<span class="dt">int</span> x, <span class="dt">int</span> y){ <span class="co">// x - y を求める. 比較不能ならnull.</span>
        <span class="kw">if</span>(!<span class="fu">same</span>(x, y)){ <span class="kw">return</span> <span class="kw">null</span>; }
        <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">weight</span>(x) - <span class="kw">this</span>.<span class="fu">weight</span>(y);
    }
    <span class="co">// size()はUnionFindと同じなので省略.</span>
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<ul>
<li><p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330">AOJ 1330 (Never Wait for Weights)</a></p></li>
</ul>
<h2 id="SumSegmentTree"><span class="header-section-number">2.3</span> SegmentTree (単一加算と総和)</h2>
<p>範囲に関わるクエリを高速に処理するデータ構造.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>add(k) : O(log n) ※単一の値の更新</p></li>
<li><p>get(s,t): O(log n) ※範囲の値の計算</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> SegTree{
    <span class="dt">int</span> n;
    <span class="dt">long</span>[] dat;

    <span class="kw">public</span> <span class="fu">SegTree</span>(<span class="dt">int</span> n_) {
        <span class="dt">int</span> n = <span class="dv">1</span>;
        <span class="kw">while</span>(n &lt; n_){
            n *= <span class="dv">2</span>;
        }

        <span class="kw">this</span>.<span class="fu">n</span> = n;
        dat = <span class="kw">new</span> <span class="dt">long</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>];
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span> ; i++){
            dat[i] = <span class="dv">0</span>;
        }
    }

    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">calc</span>(<span class="dt">long</span> fst, <span class="dt">long</span> snd){ <span class="kw">return</span> fst + snd; }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">update</span>(<span class="dt">int</span> k, <span class="dt">long</span> a){
        k += n - <span class="dv">1</span>;
        dat[k] = a;

        <span class="kw">while</span>(k &gt; <span class="dv">0</span>){
            k = (k - <span class="dv">1</span>) / <span class="dv">2</span>;
            dat[k] = <span class="fu">calc</span>(dat[k * <span class="dv">2</span> + <span class="dv">1</span>], dat[k * <span class="dv">2</span> + <span class="dv">2</span>]);
        }
    }

    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">query</span>(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="kw">if</span>(r &lt;= a || b &lt;= l){
            <span class="kw">return</span> <span class="dv">0</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){
            <span class="kw">return</span> dat[k];
        }<span class="kw">else</span> {
            <span class="kw">return</span> <span class="fu">calc</span>(<span class="fu">query</span>(a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l, (l + r) / <span class="dv">2</span>), <span class="fu">query</span>(a, b, k * <span class="dv">2</span> + <span class="dv">2</span> , (l + r) / <span class="dv">2</span>, r));
        }
    }

    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">query</span>(<span class="dt">int</span> a, <span class="dt">int</span> b){
        <span class="kw">return</span> <span class="fu">query</span>(a, b, <span class="dv">0</span>, <span class="dv">0</span>, n);
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="BIT"><span class="header-section-number">2.4</span> BIT (単一加算と総和)</h2>
<p>累積値を計算する事に特化したデータ構造. 空間計算量 O(N) であり, 元のデータと同じ量のメモリ量で構築出来る.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>add(k) : O(log n) ※単一の値の更新</p></li>
<li><p>sum(s,t): O(log n) ※範囲の和の計算</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> BIT {
    <span class="dt">int</span>[] dat;
    
    <span class="kw">public</span> <span class="fu">BIT</span>(<span class="dt">int</span> n){
        dat = <span class="kw">new</span> <span class="dt">int</span>[n + <span class="dv">1</span>];
    }
    
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="dt">int</span> k, <span class="dt">int</span> a){ <span class="co">// k : 0-indexed</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = k + <span class="dv">1</span>; i &lt; dat.<span class="fu">length</span>; i += i &amp; -i){
            dat[i] += a;    
        }
    }
    
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">sum</span>(<span class="dt">int</span> s, <span class="dt">int</span> t){ <span class="co">// [s, t)</span>
        <span class="kw">if</span>(s &gt; <span class="dv">0</span>) <span class="kw">return</span> <span class="fu">sum</span>(<span class="dv">0</span>, t) - <span class="fu">sum</span>(<span class="dv">0</span>, s);
        
        <span class="dt">int</span> ret = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = t; i &gt; <span class="dv">0</span>; i -= i &amp; -i) {
            ret += dat[i];
        }
        <span class="kw">return</span> ret;
    }
    
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">get</span>(<span class="dt">int</span> k){ <span class="co">// k : 0-indexed</span>
        <span class="dt">int</span> p = Integer.<span class="fu">highestOneBit</span>(dat.<span class="fu">length</span> - <span class="dv">1</span>);
        <span class="kw">for</span>(<span class="dt">int</span> q = p; q &gt; <span class="dv">0</span>; q &gt;&gt;= <span class="dv">1</span>, p |= q){
            <span class="kw">if</span>( p &gt;= dat.<span class="fu">length</span> || k &lt; dat[p]) p ^= q;
            <span class="kw">else</span> k -= dat[p];
        }
        <span class="kw">return</span> p;
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<ul>
<li><p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B">AOJ DSL-2-B (Range Sum Query)</a></p></li>
<li><p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0516">AOJ 0516 (Maximum Sum)</a></p></li>
</ul>
<h2 id="PersistentDynamicSumSegmentTree"><span class="header-section-number">2.5</span> 動的永続SegmentTree (単一加算と総和)</h2>
<p>Indexの範囲が広く, updateが密ではない場合, 動的SegTreeも検討すべき.<br />
(クエリ先読みができる場合は, 座標圧縮するだけで済む. 要検討.)</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>update(k) : O(log n) ※単一の値の更新</p></li>
<li><p>query(s,t): O(log n) ※範囲<span>[</span>s,t)の和の計算</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> SegTree {
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">long</span> DEFAULT = <span class="dv">0</span>; <span class="co">// 単位元</span>

    <span class="kw">private</span> <span class="dt">long</span> lower, upper; <span class="co">// [lower, upper)</span>
    <span class="kw">private</span> SegTree left, right;
    <span class="kw">private</span> <span class="dt">long</span> value = DEFAULT; <span class="co">// 初期値は単位元</span>

    <span class="kw">public</span> <span class="fu">SegTree</span>(<span class="dt">final</span> <span class="dt">long</span> n){ <span class="kw">this</span>(<span class="dv">0</span>, Long.<span class="fu">highestOneBit</span>(n) &lt;&lt; 1l); }

    <span class="kw">private</span> <span class="fu">SegTree</span>(<span class="dt">long</span> lower, <span class="dt">long</span> upper){ <span class="kw">this</span>(lower, upper, DEFAULT); }
    <span class="kw">private</span> <span class="fu">SegTree</span>(<span class="dt">final</span> <span class="dt">long</span> lower, <span class="dt">final</span> <span class="dt">long</span> upper, <span class="dt">final</span> <span class="dt">long</span> value){
        <span class="kw">this</span>.<span class="fu">lower</span> = lower; <span class="kw">this</span>.<span class="fu">upper</span> = upper; <span class="kw">this</span>.<span class="fu">value</span> = value;
    }

    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">get</span>(SegTree s){<span class="kw">return</span> s==<span class="kw">null</span> ? DEFAULT : s.<span class="fu">value</span>;}

    <span class="kw">public</span> SegTree <span class="fu">update</span>(<span class="dt">final</span> <span class="dt">long</span> index, <span class="dt">final</span> <span class="dt">long</span> value){
        <span class="kw">if</span>(<span class="kw">this</span>.<span class="fu">lower</span> == index &amp;&amp; <span class="kw">this</span>.<span class="fu">upper</span> == index + <span class="dv">1</span>){
            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">SegTree</span>(index, index + <span class="dv">1</span>, value);
        }<span class="kw">else</span>{<span class="co">// split to [lower, middle) and [middle, upper)</span>
            <span class="dt">final</span> <span class="dt">long</span> middle = (<span class="kw">this</span>.<span class="fu">lower</span> + <span class="kw">this</span>.<span class="fu">upper</span>) / <span class="dv">2</span>;
            <span class="dt">final</span> SegTree ret = <span class="kw">new</span> <span class="fu">SegTree</span>(<span class="kw">this</span>.<span class="fu">lower</span>, <span class="kw">this</span>.<span class="fu">upper</span>);

            <span class="kw">if</span>(index &lt; middle){ <span class="co">//update in [lower, middle)</span>
                ret.<span class="fu">left</span> = <span class="kw">this</span>.<span class="fu">left</span> != <span class="kw">null</span> ? <span class="kw">this</span>.<span class="fu">left</span>
                        : <span class="kw">new</span> <span class="fu">SegTree</span>(<span class="kw">this</span>.<span class="fu">lower</span>, middle);
                ret.<span class="fu">left</span> = ret.<span class="fu">left</span>.<span class="fu">update</span>(index, value);
                ret.<span class="fu">right</span> = right;
            }<span class="kw">else</span>{ <span class="co">//update in [middle, upper)</span>
                ret.<span class="fu">left</span> = <span class="kw">this</span>.<span class="fu">left</span>;
                ret.<span class="fu">right</span> = <span class="kw">this</span>.<span class="fu">right</span> != <span class="kw">null</span> ? <span class="kw">this</span>.<span class="fu">right</span>
                        : <span class="kw">new</span> <span class="fu">SegTree</span>(middle, <span class="kw">this</span>.<span class="fu">upper</span>);
                ret.<span class="fu">right</span> = ret.<span class="fu">right</span>.<span class="fu">update</span>(index, value);
            }
            ret.<span class="fu">value</span> = <span class="fu">get</span>(ret.<span class="fu">left</span>) + <span class="fu">get</span>(ret.<span class="fu">right</span>);

            <span class="kw">return</span> ret;
        }
    }

    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">query</span>(<span class="dt">long</span> lower, <span class="dt">long</span> upper){
        <span class="kw">if</span>(<span class="kw">this</span>.<span class="fu">upper</span> &lt;= lower || upper &lt;= <span class="kw">this</span>.<span class="fu">lower</span>){
            <span class="kw">return</span> DEFAULT;
        }<span class="kw">else</span> <span class="kw">if</span>(lower &lt;= <span class="kw">this</span>.<span class="fu">lower</span> &amp;&amp; <span class="kw">this</span>.<span class="fu">upper</span> &lt;= upper){
            <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">value</span>;
        }
        <span class="dt">final</span> <span class="dt">long</span> middle = (<span class="kw">this</span>.<span class="fu">lower</span> + <span class="kw">this</span>.<span class="fu">upper</span>) / <span class="dv">2</span>;
        <span class="kw">return</span> (left == <span class="kw">null</span> ? DEFAULT : left.<span class="fu">query</span>(lower, middle))
            + (right == <span class="kw">null</span> ? DEFAULT : right.<span class="fu">query</span>(middle, upper));
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>TODO</p>
<h2 id="LasyAddSumSegmentTree"><span class="header-section-number">2.6</span> 遅延評価 SegmentTree (区間加算と総和)</h2>
<p>SegmentTreeでは区間に対する add に <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mspace width="0.278em"></mspace><mi>l</mi><mi>o</mi><mi>g</mi><mspace width="0.278em"></mspace><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n \; log\; n)</annotation></semantics></math> かかってしまう.<br />
add のクエリを遅延評価することで 区間add を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mspace width="0.278em"></mspace><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(log\; n)</annotation></semantics></math> に抑える.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>add(v,s,t): O(log n) ※範囲の値の加算</p></li>
<li><p>sum(s,t): O(log n) ※範囲の値の取得</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> LazyAddSumSegmentTree{
    <span class="dt">int</span> n;
    <span class="dt">long</span>[] dat, lazy;

    <span class="kw">public</span> <span class="fu">LazyAddSumSegmentTree</span>(<span class="dt">int</span> n_) {
        <span class="dt">int</span> n = <span class="dv">1</span>;
        <span class="kw">while</span>(n &lt; n_){ n *= <span class="dv">2</span>;} <span class="kw">this</span>.<span class="fu">n</span> = n;
        dat = <span class="kw">new</span> <span class="dt">long</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>];
        lazy = <span class="kw">new</span> <span class="dt">long</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>];
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">evaluate_lazy</span>(<span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        dat[k] += lazy[k] * (r - l);
        <span class="kw">if</span>(k &lt; n - <span class="dv">1</span>){
            lazy[<span class="dv">2</span> * k + <span class="dv">1</span>] += lazy[k]; lazy[<span class="dv">2</span> * k + <span class="dv">2</span>] += lazy[k];
        }
        lazy[k] = <span class="dv">0</span>;
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">update_node</span>(<span class="dt">int</span> k){ dat[k] = dat[<span class="dv">2</span>*k<span class="dv">+1</span>] + dat[<span class="dv">2</span>*k<span class="dv">+2</span>]; }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="dt">long</span> v, <span class="dt">int</span> a, <span class="dt">int</span> b){ <span class="fu">add</span>(v, a, b, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>); }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="dt">long</span> v, <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="fu">evaluate_lazy</span>(k, l, r);

        <span class="kw">if</span>(r &lt;= a || b &lt;= l){ <span class="kw">return</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){
            lazy[k] += v; <span class="fu">evaluate_lazy</span>(k, l, r);
        }<span class="kw">else</span> {
            <span class="fu">add</span>(v, a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l , (l + r) / <span class="dv">2</span>);
            <span class="fu">add</span>(v, a, b, k * <span class="dv">2</span> + <span class="dv">2</span>, (l + r) / <span class="dv">2</span>, r);
            <span class="fu">update_node</span>(k);
        }
    }

    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">sum</span>(<span class="dt">int</span> a, <span class="dt">int</span> b){ <span class="kw">return</span> <span class="fu">sum</span>(a, b, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>); }
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">sum</span>(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="fu">evaluate_lazy</span>(k, l, r);

        <span class="kw">if</span>(r &lt;= a || b &lt;= l){ <span class="kw">return</span> <span class="dv">0</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){ <span class="kw">return</span> dat[k];
        }<span class="kw">else</span> {
            <span class="dt">long</span> v1 = <span class="fu">sum</span>(a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l , (l + r) / <span class="dv">2</span>);
            <span class="dt">long</span> v2 = <span class="fu">sum</span>(a, b, k * <span class="dv">2</span> + <span class="dv">2</span>, (l + r) / <span class="dv">2</span>, r);
            <span class="fu">update_node</span>(k); <span class="kw">return</span> v1 + v2;
        }
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>TODO</p>
<h2 id="LazySetSumSegmentTree"><span class="header-section-number">2.7</span> 遅延評価 SegmentTree (範囲更新と総和)</h2>
<p>遅延評価の利点として時系列が重要な操作も扱え、“範囲をある値にする” というのも出来る。</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>set(v,s,t): O(log n) ※ 範囲<span>[</span>s, t) を v に更新</p></li>
<li><p>sum(s,t): O(log n) ※範囲<span>[</span>s,t)の和の計算</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> LazySetSumSegmentTree {
    <span class="dt">int</span> n;
    <span class="dt">long</span>[] dat, lazy;
    <span class="dt">boolean</span>[] push;

    <span class="kw">public</span> <span class="fu">LazySetSumSegmentTree</span>(<span class="dt">int</span> n_) {
        <span class="dt">int</span> n = <span class="dv">1</span>;
        <span class="kw">while</span>(n &lt; n_){ n *= <span class="dv">2</span>;} <span class="kw">this</span>.<span class="fu">n</span> = n;
        dat = <span class="kw">new</span> <span class="dt">long</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>];
        lazy = <span class="kw">new</span> <span class="dt">long</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>];
        push = <span class="kw">new</span> <span class="dt">boolean</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>];
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">evaluate_lazy</span>(<span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="kw">if</span>(!push[k]){ <span class="kw">return</span>; }
        dat[k] = lazy[k] * (r - l);
        <span class="kw">if</span>(k &lt; n - <span class="dv">1</span>){
            lazy[k * <span class="dv">2</span> + <span class="dv">1</span>] = lazy[k * <span class="dv">2</span> + <span class="dv">2</span>] = lazy[k];
            push[k * <span class="dv">2</span> + <span class="dv">1</span>] = push[k * <span class="dv">2</span> + <span class="dv">2</span>] = <span class="kw">true</span>;
        }
        lazy[k] = <span class="dv">0</span>; push[k] = <span class="kw">false</span>;
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">update_node</span>(<span class="dt">int</span> k){ dat[k] = dat[k*<span class="dv">2+1</span>] + dat[k*<span class="dv">2+2</span>]; }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">set</span>(<span class="dt">long</span> v, <span class="dt">int</span> a, <span class="dt">int</span> b){ <span class="fu">set</span>(v, a, b, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>); }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">set</span>(<span class="dt">long</span> v, <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="fu">evaluate_lazy</span>(k, l, r);
        <span class="kw">if</span>(r &lt;= a || b &lt;= l){ <span class="kw">return</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){
            lazy[k] = v; push[k] = <span class="kw">true</span>;
            <span class="fu">evaluate_lazy</span>(k, l, r);
        }<span class="kw">else</span>{
            <span class="fu">set</span>(v, a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l, (l + r) / <span class="dv">2</span>);
            <span class="fu">set</span>(v, a, b, k * <span class="dv">2</span> + <span class="dv">2</span>, (l + r) / <span class="dv">2</span>, r);
            <span class="fu">update_node</span>(k);
        }
    }
    
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">sum</span>(<span class="dt">int</span> a, <span class="dt">int</span> b){ <span class="kw">return</span> <span class="fu">sum</span>(a, b, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>); }
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">sum</span>(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="fu">evaluate_lazy</span>(k, l, r);
        <span class="kw">if</span>(r &lt;= a || b &lt;= l){ <span class="kw">return</span> <span class="dv">0</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){ <span class="kw">return</span> dat[k];
        }<span class="kw">else</span>{
            <span class="dt">final</span> <span class="dt">long</span> v1 = <span class="fu">sum</span>(a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l, (l + r) / <span class="dv">2</span>);
            <span class="dt">final</span> <span class="dt">long</span> v2 = <span class="fu">sum</span>(a, b, k * <span class="dv">2</span> + <span class="dv">2</span>, (l + r) / <span class="dv">2</span>, r);
            <span class="fu">update_node</span>(k); <span class="kw">return</span> v1 + v2;
        }
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<ul>
<li><p><a href="https://yukicoder.me/problems/no/230">yukicoder No.230 Splarraay ｽﾌﾟﾗﾚｪｰｲ</a> <a href="https://yukicoder.me/submissions/214767"><span>[</span>提出<span>]</span></a></p></li>
</ul>
<h2 id="RangeAddRangeMinimumQuerySegmentTree"><span class="header-section-number">2.8</span> 範囲加算RMQ(SegmentTree)</h2>
<p>範囲加算をサポートした RMQ(Range Minimum Query) の実装.<br />
範囲での加算と最小値の計算を効率的に行える.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>add(s,t,v) : O(log n) ※範囲<span>[</span>s,t)への加算</p></li>
<li><p>min(s,t) : O(log n) ※範囲<span>[</span>s,t)の最小値</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// 初期値は [0,n) = 0, 範囲minが手抜きなので,番兵(INF)が必要.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> RMQ {
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">long</span> INF = Long.<span class="fu">MAX_VALUE</span> / <span class="dv">2</span> - <span class="dv">1</span>;
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">long</span> DEFAULT = <span class="dv">0</span>; <span class="co">// 単位元</span>

    <span class="dt">int</span> n; <span class="dt">long</span>[] min, add; <span class="co">// add[k]...範囲に足した値. min[k]...その時点での最小値</span>

    <span class="kw">public</span> <span class="fu">RMQ</span>(<span class="dt">int</span> n_) {
        <span class="dt">int</span> n = <span class="dv">1</span>;
        <span class="kw">while</span>(n &lt; n_){ n *= <span class="dv">2</span>;} <span class="kw">this</span>.<span class="fu">n</span> = n;
        min = <span class="kw">new</span> <span class="dt">long</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>]; add = <span class="kw">new</span> <span class="dt">long</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>];
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span> ; i++){
            min[i] = DEFAULT; add[i] = DEFAULT;
        }
    }

    <span class="co">// [a, b) に v を足す</span>
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="dt">long</span> v, <span class="dt">int</span> a, <span class="dt">int</span> b){ <span class="fu">add</span>(v, a, b, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>); }
    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="dt">long</span> v, <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="kw">if</span>(r &lt;= a || b &lt;= l){ <span class="kw">return</span>; } <span class="co">// 完全に範囲外</span>
        <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b) { <span class="co">// 完全に範囲内</span>
            add[k] += v;
        }<span class="kw">else</span>{ <span class="co">//範囲外を含む -&gt; 二分割して再帰</span>
            <span class="fu">add</span>(v, a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l, (l + r) / <span class="dv">2</span>);
            <span class="fu">add</span>(v, a, b, k * <span class="dv">2</span> + <span class="dv">2</span>, (l + r) / <span class="dv">2</span>, r);
        }
        min[k] = (k &gt;= (n - <span class="dv">1</span>) ? DEFAULT : Math.<span class="fu">min</span>(min[k * <span class="dv">2</span> + <span class="dv">1</span>], min[k * <span class="dv">2</span> + <span class="dv">2</span>])) + add[k];
    }

    <span class="co">// [a, b) の範囲での最小値を求める</span>
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">min</span>(<span class="dt">long</span> a, <span class="dt">long</span> b){ <span class="kw">return</span> <span class="fu">min</span>(a, b, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>); }
    <span class="kw">private</span> <span class="dt">long</span> <span class="fu">min</span>(<span class="dt">long</span> a, <span class="dt">long</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="kw">if</span>(r &lt;= a || b &lt;= l){ <span class="kw">return</span> INF; } <span class="co">// 簡単のため適当に大きい値を返す.</span>
        <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){ <span class="kw">return</span> min[k]; } <span class="co">//</span>

        <span class="dt">final</span> <span class="dt">long</span> left_min  = <span class="fu">min</span>(a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l, (l + r) / <span class="dv">2</span>);
        <span class="dt">final</span> <span class="dt">long</span> right_min = <span class="fu">min</span>(a, b, k * <span class="dv">2</span> + <span class="dv">2</span>, (l + r) / <span class="dv">2</span>, r);
        <span class="kw">return</span> Math.<span class="fu">min</span>(left_min, right_min) + add[k]; <span class="co">//</span>
    }

    <span class="co">// [index] での値を求める</span>
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">value</span>(<span class="dt">int</span> index){
        <span class="dt">int</span> k = index + <span class="kw">this</span>.<span class="fu">n</span> - <span class="dv">1</span>;
        <span class="dt">long</span> value = add[k];
        <span class="kw">while</span>(k &gt; <span class="dv">0</span>){ k = (k - <span class="dv">1</span>) / <span class="dv">2</span>; value += add[k]; }
        <span class="kw">return</span> value;
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>TODO</p>
<h2 id="StarrySkyTree"><span class="header-section-number">2.9</span> StarrySkyTree</h2>
<p>範囲の加算と範囲の最大値クエリを効率的に処理するデータ構造.<br />
子ノードのうちどちらかは0, もう一方は0以下という制約を設けることで, 配列一つで両方のクエリをサポートでき, 記憶域に対してもやさしい構造になっている.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>add(s,t,v) : O(log n) ※範囲<span>[</span>s,t)への加算</p></li>
<li><p>max(s,t) : O(log n) ※範囲<span>[</span>s,t)の最大値</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// JOI界隈で人気な, ちょっと特殊なRMQ(Range Maximum Query).</span>
<span class="co">// 根は全体の最大値, 子ノードのうちどちらかは 0, もう一方は 0 以下を満たす.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> StarrySkyTree {
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">long</span> M_INF = Long.<span class="fu">MIN_VALUE</span> / <span class="dv">2</span> + <span class="dv">1</span>;
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">long</span> DEFAULT = <span class="dv">0</span>; <span class="co">// 単位元</span>

    <span class="dt">int</span> n; <span class="dt">long</span>[] add; <span class="co">//addは上記の制約を満たす.</span>

    <span class="kw">public</span> <span class="fu">StarrySkyTree</span>(<span class="dt">int</span> n_) {
        <span class="dt">int</span> n = <span class="dv">1</span>;
        <span class="kw">while</span>(n &lt; n_){ n *= <span class="dv">2</span>;} <span class="kw">this</span>.<span class="fu">n</span> = n;
        add = <span class="kw">new</span> <span class="dt">long</span>[<span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span>];
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="kw">this</span>.<span class="fu">n</span> * <span class="dv">2</span> - <span class="dv">1</span> ; i++){ add[i] = DEFAULT; }
    }

    <span class="co">// [a, b) に v を足す</span>
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="dt">long</span> v, <span class="dt">int</span> a, <span class="dt">int</span> b){ <span class="fu">add</span>(v, a, b, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>); }
    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="dt">long</span> v, <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="kw">if</span>(k == <span class="dv">0</span>){ add[k] += v; } <span class="co">// 全体に加算しておく.</span>
        <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b) { <span class="kw">return</span>; } <span class="co">// 完全に範囲内</span>
        <span class="kw">if</span>(r &lt;= a || b &lt;= l) { add[k] -= v; <span class="kw">return</span>; } <span class="co">// 完全に範囲外</span>
        <span class="co">// 範囲外を含む -&gt; 二分割して再帰</span>
        <span class="fu">add</span>(v, a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l, (l + r) / <span class="dv">2</span>);
        <span class="fu">add</span>(v, a, b, k * <span class="dv">2</span> + <span class="dv">2</span>, (l + r) / <span class="dv">2</span>, r);
        <span class="co">// どちらかが 0 になるように, 子供の最大値を子供から引いて親に足す.</span>
        <span class="dt">final</span> <span class="dt">long</span> child_max = Math.<span class="fu">max</span>(add[k * <span class="dv">2</span> + <span class="dv">1</span>], add[k * <span class="dv">2</span> + <span class="dv">2</span>]);
        add[k * <span class="dv">2</span> + <span class="dv">1</span>] -= child_max; add[k * <span class="dv">2</span> + <span class="dv">2</span>] -= child_max;
        add[k] += child_max;
    }

    <span class="co">// [a, b) の範囲での最大値を求める</span>
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">max</span>(<span class="dt">long</span> a, <span class="dt">long</span> b){ <span class="kw">return</span> <span class="fu">max</span>(a, b, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>); }
    <span class="kw">private</span> <span class="dt">long</span> <span class="fu">max</span>(<span class="dt">long</span> a, <span class="dt">long</span> b, <span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r){
        <span class="kw">if</span>(r &lt;= a || b &lt;= l){ <span class="kw">return</span> M_INF; } <span class="co">// 簡単のため適当に小さい値を返す.</span>
        <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){ <span class="kw">return</span> add[k]; } <span class="co">// 子孫のaddは 0 を選べる.</span>

        <span class="dt">final</span> <span class="dt">long</span> left_max  = <span class="fu">max</span>(a, b, k * <span class="dv">2</span> + <span class="dv">1</span>, l, (l + r) / <span class="dv">2</span>);
        <span class="dt">final</span> <span class="dt">long</span> right_max = <span class="fu">max</span>(a, b, k * <span class="dv">2</span> + <span class="dv">2</span>, (l + r) / <span class="dv">2</span>, r);
        <span class="kw">return</span> Math.<span class="fu">max</span>(left_max, right_max) + add[k]; <span class="co">//</span>
    }

    <span class="co">// [index] での値を求める</span>
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">value</span>(<span class="dt">int</span> index){
        <span class="dt">int</span> k = index + <span class="kw">this</span>.<span class="fu">n</span> - <span class="dv">1</span>;
        <span class="dt">long</span> value = add[k];
        <span class="kw">while</span>(k &gt; <span class="dv">0</span>){ k = (k - <span class="dv">1</span>) / <span class="dv">2</span>; value += add[k]; }
        <span class="kw">return</span> value;
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>TODO</p>
<h2 id="SparseTable"><span class="header-section-number">2.10</span> SparseTable(RMQ)</h2>
<p>最大値クエリをO(1)で処理するデータ構造. しかし, 構築や値の更新にO(n log n)かかる.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>update(k,v) : O(n log n) ※単体への加算</p></li>
<li><p>max(s,t) : O(1) ※範囲<span>[</span>s,t)の最大値</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> RMQ {
    <span class="dt">long</span>[][] sparse_table; <span class="co">// queryを O(1)にするなら, k をメモ化する事.</span>

    <span class="kw">public</span> <span class="fu">RMQ</span>(<span class="dt">long</span>[] array){ <span class="co">// O(n log n)</span>
        <span class="dt">final</span> <span class="dt">int</span> depth = Integer.<span class="fu">numberOfTrailingZeros</span>(Integer.<span class="fu">highestOneBit</span>(array.<span class="fu">length</span>));
        sparse_table = <span class="kw">new</span> <span class="dt">long</span>[depth + <span class="dv">1</span>][]; sparse_table[<span class="dv">0</span>] = <span class="kw">new</span> <span class="dt">long</span>[array.<span class="fu">length</span>];
        System.<span class="fu">arraycopy</span>(array, <span class="dv">0</span>, sparse_table[<span class="dv">0</span>], <span class="dv">0</span>, array.<span class="fu">length</span>);

        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">1</span>; k &lt; sparse_table.<span class="fu">length</span>; k++){
            sparse_table[k] = <span class="kw">new</span> <span class="dt">long</span>[array.<span class="fu">length</span> - (<span class="dv">1</span> &lt;&lt; k) + <span class="dv">1</span>];
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i + (<span class="dv">1</span> &lt;&lt; k) &lt;= array.<span class="fu">length</span>; i++) { <span class="co">// [i, i + (1 &lt;&lt; k))</span>
                <span class="co">// [i, i + (1 &lt;&lt; k) -&gt; [i, i + (1 &lt;&lt; k) / 2), [i + (1 &lt;&lt; k) / 2, i &lt;&lt; (k - 1))</span>
                sparse_table[k][i] =
                        Math.<span class="fu">min</span>(sparse_table[k<span class="dv">-1</span>][i], sparse_table[k<span class="dv">-1</span>][i + (<span class="dv">1</span> &lt;&lt; (k - <span class="dv">1</span>))]);
            }
        }
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">update</span>(<span class="dt">int</span> index, <span class="dt">long</span> v){ <span class="co">// index: 0-index</span>
        <span class="co">//update O(n log n) で効率が悪い. SegTreeでどうぞ.</span>
        sparse_table[<span class="dv">0</span>][index] = v;
        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">1</span>; k &lt; sparse_table.<span class="fu">length</span>; k++){
            <span class="dt">final</span> <span class="dt">int</span> begin = Math.<span class="fu">max</span>(<span class="dv">0</span>, index - (<span class="dv">1</span> &lt;&lt; k) + <span class="dv">1</span>);
            <span class="dt">final</span> <span class="dt">int</span> end = Math.<span class="fu">min</span>(sparse_table[k].<span class="fu">length</span>, index + (<span class="dv">1</span> &lt;&lt; k));
            <span class="co">// 最大で index + [-(1 &lt;&lt; k) + 1, (1 &lt;&lt; k)) の範囲を更新する必要がある</span>
            <span class="kw">for</span>(<span class="dt">int</span> i = begin; i &lt; end; i++){
                sparse_table[k][i] =
                        Math.<span class="fu">min</span>(sparse_table[k - <span class="dv">1</span>][i], sparse_table[k<span class="dv">-1</span>][i + (<span class="dv">1</span> &lt;&lt; (k - <span class="dv">1</span>))]);
            }
        }
    }

    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">query</span>(<span class="dt">int</span> l, <span class="dt">int</span> r){ <span class="co">// [l, r) O(log log n)</span>
        <span class="dt">final</span> <span class="dt">int</span> k = Integer.<span class="fu">numberOfTrailingZeros</span>(Integer.<span class="fu">highestOneBit</span>(r - l));
        <span class="co">// k -&gt; 区間をオーバーしない最大の2の冪乗</span>
        <span class="co">// left -&gt; [i, i + (1 &lt;&lt; k)), right -&gt; [r - (1 &lt;&lt; k)] (開区間なので±0)</span>
        <span class="kw">return</span> Math.<span class="fu">min</span>(sparse_table[k][l], sparse_table[k][r - (<span class="dv">1</span> &lt;&lt; k)]);
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>TODO</p>
<h2 id="RMNthQSegTree"><span class="header-section-number">2.11</span> n番目の最小値(SegmentTree)</h2>
<p>区間の n番目 に小さい値を効率的に求めるデータ構造. SegmentTree に部分列を突っ込んで二分探索している.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>update(k,v) : O(log n) ※単体への加算</p></li>
<li><p>min(s,t,n) : O(log^3 n) ※範囲<span>[</span>s,t)のn番目の最小値</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// SegmentTree(っぽい) 構造で範囲内のn番目の最小値を求める.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> RMNthQ {
    <span class="dt">int</span> n, depth;
    <span class="dt">long</span>[][] segs;

    <span class="kw">public</span> <span class="fu">RMNthQ</span>(<span class="dt">int</span> n_) {
        <span class="kw">this</span>.<span class="fu">n</span> = n_;
        <span class="kw">this</span>.<span class="fu">depth</span> = Integer.<span class="fu">numberOfTrailingZeros</span>(Integer.<span class="fu">highestOneBit</span>(n_)) + <span class="dv">2</span>;
        segs = <span class="kw">new</span> <span class="dt">long</span>[depth][n_];
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">merge</span>(<span class="dt">int</span> d, <span class="dt">int</span> begin, <span class="dt">int</span> middle, <span class="dt">int</span> end){
        <span class="kw">for</span>(<span class="dt">int</span> d_pos = begin, s1_pos = begin, s2_pos = middle; d_pos &lt; end; d_pos++){
            <span class="kw">if</span>(s1_pos &gt;= middle){ segs[d][d_pos] = segs[d + <span class="dv">1</span>][s2_pos++]; }
            <span class="kw">else</span> <span class="kw">if</span>(s2_pos &gt;= end) { segs[d][d_pos] = segs[d + <span class="dv">1</span>][s1_pos++]; }
            <span class="kw">else</span> <span class="kw">if</span>(segs[d + <span class="dv">1</span>][s1_pos] &lt;= segs[d + <span class="dv">1</span>][s2_pos]) {
                segs[d][d_pos] = segs[d + <span class="dv">1</span>][s1_pos++];
            }<span class="kw">else</span>{
                segs[d][d_pos] = segs[d + <span class="dv">1</span>][s2_pos++];
            }
        }
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">init</span>(<span class="dt">long</span>[] array){ <span class="co">// O( n log n)</span>
        System.<span class="fu">arraycopy</span>(array, <span class="dv">0</span>, segs[depth - <span class="dv">1</span>], <span class="dv">0</span>, n);
        <span class="kw">for</span>(<span class="dt">int</span> d = depth - <span class="dv">2</span>, size = <span class="dv">2</span>; d &gt;= <span class="dv">0</span>; d--, size *= <span class="dv">2</span>){
            <span class="kw">for</span>(<span class="dt">int</span> begin = <span class="dv">0</span>; begin &lt; <span class="kw">this</span>.<span class="fu">n</span>; begin += size){
                <span class="dt">final</span> <span class="dt">int</span> middle = begin + size / <span class="dv">2</span>;
                <span class="dt">final</span> <span class="dt">int</span> end = Math.<span class="fu">min</span>(begin + size, <span class="kw">this</span>.<span class="fu">n</span>);

                <span class="kw">this</span>.<span class="fu">merge</span>(d, begin, middle, end);
            }
        }
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">update</span>(<span class="dt">int</span> k, <span class="dt">long</span> a){ <span class="co">// 多分 O(n)</span>
        segs[depth - <span class="dv">1</span>][k] = a;
        <span class="kw">for</span>(<span class="dt">int</span> d = depth - <span class="dv">2</span>, size = <span class="dv">2</span>; d &gt;= <span class="dv">0</span>; d--, size *= <span class="dv">2</span>){
            <span class="dt">final</span> <span class="dt">int</span> begin = (k / size) * size, middle = begin + size / <span class="dv">2</span>;
            <span class="dt">final</span> <span class="dt">int</span> end  = Math.<span class="fu">min</span>(begin + size, <span class="kw">this</span>.<span class="fu">n</span>);

            <span class="kw">this</span>.<span class="fu">merge</span>(d, begin, middle, end);
        }
    }

    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">upper_bound</span>(<span class="dt">long</span>[] array, <span class="dt">long</span> key, <span class="dt">int</span> begin, <span class="dt">int</span> end){
        <span class="dt">int</span> lower = begin - <span class="dv">1</span>, upper = end;
        <span class="kw">while</span>(upper - lower &gt; <span class="dv">1</span>){
            <span class="dt">final</span> <span class="dt">int</span> mid = (lower + upper) / <span class="dv">2</span>;

            <span class="kw">if</span>(array[mid] &lt;= key){ lower = mid; } <span class="kw">else</span> { upper = mid;}
        }
        <span class="kw">return</span> upper;
    }

    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">query</span>(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">long</span> v, <span class="dt">int</span> d, <span class="dt">int</span> l, <span class="dt">int</span> r){ <span class="co">// O(log^2 n)</span>
        <span class="kw">if</span>(r &lt;= a || b &lt;= l){
            <span class="kw">return</span> <span class="dv">0</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){
            <span class="kw">return</span> (<span class="fu">upper_bound</span>(segs[d], v, l, r) - l);
        }<span class="kw">else</span> {
            <span class="dt">final</span> <span class="dt">int</span> size = <span class="dv">1</span> &lt;&lt; (depth - d - <span class="dv">1</span>);
            <span class="kw">return</span> <span class="fu">query</span>(a, b, v, d + <span class="dv">1</span>, l, l + size / <span class="dv">2</span>)
                    + <span class="fu">query</span>(a, b, v, d + <span class="dv">1</span>, l + size / <span class="dv">2</span>, Math.<span class="fu">min</span>(l + size, n));
        }
    }

    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">query</span>(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> nth){ <span class="co">// O(log^3 n)</span>
        <span class="dt">int</span> lower_index = -<span class="dv">1</span>, upper_index = <span class="kw">this</span>.<span class="fu">n</span>; <span class="co">//(l, u]</span>
        <span class="kw">while</span>(upper_index &gt; lower_index + <span class="dv">1</span>) {
            <span class="dt">final</span> <span class="dt">int</span> middle_index = (lower_index + upper_index) / <span class="dv">2</span>;
            <span class="dt">final</span> <span class="dt">int</span> ret = <span class="fu">query</span>(a, b, segs[<span class="dv">0</span>][middle_index], <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>);
            <span class="kw">if</span> (ret &lt; nth) { lower_index = middle_index; }
            <span class="kw">else</span> { upper_index = middle_index; }
        }
        <span class="kw">return</span> segs[<span class="dv">0</span>][upper_index];
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>TODO</p>
<h2 id="RMNthQWave"><span class="header-section-number">2.12</span> n番目の最小値(Waveletっぽい)</h2>
<p>区間の n番目 に小さい値を効率的に求めるデータ構造. こちらは minクエリを O(log n) でできる.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<ul>
<li><p>min(s,t,n) : O(log n) ※範囲<span>[</span>s,t)の番目の最小値</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// SegmentTree(っぽい) 構造で範囲内のn番目の最小値を求める.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> RMNthQ {
    <span class="dt">int</span> n, depth;
    <span class="dt">long</span>[][] segs;

    <span class="kw">public</span> <span class="fu">RMNthQ</span>(<span class="dt">int</span> n_) {
        <span class="kw">this</span>.<span class="fu">n</span> = n_;
        <span class="kw">this</span>.<span class="fu">depth</span> = Integer.<span class="fu">numberOfTrailingZeros</span>(Integer.<span class="fu">highestOneBit</span>(n_)) + <span class="dv">2</span>;
        segs = <span class="kw">new</span> <span class="dt">long</span>[depth][n_];
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">merge</span>(<span class="dt">int</span> d, <span class="dt">int</span> begin, <span class="dt">int</span> middle, <span class="dt">int</span> end){
        <span class="kw">for</span>(<span class="dt">int</span> d_pos = begin, s1_pos = begin, s2_pos = middle; d_pos &lt; end; d_pos++){
            <span class="kw">if</span>(s1_pos &gt;= middle){ segs[d][d_pos] = segs[d + <span class="dv">1</span>][s2_pos++]; }
            <span class="kw">else</span> <span class="kw">if</span>(s2_pos &gt;= end) { segs[d][d_pos] = segs[d + <span class="dv">1</span>][s1_pos++]; }
            <span class="kw">else</span> <span class="kw">if</span>(segs[d + <span class="dv">1</span>][s1_pos] &lt;= segs[d + <span class="dv">1</span>][s2_pos]) {
                segs[d][d_pos] = segs[d + <span class="dv">1</span>][s1_pos++];
            }<span class="kw">else</span>{
                segs[d][d_pos] = segs[d + <span class="dv">1</span>][s2_pos++];
            }
        }
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">init</span>(<span class="dt">long</span>[] array){ <span class="co">// O( n log n)</span>
        System.<span class="fu">arraycopy</span>(array, <span class="dv">0</span>, segs[depth - <span class="dv">1</span>], <span class="dv">0</span>, n);
        <span class="kw">for</span>(<span class="dt">int</span> d = depth - <span class="dv">2</span>, size = <span class="dv">2</span>; d &gt;= <span class="dv">0</span>; d--, size *= <span class="dv">2</span>){
            <span class="kw">for</span>(<span class="dt">int</span> begin = <span class="dv">0</span>; begin &lt; <span class="kw">this</span>.<span class="fu">n</span>; begin += size){
                <span class="dt">final</span> <span class="dt">int</span> middle = begin + size / <span class="dv">2</span>;
                <span class="dt">final</span> <span class="dt">int</span> end = Math.<span class="fu">min</span>(begin + size, <span class="kw">this</span>.<span class="fu">n</span>);

                <span class="kw">this</span>.<span class="fu">merge</span>(d, begin, middle, end);
            }
        }
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">update</span>(<span class="dt">int</span> k, <span class="dt">long</span> a){ <span class="co">// 多分 O(n)</span>
        segs[depth - <span class="dv">1</span>][k] = a;
        <span class="kw">for</span>(<span class="dt">int</span> d = depth - <span class="dv">2</span>, size = <span class="dv">2</span>; d &gt;= <span class="dv">0</span>; d--, size *= <span class="dv">2</span>){
            <span class="dt">final</span> <span class="dt">int</span> begin = (k / size) * size, middle = begin + size / <span class="dv">2</span>;
            <span class="dt">final</span> <span class="dt">int</span> end  = Math.<span class="fu">min</span>(begin + size, <span class="kw">this</span>.<span class="fu">n</span>);

            <span class="kw">this</span>.<span class="fu">merge</span>(d, begin, middle, end);
        }
    }

    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">upper_bound</span>(<span class="dt">long</span>[] array, <span class="dt">long</span> key, <span class="dt">int</span> begin, <span class="dt">int</span> end){
        <span class="dt">int</span> lower = begin - <span class="dv">1</span>, upper = end;
        <span class="kw">while</span>(upper - lower &gt; <span class="dv">1</span>){
            <span class="dt">final</span> <span class="dt">int</span> mid = (lower + upper) / <span class="dv">2</span>;

            <span class="kw">if</span>(array[mid] &lt;= key){ lower = mid; } <span class="kw">else</span> { upper = mid;}
        }
        <span class="kw">return</span> upper;
    }

    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">query</span>(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">long</span> v, <span class="dt">int</span> d, <span class="dt">int</span> l, <span class="dt">int</span> r){ <span class="co">// O(log^2 n)</span>
        <span class="kw">if</span>(r &lt;= a || b &lt;= l){
            <span class="kw">return</span> <span class="dv">0</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a &lt;= l &amp;&amp; r &lt;= b){
            <span class="kw">return</span> (<span class="fu">upper_bound</span>(segs[d], v, l, r) - l);
        }<span class="kw">else</span> {
            <span class="dt">final</span> <span class="dt">int</span> size = <span class="dv">1</span> &lt;&lt; (depth - d - <span class="dv">1</span>);
            <span class="kw">return</span> <span class="fu">query</span>(a, b, v, d + <span class="dv">1</span>, l, l + size / <span class="dv">2</span>)
                    + <span class="fu">query</span>(a, b, v, d + <span class="dv">1</span>, l + size / <span class="dv">2</span>, Math.<span class="fu">min</span>(l + size, n));
        }
    }

    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">query</span>(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> nth){ <span class="co">// O(log^3 n)</span>
        <span class="dt">int</span> lower_index = -<span class="dv">1</span>, upper_index = <span class="kw">this</span>.<span class="fu">n</span>; <span class="co">//(l, u]</span>
        <span class="kw">while</span>(upper_index &gt; lower_index + <span class="dv">1</span>) {
            <span class="dt">final</span> <span class="dt">int</span> middle_index = (lower_index + upper_index) / <span class="dv">2</span>;
            <span class="dt">final</span> <span class="dt">int</span> ret = <span class="fu">query</span>(a, b, segs[<span class="dv">0</span>][middle_index], <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>.<span class="fu">n</span>);
            <span class="kw">if</span> (ret &lt; nth) { lower_index = middle_index; }
            <span class="kw">else</span> { upper_index = middle_index; }
        }
        <span class="kw">return</span> segs[<span class="dv">0</span>][upper_index];
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>TODO</p>
<h1 id="graph"><span class="header-section-number">3</span> Graph</h1>
<h2 id="AdjMat"><span class="header-section-number">3.1</span> 隣接行列</h2>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// INF という値は適当に大きい値を突っ込んでおく.</span>
<span class="co">// 二つ足しても平気な Long.MAX_VALUE / 2 - 1 を良く使う.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span>[][] <span class="fu">init_adj</span>(<span class="dt">final</span> <span class="dt">int</span> n){
    <span class="dt">long</span>[][] ret = <span class="kw">new</span> <span class="dt">long</span>[n][n];
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++){
            ret[i][j] = i == j ? <span class="dv">0</span> : INF;
        }
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="AdjList"><span class="header-section-number">3.2</span> 隣接リスト</h2>
<h3 id="souce-code" class="unnumbered">Souce Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> ArrayList&lt;Map&lt;Integer, Long&gt;&gt; <span class="fu">init_adj</span>(<span class="dt">final</span> <span class="dt">int</span> n){
    ArrayList&lt;Map&lt;Integer, Long&gt;&gt; ret = <span class="kw">new</span> ArrayList&lt;Map&lt;Integer, Long&gt;&gt;();
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){
        ret.<span class="fu">add</span>(<span class="kw">new</span> LinkedHashMap&lt;Integer, Long&gt;());
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="FindCycle"><span class="header-section-number">3.3</span> 閉路検出</h2>
<p>閉路検出は, DFSの探索で探索中に二度探索する部分があるかで判定する.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">int</span> unvisited = <span class="dv">0</span>, visiting = <span class="dv">1</span>, visited = <span class="dv">2</span>;

<span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">dfs</span>(<span class="dt">int</span> node, <span class="dt">boolean</span>[][] adj, <span class="dt">int</span>[] state){
    state[node] = visiting;

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; adj.<span class="fu">length</span>; i++){
        <span class="kw">if</span>(!adj[node][i]){ <span class="kw">continue</span>; }
        <span class="kw">else</span> <span class="kw">if</span>(state[i] == unvisited){
            <span class="kw">if</span>(!<span class="fu">dfs</span>(i, adj, state)){ <span class="co">//</span>
                state[node] = visited; <span class="kw">return</span> <span class="kw">false</span>;
            }
        }<span class="kw">else</span> <span class="kw">if</span>(state[i] == visiting){ <span class="co">//cycle!</span>
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }

    state[node] = visited;
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">find_cycle</span>(<span class="dt">boolean</span>[][] adj){
    <span class="dt">int</span>[] state = <span class="kw">new</span> <span class="dt">int</span>[adj.<span class="fu">length</span>];
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; adj.<span class="fu">length</span>; i++){
        state[i] = unvisited;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; adj.<span class="fu">length</span>; i++){
        <span class="kw">if</span>(state[i] == unvisited){
            <span class="kw">if</span>(!<span class="fu">dfs</span>(i, adj, state)){
                <span class="kw">return</span> <span class="kw">false</span>;
            }
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="TopologicalSort"><span class="header-section-number">3.4</span> トポロジカルソート</h2>
<p>閉路検出は, DFSの探索で帰りがけ順に見れば良い. 閉路がなければトポロジカルソートできる.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">int</span> unvisited = <span class="dv">0</span>, visiting = <span class="dv">1</span>, visited = <span class="dv">2</span>;

<span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">dfs</span>(<span class="dt">int</span> node, <span class="dt">boolean</span>[][] adj, <span class="dt">int</span>[] state, LinkedList&lt;Integer&gt; list){
    state[node] = visiting;

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; adj.<span class="fu">length</span>; i++){
        <span class="kw">if</span>(!adj[node][i]){ <span class="kw">continue</span>; }
        <span class="kw">else</span> <span class="kw">if</span>(state[i] == unvisited){
            <span class="kw">if</span>(!<span class="fu">dfs</span>(i, adj, state, list)){ <span class="co">//</span>
                state[node] = visited; <span class="kw">return</span> <span class="kw">false</span>;
            }
        }<span class="kw">else</span> <span class="kw">if</span>(state[i] == visiting){ <span class="co">//cycle!</span>
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }

    state[node] = visited;
    list.<span class="fu">addFirst</span>(node);
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">topological_sort</span>(<span class="dt">boolean</span>[][] adj, LinkedList&lt;Integer&gt; list){
    <span class="dt">int</span>[] state = <span class="kw">new</span> <span class="dt">int</span>[adj.<span class="fu">length</span>];
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; adj.<span class="fu">length</span>; i++){
        state[i] = unvisited;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; adj.<span class="fu">length</span>; i++){
        <span class="kw">if</span>(state[i] == unvisited){
            <span class="kw">if</span>(!<span class="fu">dfs</span>(i, adj, state, list)){
                <span class="kw">return</span> <span class="kw">false</span>;
            }
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="WarshallFloydPathRestore"><span class="header-section-number">3.5</span> ワーシャルフロイド(パス復元)</h2>
<p>全対最短路をO(n^3)で求めるアルゴリズム.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p>O(n^3)</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// next[i][j] := i -&gt; j へ行く際に, 次に通過する点</span>
<span class="co">// for(int cur = start; cur != goal; cur = next[cur][goal]) と順番に辿れる.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span>[][] <span class="fu">warshallFloyd</span>(<span class="dt">long</span>[][] adj){ <span class="co">// adj に全対最短路が入る.</span>
    <span class="dt">final</span> <span class="dt">int</span> n = adj.<span class="fu">length</span>;

    <span class="dt">int</span>[][] next = <span class="kw">new</span> <span class="dt">int</span>[n][n];
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++){
            next[i][j] = j;
        }
    }

    <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k++){
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++){
                <span class="kw">if</span>(adj[i][j] &lt; adj[i][k] + adj[k][j]){
                    adj[i][j] = adj[i][k] + adj[k][j];
                    next[i][j] = next[i][k];
                }
            }
        }
    }

    <span class="kw">return</span> next;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="WarshallFloyd"><span class="header-section-number">3.6</span> SCC(WarshallFloyd)</h2>
<p>O(n^3)でSCCを求めるアルゴリズム.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p>O(n^3)</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// WarshallFloyd して adj[i][j] != INF &amp;&amp; adj[j][i] != INF なら同じ成分.</span>
<span class="kw">public</span> <span class="dt">static</span> ArrayList&lt;Set&lt;Integer&gt;&gt; <span class="fu">StrongConnectedComponents</span>(<span class="dt">long</span>[][] adj){
    <span class="dt">final</span> <span class="dt">int</span> n = adj.<span class="fu">length</span>;

    <span class="dt">long</span>[][] wf_adj = <span class="fu">warshallFloyd</span>(adj);
    ArrayList&lt;Set&lt;Integer&gt;&gt; sets = <span class="kw">new</span> ArrayList&lt;Set&lt;Integer&gt;&gt;();
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){
        Set&lt;Integer&gt; set = <span class="kw">new</span> HashSet&lt;Integer&gt;();
        set.<span class="fu">add</span>(i);

        sets.<span class="fu">add</span>(set);
    }

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++){
            <span class="kw">if</span>(adj[i][j] != INF &amp;&amp; adj[j][i] != INF){
                sets.<span class="fu">get</span>(i).<span class="fu">add</span>(j);
                sets.<span class="fu">get</span>(j).<span class="fu">add</span>(i);
            }
        }
    }

    <span class="kw">return</span> sets;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="MinimumSteinerTree"><span class="header-section-number">3.7</span> 最小シュタイナー木</h2>
<p>最小シュタイナー木を求めるアルゴリズム.</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// adj -&gt; 隣接行列, ts -&gt; 木に含まれてほしい木</span>
<span class="co">// 戻り値が INF以上なら, 要求を満たすシュタイナー木は存在しない.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">minimumSteinerTree</span>(<span class="dt">long</span>[][] adj, <span class="dt">int</span>[] ts){
    <span class="dt">final</span> <span class="dt">int</span> n = adj.<span class="fu">length</span>;
    <span class="dt">final</span> <span class="dt">int</span> m = ts.<span class="fu">length</span>;

    <span class="co">// メモリが勿体無い場合は ワーシャルフロイドの結果を adj に入れる.</span>
    <span class="dt">long</span>[][] all_pair = <span class="fu">warshallFloyd</span>(adj); <span class="co">//O(n^3)</span>
    <span class="dt">long</span>[][] DP = <span class="kw">new</span> <span class="dt">long</span>[<span class="dv">1</span> &lt;&lt; m][n];

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++){
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++){
            DP[<span class="dv">1</span> &lt;&lt; i][j] = all_pair[ts[i]][j];
        }
    }

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; (<span class="dv">1</span> &lt;&lt; m); i++){ <span class="co">// O(2^t)</span>
        <span class="kw">if</span>(Integer.<span class="fu">bitCount</span>(i) == <span class="dv">1</span>){ <span class="kw">continue</span>; } <span class="co">// ペア作れないのはNG</span>

        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++){ <span class="co">// O(n)</span>
            DP[i][j] = INF;
            <span class="co">// i と 0 以外の部分集合を列挙して, ペアで行ける場所の最小値を求める..</span>
            <span class="kw">for</span>(<span class="dt">int</span> k = (i - <span class="dv">1</span>) &amp; i; k &gt; <span class="dv">0</span>; k = (k - <span class="dv">1</span>) &amp; i){
                DP[i][j] = Math.<span class="fu">min</span>(DP[i][j], DP[k][j] + DP[i ^ k][j]);
            } <span class="co">// DP[i][駅] は, iのシュタイナー木を作るコストが入る. (足し算してるから)</span>
        }
        <span class="co">// このままだと, 辺を重複してカウントするので, ワーシャルして排除.</span>
        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k++) {
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) {
                DP[i][j] = Math.<span class="fu">min</span>(DP[i][j], DP[i][k] + all_pair[k][j]);
            }
        }
    }

    <span class="dt">long</span> ret = Long.<span class="fu">MAX_VALUE</span>;
    <span class="kw">for</span>(<span class="dt">final</span> <span class="dt">int</span> t : ts){ ret = Math.<span class="fu">min</span>(ret, DP[(<span class="dv">1</span> &lt;&lt; m) - <span class="dv">1</span>][t]); }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="OfflineLCA"><span class="header-section-number">3.8</span> オフライン最小共通先祖</h2>
<p>クエリに対してまとめて最小共通祖先を求める. 計算量はだいたい O(Ea(V)).</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// DFS で 前順走査(preorder) で 一番近い親を探す. 部分木のマージに, UnionFind を使う .</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">dfs</span>(<span class="dt">int</span>[] us, <span class="dt">int</span>[] vs, <span class="dt">int</span>[] lcas, <span class="dt">int</span> node, <span class="dt">int</span> parent,
                       <span class="dt">boolean</span>[] visited, <span class="dt">int</span>[] ancestor, <span class="dt">boolean</span>[][] adj, UnionFind uf){
    ancestor[uf.<span class="fu">find</span>(node)] = node; <span class="co">// 自分の祖先は自分.</span>
    <span class="kw">for</span>(<span class="dt">int</span> next = <span class="dv">0</span>; next &lt; adj.<span class="fu">length</span>; next++){
        <span class="kw">if</span>(next == parent){ <span class="kw">continue</span>; }
        <span class="kw">if</span>(!adj[node][next]){ <span class="kw">continue</span>; }

        <span class="fu">dfs</span>(us, vs, lcas, next, node, visited, ancestor, adj, uf);
        uf.<span class="fu">union</span>(node, next); <span class="co">// next以下のLCAを探索し終えたので, 部分木を併合.</span>
        ancestor[uf.<span class="fu">find</span>(node)] = node; <span class="co">// 併合した祖先は自分(部分木内はもう終えてる)</span>
    }

    visited[node] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; us.<span class="fu">length</span>; i++){
        <span class="dt">int</span> not_node = -<span class="dv">1</span>; <span class="co">// 片方が自分だった時のもう片方が欲しい</span>
        <span class="kw">if</span>(us[i] == node){ not_node = vs[i]; }
        <span class="kw">else</span> <span class="kw">if</span>(vs[i] == node){ not_node = us[i]; }

        <span class="kw">if</span>(not_node &gt;= <span class="dv">0</span> &amp;&amp; visited[not_node]){ <span class="co">// 両方とも評価済みかのチェック</span>
            lcas[i] = ancestor[uf.<span class="fu">find</span>(not_node)]; <span class="co">// 両方とも評価済みの場合は一度しかない.</span>
        }
    }
}

<span class="co">//</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span>[] <span class="fu">offlineLCA</span>(<span class="dt">int</span>[] us, <span class="dt">int</span>[] vs, <span class="dt">boolean</span>[][] adj){
    <span class="dt">final</span> <span class="dt">int</span> n = adj.<span class="fu">length</span>;
    <span class="dt">int</span>[] lca_nodes = <span class="kw">new</span> <span class="dt">int</span>[us.<span class="fu">length</span>], ancestor = <span class="kw">new</span> <span class="dt">int</span>[n];
    <span class="dt">boolean</span>[] visited = <span class="kw">new</span> <span class="dt">boolean</span>[n];
    UnionFind uf = <span class="kw">new</span> <span class="fu">UnionFind</span>(n);

    <span class="fu">dfs</span>(us, vs, lca_nodes, <span class="dv">0</span>, -<span class="dv">1</span>, visited, ancestor, adj, uf);
    <span class="kw">return</span> lca_nodes;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="MinimumCutStoerWagner"><span class="header-section-number">3.9</span> 全域最小カット</h2>
<p>無向グラフ全体を2つに切る際の辺を切るコストの最小コストを求める. O(N^3)</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">minimumCut</span>(<span class="dt">final</span> <span class="dt">int</span> n, <span class="dt">long</span>[][] adj){
    ArrayList&lt;Integer&gt; uf = <span class="kw">new</span> ArrayList&lt;Integer&gt;();
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){
        uf.<span class="fu">add</span>(i);
    }
    Set&lt;Integer&gt; set = <span class="kw">new</span> HashSet&lt;Integer&gt;(), ret = <span class="kw">null</span>;

    <span class="dt">long</span> cut = Long.<span class="fu">MAX_VALUE</span>;
    <span class="kw">for</span>(<span class="dt">int</span> m = n; m &gt; <span class="dv">1</span>; m--){
        <span class="dt">long</span>[] ws = <span class="kw">new</span> <span class="dt">long</span>[m];
        <span class="dt">int</span> u = <span class="dv">0</span>, v = <span class="dv">0</span>;
        <span class="dt">long</span> w = <span class="dv">0</span>;

        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; m; k++){
            u = v;

            v = <span class="dv">0</span>;
            {
                <span class="dt">long</span> tmp_max = ws[<span class="dv">0</span>];
                <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; m; i++){
                    <span class="kw">if</span>(tmp_max &lt; ws[i]){
                        tmp_max = ws[i];
                        v = i;
                    }
                }
            }

            w = ws[v];
            ws[v] = -<span class="dv">1</span>;

            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++){
                <span class="kw">if</span>(ws[i] &gt;= <span class="dv">0</span>){
                    ws[i] += adj[uf.<span class="fu">get</span>(v)][uf.<span class="fu">get</span>(i)];
                }
            }
        }

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++){
            adj[uf.<span class="fu">get</span>(i)][uf.<span class="fu">get</span>(u)] += adj[uf.<span class="fu">get</span>(i)][uf.<span class="fu">get</span>(v)];
            adj[uf.<span class="fu">get</span>(u)][uf.<span class="fu">get</span>(i)] += adj[uf.<span class="fu">get</span>(v)][uf.<span class="fu">get</span>(i)];
        }

        set.<span class="fu">add</span>(uf.<span class="fu">get</span>(v));
        <span class="kw">if</span>(cut &gt; w){
            cut = w;
            ret = <span class="kw">new</span> HashSet&lt;Integer&gt;(set);
        }

        uf.<span class="fu">remove</span>(v);
    }

    <span class="kw">return</span> cut;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h1 id="math"><span class="header-section-number">4</span> Math</h1>
<h2 id="GCDux5fANDux5fLCM"><span class="header-section-number">4.1</span> GCD, LCM</h2>
<p>基本的な算術用の関数. いつもお世話になる.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p>軽い. O(log b) くらい</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">gcd</span>(<span class="dt">long</span> a, <span class="dt">long</span> b){
    <span class="kw">return</span> b == <span class="dv">0</span> ? a : <span class="fu">gcd</span>(b, a % b);
}
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">lcm</span>(<span class="dt">long</span> a, <span class="dt">long</span> b){
    <span class="kw">return</span> a / <span class="fu">gcd</span>(a, b) * b;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="nextpermutation"><span class="header-section-number">4.2</span> nextPermutation</h2>
<p>順列に対して次の順列を返す. C++ にもある便利な関数.</p>
<h3 id="source-code-1" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// 任意の Comparable&lt;T&gt; を実装したクラスに対する next_permutation</span>
<span class="fu">@SafeVarargs</span>
<span class="kw">public</span> <span class="dt">static</span> &lt;T <span class="kw">extends</span> Comparable&lt;? <span class="kw">super</span> T&gt;&gt; <span class="dt">boolean</span> <span class="fu">next_permutation</span>(T <span class="kw">... </span>perm) {
    <span class="kw">for</span>(<span class="dt">int</span> i = perm.<span class="fu">length</span> - <span class="dv">1</span>; i &gt; <span class="dv">0</span>; i--){
        <span class="kw">if</span>(perm[i - <span class="dv">1</span>].<span class="fu">compareTo</span>(perm[i]) &lt; <span class="dv">0</span>){
            <span class="dt">int</span> j = perm.<span class="fu">length</span>;
            <span class="kw">while</span>(perm[i - <span class="dv">1</span>].<span class="fu">compareTo</span>(perm[--j]) &gt;= <span class="dv">0</span>);

            <span class="fu">swap</span>(perm, i - <span class="dv">1</span>, j);
            <span class="fu">reverse</span>(perm, i, perm.<span class="fu">length</span>); <span class="co">// [i, n)</span>

            <span class="kw">return</span> <span class="kw">true</span>;
        }
    }

    <span class="fu">reverse</span>(perm, <span class="dv">0</span>, perm.<span class="fu">length</span>); <span class="co">// [0, n)</span>
    <span class="kw">return</span> <span class="kw">false</span>;
}</code></pre></div>
<h2 id="Rational"><span class="header-section-number">4.3</span> 有理数</h2>
<p>有理数を表現するクラス. longなのでintの範囲では誤差無しとして扱える.</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// equalsメソッドは eclipse等で生成するなりして作ること</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> Rational <span class="kw">implements</span> Comparable&lt;Rational&gt; {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> Rational ZERO = <span class="kw">new</span> <span class="fu">Rational</span>(<span class="dv">0</span>);
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> Rational ONE  = <span class="kw">new</span> <span class="fu">Rational</span>(<span class="dv">1</span>);
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> Rational NaN  = <span class="kw">new</span> <span class="fu">Rational</span>(<span class="dv">1</span>, <span class="dv">0</span>){
        <span class="kw">public</span> String <span class="fu">toString</span>(){ <span class="kw">return</span> <span class="st">&quot;NaN&quot;</span>; }};

    <span class="kw">private</span> <span class="dt">long</span> nom, denom;

    <span class="kw">public</span> <span class="fu">Rational</span>(<span class="dt">long</span> nom, <span class="dt">long</span> denom) {
        <span class="kw">if</span>(nom == <span class="dv">0</span>){ <span class="kw">this</span>.<span class="fu">nom</span> = <span class="dv">0</span>; <span class="kw">this</span>.<span class="fu">denom</span> = <span class="dv">1</span>; }
        <span class="kw">else</span>{ <span class="dt">final</span> <span class="dt">long</span> gcd = <span class="fu">inner_gcd</span>(nom, denom);
            <span class="kw">this</span>.<span class="fu">nom</span> = nom / gcd; <span class="kw">this</span>.<span class="fu">denom</span> = denom / gcd;
            <span class="kw">if</span>(<span class="kw">this</span>.<span class="fu">nom</span> * <span class="kw">this</span>.<span class="fu">denom</span> &lt; <span class="dv">0</span>){
                <span class="kw">this</span>.<span class="fu">nom</span> = -Math.<span class="fu">abs</span>(<span class="kw">this</span>.<span class="fu">nom</span>);
                <span class="kw">this</span>.<span class="fu">denom</span> = Math.<span class="fu">abs</span>(<span class="kw">this</span>.<span class="fu">denom</span>);
            }}}
    <span class="kw">public</span> <span class="fu">Rational</span>(<span class="dt">long</span> num) { <span class="kw">this</span>(num, <span class="dv">1</span>); }
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">get_nom</span>(){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">nom</span>; }
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">get_denom</span>(){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">denom</span>; }
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">inner_gcd</span>(<span class="dt">long</span> a, <span class="dt">long</span> b){
        <span class="kw">return</span> b == <span class="dv">0</span> ? a : <span class="fu">inner_gcd</span>(b, a % b); }
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">inner_lcm</span>(<span class="dt">long</span> a, <span class="dt">long</span> b){
        <span class="kw">return</span> a / <span class="fu">inner_gcd</span>(a, b) * b; }
    <span class="kw">public</span> Rational <span class="fu">minus</span>(){ <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Rational</span>(-<span class="kw">this</span>.<span class="fu">nom</span>, <span class="kw">this</span>.<span class="fu">denom</span>); }
    <span class="kw">public</span> Rational <span class="fu">inv</span>(){ <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Rational</span>(<span class="kw">this</span>.<span class="fu">denom</span>, <span class="kw">this</span>.<span class="fu">nom</span>); }
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">sign</span>(){
        <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">nom</span> ==<span class="dv">0</span> ? <span class="dv">0</span> : <span class="fu">inner_lcm</span>(<span class="kw">this</span>.<span class="fu">nom</span>,<span class="kw">this</span>.<span class="fu">denom</span>) &lt; <span class="dv">0</span> ?-<span class="dv">1</span>:<span class="dv">1</span>;}
    <span class="kw">public</span> Rational <span class="fu">abs</span>(){
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Rational</span>(Math.<span class="fu">abs</span>(<span class="kw">this</span>.<span class="fu">nom</span>), Math.<span class="fu">abs</span>(<span class="kw">this</span>.<span class="fu">denom</span>));}

    <span class="kw">public</span> Rational <span class="fu">add</span>(Rational o){
        <span class="dt">final</span> <span class="dt">long</span> lcm = <span class="fu">inner_lcm</span>(<span class="kw">this</span>.<span class="fu">denom</span>, o.<span class="fu">denom</span>);
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Rational</span>(lcm/<span class="kw">this</span>.<span class="fu">denom</span>*<span class="kw">this</span>.<span class="fu">nom</span> + lcm/o.<span class="fu">denom</span>*o.<span class="fu">nom</span>,lcm);}
    <span class="kw">public</span> Rational <span class="fu">sub</span>(Rational o){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">add</span>(o.<span class="fu">minus</span>()); }
    <span class="kw">public</span> Rational <span class="fu">mul</span>(Rational o){ <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Rational</span>(<span class="kw">this</span>.<span class="fu">nom</span> * o.<span class="fu">nom</span>, <span class="kw">this</span>.<span class="fu">denom</span> * o.<span class="fu">denom</span>); }
    <span class="kw">public</span> Rational <span class="fu">div</span>(Rational o){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">mul</span>(o.<span class="fu">inv</span>()); }
    <span class="kw">public</span> Rational <span class="fu">gcd</span>(Rational o){
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Rational</span>(<span class="fu">inner_gcd</span>(<span class="kw">this</span>.<span class="fu">nom</span>, o.<span class="fu">nom</span>), <span class="fu">inner_lcm</span>(<span class="kw">this</span>.<span class="fu">denom</span>, o.<span class="fu">denom</span>)); }
    <span class="kw">public</span> Rational <span class="fu">lcm</span>(Rational o){
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Rational</span>(<span class="fu">inner_lcm</span>(<span class="kw">this</span>.<span class="fu">nom</span>, o.<span class="fu">nom</span>), <span class="fu">inner_gcd</span>(<span class="kw">this</span>.<span class="fu">denom</span>, o.<span class="fu">denom</span>)); }
    <span class="kw">public</span> Rational <span class="fu">pow</span>(<span class="dt">long</span> p){
        <span class="kw">if</span>(p == <span class="dv">0</span>){ <span class="kw">return</span> Rational.<span class="fu">ONE</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(p % <span class="dv">2</span> != <span class="dv">0</span>){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">mul</span>(<span class="fu">pow</span>(p - <span class="dv">1</span>));
        }<span class="kw">else</span>{ Rational ret = <span class="fu">pow</span>(p / <span class="dv">2</span>); <span class="kw">return</span> ret.<span class="fu">mul</span>(ret); }}

    <span class="fu">@Override</span>
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span>(Rational o){
        <span class="dt">final</span> <span class="dt">long</span> det = <span class="kw">this</span>.<span class="fu">nom</span> * o.<span class="fu">denom</span> - <span class="kw">this</span>.<span class="fu">denom</span> * o.<span class="fu">nom</span>;
        <span class="kw">if</span>(det &lt; <span class="dv">0</span>){ <span class="kw">return</span> -<span class="dv">1</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(det &gt; <span class="dv">0</span>){ <span class="kw">return</span> <span class="dv">1</span>;
        }<span class="kw">else</span>{ <span class="kw">return</span> <span class="dv">0</span>; }}
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<ul>
<li><p><a href="http://maximum-cup-2013.contest.atcoder.jp/tasks/maximum_2013_c">Maximum-Cup 2013 (C - 白蛇のお守り)</a></p></li>
</ul>
<h2 id="BigRational"><span class="header-section-number">4.4</span> 有理数</h2>
<p>多倍長整数で有理数を表現する.</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// import java.math.BigInteger;</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> BigRational <span class="kw">implements</span> Comparable&lt;BigRational&gt;{
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> BigRational ZERO = <span class="kw">new</span> <span class="fu">BigRational</span>(<span class="dv">0</span>, <span class="dv">1</span>);
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> BigRational ONE  = <span class="kw">new</span> <span class="fu">BigRational</span>(<span class="dv">1</span>, <span class="dv">1</span>);
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> BigRational NaN  = <span class="kw">new</span> <span class="fu">BigRational</span>(<span class="dv">1</span>, <span class="dv">0</span>);

    <span class="kw">public</span> <span class="dt">final</span> BigInteger nom, denom;

    <span class="kw">public</span> <span class="fu">BigRational</span>(BigInteger nom, BigInteger denom){
        <span class="kw">this</span>.<span class="fu">nom</span> = <span class="fu">calc_nom</span>(nom,denom); <span class="kw">this</span>.<span class="fu">denom</span> = <span class="fu">calc_denom</span>(nom,denom); }

    <span class="kw">public</span> <span class="fu">BigRational</span>(BigInteger nom){ <span class="kw">this</span>(nom, BigInteger.<span class="fu">valueOf</span>(<span class="dv">1</span>)); }
    <span class="kw">public</span> <span class="fu">BigRational</span>(<span class="dt">long</span> nom, <span class="dt">long</span> denom){
        <span class="kw">this</span>(BigInteger.<span class="fu">valueOf</span>(nom), BigInteger.<span class="fu">valueOf</span>(denom)); }
    <span class="kw">public</span> <span class="fu">BigRational</span>(<span class="dt">long</span> nom){ <span class="kw">this</span>(nom, <span class="dv">1</span>); }

    <span class="kw">private</span> <span class="dt">static</span> BigInteger <span class="fu">inner_gcd</span>(BigInteger a, BigInteger b){
        <span class="kw">return</span> b.<span class="fu">equals</span>(BigInteger.<span class="fu">ZERO</span>) ? a : <span class="fu">inner_gcd</span>(b, a.<span class="fu">remainder</span>(b));
    }
    <span class="kw">private</span> <span class="dt">static</span> BigInteger <span class="fu">inner_lcm</span>(BigInteger a, BigInteger b){
        <span class="kw">return</span> a.<span class="fu">multiply</span>(b).<span class="fu">divide</span>(a.<span class="fu">gcd</span>(b));}

    <span class="kw">private</span> <span class="dt">static</span> BigInteger <span class="fu">calc_nom</span>(BigInteger nom, BigInteger denom){
        nom = nom.<span class="fu">divide</span>(nom.<span class="fu">gcd</span>(denom));
        <span class="kw">if</span>(nom.<span class="fu">signum</span>() * denom.<span class="fu">signum</span>() &lt; <span class="dv">0</span>){ nom = nom.<span class="fu">abs</span>().<span class="fu">negate</span>(); }
        <span class="kw">return</span> nom; }
    <span class="kw">private</span> <span class="dt">static</span> BigInteger <span class="fu">calc_denom</span>(BigInteger nom, BigInteger denom){
        denom = denom.<span class="fu">divide</span>(nom.<span class="fu">gcd</span>(denom));
        <span class="kw">if</span>(nom.<span class="fu">equals</span>(BigInteger.<span class="fu">ZERO</span>)) { <span class="kw">return</span> BigInteger.<span class="fu">ONE</span>; }
        <span class="kw">if</span>(nom.<span class="fu">signum</span>() * denom.<span class="fu">signum</span>() &lt; <span class="dv">0</span>){ denom = denom.<span class="fu">abs</span>(); }
        <span class="kw">return</span> denom; }

    <span class="kw">public</span> BigRational <span class="fu">minus</span>(){ <span class="kw">return</span> <span class="kw">new</span> <span class="fu">BigRational</span>(nom.<span class="fu">negate</span>(), denom); }
    <span class="kw">public</span> BigRational <span class="fu">inv</span>()  { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">BigRational</span>(denom, nom); }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">sign</span>() { <span class="kw">return</span> nom.<span class="fu">signum</span>(); }
    <span class="kw">public</span> BigRational <span class="fu">abs</span>()  { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">BigRational</span>(nom.<span class="fu">abs</span>(), denom); }
    <span class="kw">public</span> BigRational <span class="fu">add</span>(BigRational o)  {
        <span class="dt">final</span> BigInteger lcm = <span class="fu">inner_lcm</span>(<span class="kw">this</span>.<span class="fu">denom</span>, o.<span class="fu">denom</span>);
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">BigRational</span>(lcm.<span class="fu">divide</span>(<span class="kw">this</span>.<span class="fu">denom</span>).<span class="fu">multiply</span>(<span class="kw">this</span>.<span class="fu">nom</span>)
                .<span class="fu">add</span>(lcm.<span class="fu">divide</span>(o.<span class="fu">denom</span>).<span class="fu">multiply</span>(o.<span class="fu">nom</span>)), denom); }
    <span class="kw">public</span> BigRational <span class="fu">sub</span>(BigRational o){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">add</span>(o.<span class="fu">minus</span>()); }
    <span class="kw">public</span> BigRational <span class="fu">mul</span>(BigRational o){
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">BigRational</span>(<span class="kw">this</span>.<span class="fu">nom</span>.<span class="fu">multiply</span>(o.<span class="fu">nom</span>), <span class="kw">this</span>.<span class="fu">denom</span>.<span class="fu">multiply</span>(o.<span class="fu">denom</span>)); }
    <span class="kw">public</span> BigRational <span class="fu">div</span>(BigRational o){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">mul</span>(o.<span class="fu">inv</span>()); }
    <span class="kw">public</span> BigRational <span class="fu">gcd</span>(BigRational o){
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">BigRational</span>(<span class="fu">inner_gcd</span>(<span class="kw">this</span>.<span class="fu">nom</span>, o.<span class="fu">nom</span>), <span class="kw">this</span>.<span class="fu">denom</span>.<span class="fu">divide</span>(<span class="kw">this</span>.<span class="fu">denom</span>.<span class="fu">gcd</span>(o.<span class="fu">denom</span>)).<span class="fu">multiply</span>(o.<span class="fu">denom</span>)); }
    <span class="kw">public</span> BigRational <span class="fu">lcm</span>(BigRational o){
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">BigRational</span>(<span class="fu">inner_lcm</span>(<span class="kw">this</span>.<span class="fu">nom</span>, o.<span class="fu">nom</span>), <span class="kw">this</span>.<span class="fu">denom</span>.<span class="fu">gcd</span>(o.<span class="fu">denom</span>)); }
    <span class="kw">public</span> BigRational <span class="fu">pow</span>(<span class="dt">int</span> p){ <span class="kw">return</span> <span class="kw">new</span> <span class="fu">BigRational</span>(nom.<span class="fu">pow</span>(p), denom.<span class="fu">pow</span>(p)); }

    <span class="fu">@Override</span>
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span>(BigRational arg0){
        <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">nom</span>.<span class="fu">multiply</span>(arg0.<span class="fu">denom</span>).<span class="fu">compareTo</span>(<span class="kw">this</span>.<span class="fu">denom</span>.<span class="fu">multiply</span>(arg0.<span class="fu">nom</span>)); }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<ul>
<li><p><a href="http://maximum-cup-2013.contest.atcoder.jp/tasks/maximum_2013_c">Maximum-Cup 2013 (C - 白蛇のお守り)</a></p></li>
</ul>
<h1 id="mod"><span class="header-section-number">5</span> Mod</h1>
<h2 id="BinaryPowerMethodMOD"><span class="header-section-number">5.1</span> 累乗 (mod m)</h2>
<p>累乗 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>e</mi></msup><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.222em"></mspace><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^e \: (mod \: m)</annotation></semantics></math> に関しては, バイナリ法で高速に計算できる.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mspace width="0.222em"></mspace><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(log \: e)</annotation></semantics></math> ※log(指数)オーダー</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<p>再帰関数で計算するコードはこちら.</p>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">mod_pow</span>(<span class="dt">long</span> a, <span class="dt">long</span> e, <span class="dt">long</span> m){
    <span class="kw">if</span>(e == <span class="dv">0</span>){
        <span class="kw">return</span> <span class="dv">1</span>;
    }<span class="kw">else</span> <span class="kw">if</span>(e % <span class="dv">2</span> == <span class="dv">0</span>){
        <span class="dt">long</span> ret = <span class="fu">mod_pow</span>(a, e / <span class="dv">2</span>, m);
        <span class="kw">return</span> (ret * ret) % m;
    }<span class="kw">else</span>{
        <span class="kw">return</span> (<span class="fu">mod_pow</span>(a, e - <span class="dv">1</span>, m) * a) % m;
    }
}</code></pre></div>
<p>ループで下位のケタから計算するコードはこちら.</p>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">mod_pow</span>(<span class="dt">long</span> a, <span class="dt">long</span> e, <span class="dt">long</span> m){
    <span class="dt">long</span> ret = <span class="dv">1</span>;
    <span class="kw">for</span>(; e &gt; <span class="dv">0</span>; e /= <span class="dv">2</span>){
        <span class="kw">if</span> (e % <span class="dv">2</span> != <span class="dv">0</span>) ret = (ret * a) % m;
        a = (a * a) % m;
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>する予定</p>
<h2 id="InvModP"><span class="header-section-number">5.2</span> 逆元 (mod p)</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.222em"></mspace><mi>p</mi></mrow><annotation encoding="application/x-tex">mod \: p</annotation></semantics></math> での逆元は, フェルマーの小定理より, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>a</mi><mrow><mspace width="0.222em"></mspace><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.222em"></mspace><mi>p</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^{-1} = a^{\: p-2} \: (mod \: p)</annotation></semantics></math></p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mspace width="0.222em"></mspace><mi>p</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(log \: p)</annotation></semantics></math> ※累乗にバイナリ法が使える</p>
<h3 id="ux4f9dux5b58"><span class="header-section-number">5.2.1</span> 依存</h3>
<ul>
<li><p><a href="./library-sc.html#BinaryPowerMethodMOD">累乗 (mod m) </a></p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">mod_inv</span>(<span class="dt">long</span> a, <span class="dt">long</span> p){
    <span class="kw">return</span> <span class="fu">mod_pow</span>(a, p - <span class="dv">2</span>, p);
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>する予定</p>
<h2 id="EnumInvModP"><span class="header-section-number">5.3</span> 逆元列挙 (mod p)</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.222em"></mspace><mi>p</mi></mrow><annotation encoding="application/x-tex">mod \: p</annotation></semantics></math> の逆元は1からNまで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math>で計算できる.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math> ※列挙する最大の数</p>
<h3 id="source-code-1" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// 返戻値(inv[1] ... inv[N]) にそれぞれの mod P での逆元が入る</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span>[] <span class="fu">mod_inv</span>(<span class="dt">int</span> N, <span class="dt">long</span> p){
    <span class="dt">long</span>[] inv = <span class="kw">new</span> <span class="dt">long</span>[N + <span class="dv">1</span>];
    inv[<span class="dv">1</span>] = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= N; i++){
        inv[i] = p - (p / i) * inv[(<span class="dt">int</span>)(p % i)] % p;
    }
    <span class="kw">return</span> inv;
}</code></pre></div>
<h3 id="verified-1" class="unnumbered">Verified</h3>
<p>する予定</p>
<h2 id="InvModM"><span class="header-section-number">5.4</span> 逆元 (mod m)</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.222em"></mspace><mi>m</mi></mrow><annotation encoding="application/x-tex">mod \: m</annotation></semantics></math> での逆元は, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が互いに素であれば拡張ユークリッドの互助法で求められる.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mspace width="0.222em"></mspace><mi>a</mi><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(log \: am)</annotation></semantics></math> ※最悪の場合. 平均はかなり早いはず.</p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// a and m must be co-prime.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">mod_inv</span>(<span class="dt">long</span> a, <span class="dt">long</span> m){
    <span class="kw">return</span> (a == <span class="dv">1</span> ? <span class="dv">1</span> : (<span class="dv">1</span> - m*<span class="fu">mod_inv</span>(m%a, a)) / a + m);
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>する予定</p>
<h2 id="ChineseRemainder"><span class="header-section-number">5.5</span> 中国剰余定理</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.278em"></mspace><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \; = \; a_i \; (mod \; m_i)</annotation></semantics></math> という条件から, 条件を満たす <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.278em"></mspace><mo>∏</mo><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \; (mod \; \prod m_i )</annotation></semantics></math> を求める.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>条</mi><mi>件</mi><mi>の</mi><mi>数</mi><mo>*</mo><mi>l</mi><mi>o</mi><mi>g</mi><mspace width="0.278em"></mspace><mo>∑</mo><mspace width="0.278em"></mspace><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(条件の数 * log \; \sum \; m_i)</annotation></semantics></math> ※計算量よりオーバーフローに気をつけること</p>
<h3 id="dependence" class="unnumbered">依存</h3>
<ul>
<li><p><a href="./library-sc.html#InvModM">逆元 (mod m) </a></p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">//Gauss の方法で求める. 返り値の値の mod を取らないので O(N) くらい</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">chinese_remainder</span>(<span class="dt">long</span>[] as, <span class="dt">long</span>[] ms){
    <span class="dt">long</span> prod = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">long</span> m : ms){ prod *= m; }

    <span class="dt">long</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ms.<span class="fu">length</span>; i++){
        <span class="dt">final</span> <span class="dt">long</span> M = prod / ms[i];
        <span class="dt">final</span> <span class="dt">long</span> inv = <span class="fu">mod_inv</span>(M % ms[i], ms[i]);

        <span class="dt">long</span> a = as[i] - as[i] / prod * prod;
        <span class="kw">if</span>(a &lt; <span class="dv">0</span>){ a += prod; }

        ret = (ret + M * inv * a % prod) % prod;
    }

    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>する予定</p>
<h2 id="EulerPhiFunction"><span class="header-section-number">5.6</span> オイラーのφ関数</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mspace width="0.222em"></mspace><mo>=</mo><mspace width="0.222em"></mspace><mn>1</mn><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.222em"></mspace><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^{\phi(m)} \: = \: 1 \: (mod \: m)</annotation></semantics></math> となる <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi(m)</annotation></semantics></math> を計算する.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><msqrt><mi>m</mi></msqrt><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{m})</annotation></semantics></math></p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// φ(n) = n (1 - 1/p1) ... (1 - 1/pm) (pkはnの素因数) より</span>
<span class="co">// 初項から一つづつ展開する -&gt; n -= n / pk を行う事になる.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">eulerPhiFunction</span>(<span class="dt">long</span> n) {
    <span class="dt">long</span> phi = n;
    <span class="kw">for</span>(<span class="dt">long</span> p = <span class="dv">2</span>; p * p &lt;= n; p++){
        <span class="kw">if</span>(n % p == <span class="dv">0</span>){
            phi -= phi / p;
            <span class="kw">while</span>(n % p == <span class="dv">0</span>){ n /= p; }
        }
    }
    <span class="kw">if</span>(n &gt; <span class="dv">1</span>){ phi -= phi / n; }

    <span class="kw">return</span> phi;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>する予定</p>
<h2 id="EnumEulerPhiFunction"><span class="header-section-number">5.7</span> オイラーのφ関数(列挙)</h2>
<p>1 〜 n までのオイラーのφ関数を列挙する.</p>
<h3 id="ux8a08ux7b97ux91cf" class="unnumbered">計算量</h3>
<p>O(n)</p>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">//</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span>[] <span class="fu">eulerPhiFunction</span>(<span class="dt">int</span> n) { <span class="co">// [0, n]</span>
    <span class="dt">boolean</span>[] is_prime = <span class="kw">new</span> <span class="dt">boolean</span>[n + <span class="dv">1</span>];
    <span class="dt">long</span>[] phis = <span class="kw">new</span> <span class="dt">long</span>[n + <span class="dv">1</span>];
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= n; i++){
        is_prime[i] = <span class="kw">true</span>;
        phis[i] = i;
    }
    is_prime[<span class="dv">0</span>] = is_prime[<span class="dv">1</span>] = <span class="kw">false</span>;

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; i++){
        <span class="kw">if</span>(is_prime[i]){
            phis[i] -= phis[i] / i;
            <span class="kw">for</span>(<span class="dt">int</span> j = i * <span class="dv">2</span>; j &lt;= n; j += i){
                is_prime[j] = <span class="kw">false</span>;    
                phis[j] -= phis[j] / i;
            }
        }
    }

    <span class="kw">return</span> phis;
}</code></pre></div>
<h3 id="verified-1" class="unnumbered">Verified</h3>
<p>する予定</p>
<h2 id="CarmichaelLambdaFunction"><span class="header-section-number">5.8</span> カーマイケルのλ関数</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>λ</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mspace width="0.222em"></mspace><mo>=</mo><mspace width="0.222em"></mspace><mn>1</mn><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.222em"></mspace><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^{\lambda(m)} \: = \: 1 \: (mod \: m)</annotation></semantics></math> となる <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lambda(m)</annotation></semantics></math> を計算する.<br />
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lambda(m)</annotation></semantics></math> は, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mspace width="0.222em"></mspace><mo>=</mo><mspace width="0.222em"></mspace><mn>1</mn><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.278em"></mspace><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^n \: = \: 1 \: (mod \; m)</annotation></semantics></math> となる最小の n である.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// λ(2^k) = 1 (k == 1), 2 (k == 2), 2^(k - 2) (k &gt;= 3)</span>
<span class="co">// λ(p^k) = p^(k-1) * (p - 1) ... (p=奇素数の時)</span>
<span class="co">// λ(p1^k1...pn^kn) = lcm(λ(p1^k1), ... λ(pn^kn))</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">carmichaelLambdaFunction</span>(<span class="dt">long</span> n) {
    <span class="dt">long</span> lambda = <span class="dv">1</span>;
    <span class="kw">if</span>(n % <span class="dv">8</span> == <span class="dv">0</span>){ n /= <span class="dv">2</span>; } <span class="co">// 2^(k-2)になる時は, 先に2で割って奇素数(k-1乗)と同じにする.</span>
    <span class="kw">for</span>(<span class="dt">int</span> p = <span class="dv">2</span>; p &lt;= n; p++){
        <span class="kw">if</span>(n % p == <span class="dv">0</span>){
            <span class="dt">long</span> l = p - <span class="dv">1</span>; <span class="co">// (p-1)部分を先に代入しとく. (2^k でも 1 になるので無問題)</span>
            n /= p; <span class="kw">while</span>(n % p == <span class="dv">0</span>){ n /= p; l *= p; } <span class="co">// (k-1)乗する.</span>
            lambda = <span class="fu">lcm</span>(lambda, l);
        }
    }
    <span class="kw">return</span> lambda;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<p>する予定</p>
<h1 id="dimrealgeometry"><span class="header-section-number">6</span> 2DimRealGeometry</h1>
<h2 id="TwoDimBasis"><span class="header-section-number">6.1</span> 基本データ構造</h2>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> Point2D {
    <span class="kw">public</span> <span class="dt">double</span> x;
    <span class="kw">public</span> <span class="dt">double</span> y;

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">double</span> EPS = <span class="fl">1e-9</span>;

    <span class="kw">public</span> Point2D(<span class="dt">double</span> x, <span class="dt">double</span> y) {
        <span class="kw">this</span>.<span class="fu">x</span> = x;
        <span class="kw">this</span>.<span class="fu">y</span> = y;
    }

    <span class="kw">public</span> Point2D(Point2D point) {
        <span class="kw">this</span>.<span class="fu">x</span> = point.<span class="fu">x</span>;
        <span class="kw">this</span>.<span class="fu">y</span> = point.<span class="fu">y</span>;
    }

    <span class="kw">public</span> String <span class="fu">toString</span>() {
        <span class="kw">return</span> x + <span class="st">&quot;,&quot;</span> + y;
    }

    <span class="fu">@Override</span>
    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">equals</span>(Object o) {
        <span class="kw">if</span> (o <span class="kw">instanceof</span> Point2D) {
            Point2D another = (Point2D) o;
            
            <span class="kw">if</span>(Point2D.<span class="fu">eq</span>(<span class="kw">this</span>.<span class="fu">x</span>, another.<span class="fu">x</span>) &amp;&amp; Point2D.<span class="fu">eq</span>(<span class="kw">this</span>.<span class="fu">y</span>, another.<span class="fu">y</span>)){
                <span class="kw">return</span> <span class="kw">true</span>;
            }
            
            <span class="kw">return</span> <span class="kw">false</span>;
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }

    <span class="kw">public</span> Point2D <span class="fu">add</span>(<span class="dt">double</span> x, <span class="dt">double</span> y) {
        <span class="kw">return</span> <span class="kw">new</span> Point2D(<span class="kw">this</span>.<span class="fu">x</span> + x, <span class="kw">this</span>.<span class="fu">y</span> + y);
    }

    <span class="kw">public</span> Point2D <span class="fu">sub</span>(<span class="dt">double</span> x, <span class="dt">double</span> y) {
        <span class="kw">return</span> <span class="fu">add</span>(-x, -y);
    }

    <span class="kw">public</span> Point2D <span class="fu">add</span>(Point2D another) {
        <span class="kw">return</span> <span class="fu">add</span>(another.<span class="fu">x</span>, another.<span class="fu">y</span>);
    }

    <span class="kw">public</span> Point2D <span class="fu">sub</span>(Point2D another) {
        <span class="kw">return</span> <span class="fu">sub</span>(another.<span class="fu">x</span>, another.<span class="fu">y</span>);
    }

    <span class="kw">public</span> Point2D <span class="fu">mul</span>(<span class="dt">double</span> d) {
        <span class="kw">return</span> <span class="kw">new</span> Point2D(<span class="kw">this</span>.<span class="fu">x</span> * d, <span class="kw">this</span>.<span class="fu">y</span> * d);
    }

    <span class="kw">public</span> Point2D <span class="fu">div</span>(<span class="dt">double</span> d) {
        <span class="kw">return</span> <span class="kw">new</span> Point2D(<span class="kw">this</span>.<span class="fu">x</span> / d, <span class="kw">this</span>.<span class="fu">y</span> / d);
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">dot</span>(<span class="dt">double</span> x, <span class="dt">double</span> y) {
        <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">x</span> * x + <span class="kw">this</span>.<span class="fu">y</span> * y;
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">dot</span>(Point2D another) {
        <span class="kw">return</span> <span class="fu">dot</span>(another.<span class="fu">x</span>, another.<span class="fu">y</span>);
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">cross</span>(<span class="dt">double</span> x, <span class="dt">double</span> y) {
        <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">x</span> * y - <span class="kw">this</span>.<span class="fu">y</span> * x;
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">cross</span>(Point2D another) {
        <span class="kw">return</span> <span class="fu">cross</span>(another.<span class="fu">x</span>, another.<span class="fu">y</span>);
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">dist</span>(<span class="dt">double</span> x, <span class="dt">double</span> y) {
        <span class="kw">return</span> Math.<span class="fu">sqrt</span>((<span class="kw">this</span>.<span class="fu">x</span> - x) * (<span class="kw">this</span>.<span class="fu">x</span> - x) + (<span class="kw">this</span>.<span class="fu">y</span> - y)
                * (<span class="kw">this</span>.<span class="fu">y</span> - y));
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">dist</span>(Point2D another) {
        <span class="kw">return</span> <span class="fu">dist</span>(another.<span class="fu">x</span>, another.<span class="fu">y</span>);
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">dist_o</span>() {
        <span class="kw">return</span> <span class="fu">dist</span>(<span class="dv">0</span>, <span class="dv">0</span>);
    }

    <span class="kw">public</span> Point2D <span class="fu">unit</span>() {
        <span class="kw">return</span> <span class="fu">div</span>(<span class="fu">dist_o</span>());
    }

    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">pol</span>(Point2D start, Point2D end) {
        <span class="kw">return</span> end.<span class="fu">sub</span>(start).<span class="fu">cross</span>(<span class="kw">this</span>.<span class="fu">sub</span>(start)) &lt; EPS;
    }

    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">pos</span>(Point2D start, Point2D end) {
        <span class="kw">return</span> (start.<span class="fu">dist</span>(<span class="kw">this</span>) + <span class="kw">this</span>.<span class="fu">dist</span>(end) &lt; start.<span class="fu">dist</span>(end) + EPS);
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">pld</span>(Point2D start, Point2D end) {
        <span class="kw">return</span> Math.<span class="fu">abs</span>((end.<span class="fu">sub</span>(start).<span class="fu">cross</span>(<span class="kw">this</span>.<span class="fu">sub</span>(start)))
                / end.<span class="fu">sub</span>(start).<span class="fu">dist_o</span>());
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">psd</span>(Point2D start, Point2D end) {
        <span class="kw">if</span> (end.<span class="fu">sub</span>(start).<span class="fu">dot</span>(<span class="kw">this</span>.<span class="fu">sub</span>(start)) &lt; EPS) {
            <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">dist</span>(start);
        } <span class="kw">else</span> <span class="kw">if</span> (start.<span class="fu">sub</span>(end).<span class="fu">dot</span>(<span class="kw">this</span>.<span class="fu">sub</span>(end)) &lt; EPS) {
            <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">dist</span>(end);
        } <span class="kw">else</span> {
            <span class="kw">return</span> Math.<span class="fu">abs</span>(end.<span class="fu">sub</span>(start).<span class="fu">cross</span>(<span class="kw">this</span>.<span class="fu">sub</span>(start)) / end.<span class="fu">dist</span>(start));
        }
    }
    
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">signum</span>(<span class="dt">double</span> x){
        <span class="kw">return</span> Math.<span class="fu">abs</span>(x) &lt; EPS ? <span class="dv">0</span> : x &gt; <span class="dv">0</span> ? <span class="dv">1</span> : -<span class="dv">1</span>;
    }
    
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">eq</span>(<span class="dt">double</span> x, <span class="dt">double</span> y){
        <span class="kw">return</span> <span class="fu">signum</span>(x - y) == <span class="dv">0</span>;
    }
    
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">ccw</span>(Point2D p, Point2D r, Point2D s){
        Point2D a = r.<span class="fu">sub</span>(p);
        Point2D b = s.<span class="fu">sub</span>(p);
        
        <span class="dt">final</span> <span class="dt">int</span> sgn = Point2D.<span class="fu">signum</span>(a.<span class="fu">cross</span>(b));
        <span class="kw">if</span>(sgn != <span class="dv">0</span>){
            <span class="kw">return</span> sgn;
        }<span class="kw">else</span> <span class="kw">if</span>(a.<span class="fu">x</span> * b.<span class="fu">x</span> &lt; -EPS &amp;&amp; a.<span class="fu">y</span> * b.<span class="fu">y</span> &lt; -EPS){
            <span class="kw">return</span> -<span class="dv">1</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a.<span class="fu">dist_o</span>() &lt; b.<span class="fu">dist_o</span>() - EPS){
            <span class="kw">return</span> <span class="dv">1</span>;
        }<span class="kw">else</span>{
            <span class="kw">return</span> <span class="dv">0</span>;
        }
    }
    
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">intersect_s</span>(Point2D a1, Point2D a2, Point2D b1,
            Point2D b2) {
        <span class="kw">return</span> (Point2D.<span class="fu">ccw</span>(a1, a2, b1) * Point2D.<span class="fu">ccw</span>(a1, a2, b2) &lt;= <span class="dv">0</span>)
                &amp;&amp; (Point2D.<span class="fu">ccw</span>(b1, b2, a1) * Point2D.<span class="fu">ccw</span>(b1, b2, a2) &lt;= <span class="dv">0</span>);
    }

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">insersect_l</span>(Point2D a1, Point2D a2, Point2D b1,
            Point2D b2) {
        <span class="kw">return</span> a1.<span class="fu">sub</span>(a2).<span class="fu">cross</span>(b1.<span class="fu">sub</span>(b2)) &lt; EPS;
    }

    <span class="kw">public</span> <span class="dt">static</span> Point2D <span class="fu">interpoint_s</span>(Point2D a1, Point2D a2, Point2D b1,
            Point2D b2) {
        Point2D b = b2.<span class="fu">sub</span>(b1);
        <span class="dt">double</span> d1 = Math.<span class="fu">abs</span>(b.<span class="fu">cross</span>(a1.<span class="fu">sub</span>(b1)));
        <span class="dt">double</span> d2 = Math.<span class="fu">abs</span>(b.<span class="fu">cross</span>(a2.<span class="fu">sub</span>(b1)));
        <span class="dt">double</span> t = d1 / (d1 + d2);
        Point2D a = a2.<span class="fu">sub</span>(a1), v = a.<span class="fu">mul</span>(t);
        <span class="kw">return</span> a1.<span class="fu">add</span>(v);
    }

    <span class="kw">public</span> <span class="dt">static</span> Point2D <span class="fu">interpoint_l</span>(Point2D a1, Point2D a2, Point2D b1,
            Point2D b2) {
        Point2D a = a2.<span class="fu">sub</span>(a1);
        Point2D b = b2.<span class="fu">sub</span>(b1);
        <span class="dt">double</span> t = b.<span class="fu">cross</span>(b1.<span class="fu">sub</span>(a1)) / b.<span class="fu">cross</span>(a);
        Point2D v = a.<span class="fu">mul</span>(t);
        <span class="kw">return</span> a1.<span class="fu">add</span>(v);
    }

    <span class="kw">public</span> <span class="dt">static</span> Point2D[] <span class="fu">cross_ss</span>(Point2D p1, <span class="dt">double</span> r1, Point2D p2,
            <span class="dt">double</span> r2) {
        <span class="dt">double</span> dis = p1.<span class="fu">dist</span>(p2);

        <span class="kw">if</span> (r1 + EPS &gt; r2 &amp;&amp; r1 - EPS &lt; r2 &amp;&amp; dis &lt; EPS) {
            <span class="kw">return</span> <span class="kw">new</span> Point2D[<span class="dv">0</span>]; <span class="co">// same</span>
        }

        <span class="kw">if</span> (dis - EPS &lt; r1 + r2 &amp;&amp; dis + EPS &gt; r1 + r2) {
            Point2D tmp = p2.<span class="fu">sub</span>(p1);
            tmp = tmp.<span class="fu">mul</span>(r1 / tmp.<span class="fu">dist_o</span>());
            Point2D ret[] = <span class="kw">new</span> Point2D[<span class="dv">1</span>];
            ret[<span class="dv">0</span>] = p1.<span class="fu">add</span>(tmp);
            <span class="kw">return</span> ret;
        } <span class="kw">else</span> <span class="kw">if</span> (dis + EPS &gt; r1 + r2) {
            <span class="kw">return</span> <span class="kw">new</span> Point2D[<span class="dv">0</span>]; <span class="co">// out</span>
        }

        <span class="dt">double</span> dis_m = Math.<span class="fu">abs</span>(r1 - r2);

        <span class="kw">if</span> (dis_m + EPS &gt; dis &amp;&amp; dis_m - EPS &lt; dis) {
            Point2D tmp = <span class="kw">null</span>;
            <span class="kw">if</span> (r1 &gt; r2) {
                tmp = p2.<span class="fu">sub</span>(p1);
            } <span class="kw">else</span> {
                tmp = p1.<span class="fu">sub</span>(p2);
            }

            <span class="dt">double</span> min = Math.<span class="fu">min</span>(r1, r2);

            tmp = tmp.<span class="fu">mul</span>((min + tmp.<span class="fu">dist_o</span>()) / tmp.<span class="fu">dist_o</span>());

            Point2D ret[] = <span class="kw">new</span> Point2D[<span class="dv">1</span>];
            ret[<span class="dv">0</span>] = p1.<span class="fu">add</span>(tmp);
            <span class="kw">return</span> ret;
        } <span class="kw">else</span> <span class="kw">if</span> (dis_m + EPS &gt; dis) {
            <span class="kw">return</span> <span class="kw">new</span> Point2D[<span class="dv">0</span>]; <span class="co">// inner</span>
        } <span class="kw">else</span> {
            Point2D ret[] = <span class="kw">new</span> Point2D[<span class="dv">2</span>];

            <span class="dt">double</span> theta = Math.<span class="fu">acos</span>((dis * dis + r1 * r1 - r2 * r2)
                    / (<span class="dv">2</span> * dis * r1));
            <span class="dt">double</span> a = Math.<span class="fu">atan2</span>(p2.<span class="fu">y</span> - p1.<span class="fu">y</span>, p2.<span class="fu">x</span> - p1.<span class="fu">x</span>);

            ret[<span class="dv">0</span>] = <span class="kw">new</span> Point2D(r1 * Math.<span class="fu">cos</span>(a + theta) + p1.<span class="fu">x</span>, r1
                    * Math.<span class="fu">sin</span>(a + theta) + p1.<span class="fu">y</span>);
            ret[<span class="dv">1</span>] = <span class="kw">new</span> Point2D(r1 * Math.<span class="fu">cos</span>(a - theta) + p1.<span class="fu">x</span>, r1
                    * Math.<span class="fu">sin</span>(a - theta) + p1.<span class="fu">y</span>);
            <span class="kw">return</span> ret;
        }
    }
    
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">double</span> <span class="fu">ss_dist</span>(Point2D start1, Point2D end1, Point2D start2, Point2D end2){
        <span class="kw">if</span>(Point2D.<span class="fu">intersect_s</span>(start1, end1, start2, end2)){
            <span class="kw">return</span> <span class="dv">0</span>;
        }<span class="kw">else</span>{
            <span class="kw">return</span> Math.<span class="fu">min</span>(Math.<span class="fu">min</span>(Math.<span class="fu">min</span>(start1.<span class="fu">psd</span>(start2, end2), end1.<span class="fu">psd</span>(start2, end2)), start2.<span class="fu">psd</span>(start1, end1)), end2.<span class="fu">psd</span>(start1, end1));
        }
    }
    
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">interpoint_lc</span>(Point2D start, Point2D end, Point2D c, <span class="dt">double</span> r,
            Point2D ans[]) {
        <span class="kw">if</span> (c.<span class="fu">pld</span>(start, end) &gt; r + EPS)
            <span class="kw">return</span>;
        Point2D v = end.<span class="fu">sub</span>(start).<span class="fu">unit</span>();
        <span class="dt">double</span> delta = v.<span class="fu">dot</span>(start.<span class="fu">sub</span>(c)) * v.<span class="fu">dot</span>(start.<span class="fu">sub</span>(c))
                - start.<span class="fu">dist</span>(c) * start.<span class="fu">dist</span>(c) + r * r;
        <span class="dt">double</span> t = -v.<span class="fu">dot</span>(start.<span class="fu">sub</span>(c));
        <span class="dt">double</span> s = Math.<span class="fu">sqrt</span>(delta);
        ans[<span class="dv">0</span>] = start.<span class="fu">add</span>(v.<span class="fu">mul</span>(t + s));
        ans[<span class="dv">1</span>] = start.<span class="fu">add</span>(v.<span class="fu">mul</span>(t + s));
    }

    <span class="kw">public</span> Point2D <span class="fu">normal_vector</span>(Point2D p, Point2D a, Point2D b) {
        Point2D v = b.<span class="fu">sub</span>(a).<span class="fu">unit</span>();
        v = v.<span class="fu">cross</span>(p.<span class="fu">sub</span>(a)) &gt; <span class="dv">0</span> ? <span class="kw">new</span> Point2D(v.<span class="fu">y</span>, (-<span class="dv">1</span>) * v.<span class="fu">x</span>) : <span class="kw">new</span> Point2D(
                (-<span class="dv">1</span>) * v.<span class="fu">y</span>, v.<span class="fu">x</span>);
        <span class="kw">return</span> v.<span class="fu">mul</span>(p.<span class="fu">pld</span>(a, b));
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">area</span>(Point2D a, Point2D b, Point2D c) {
        <span class="kw">return</span> Math.<span class="fu">abs</span>((c.<span class="fu">sub</span>(a).<span class="fu">cross</span>(b.<span class="fu">sub</span>(a))) * <span class="fl">0.5</span>);
    }
}</code></pre></div>
<h1 id="dimintgeometry"><span class="header-section-number">7</span> 2DimIntGeometry</h1>
<h2 id="TwoIntDimPoint"><span class="header-section-number">7.1</span> 2次元の点</h2>
<h3 id="dependence" class="unnumbered">依存</h3>
<ul>
<li><p><a href="./library-sc.html#Rational">有理数 </a> or <a href="./library-sc.html#BigRational">多倍長有理数 </a></p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> Point2D <span class="kw">implements</span> Comparable&lt;Point2D&gt;{
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> Point2D NaN = <span class="kw">new</span> Point2D(Rational.<span class="fu">NaN</span>, Rational.<span class="fu">NaN</span>);
    
    <span class="kw">private</span> Rational x, y;
    
    <span class="kw">public</span> Point2D(Rational x, Rational y){
        <span class="fu">assert</span>(x != <span class="kw">null</span> &amp;&amp; y != <span class="kw">null</span>); <span class="co">// nullを入れたら殺す!</span>
        <span class="kw">this</span>.<span class="fu">x</span> = x; <span class="kw">this</span>.<span class="fu">y</span> = y;
    }
    
    <span class="kw">public</span> Rational <span class="fu">get_x</span>(){ <span class="kw">return</span> x; }
    <span class="kw">public</span> Rational <span class="fu">get_y</span>(){ <span class="kw">return</span> y; }
    <span class="kw">public</span> Rational <span class="fu">norm</span>(){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">x</span>.<span class="fu">pow</span>(<span class="dv">2</span>).<span class="fu">add</span>(<span class="kw">this</span>.<span class="fu">y</span>.<span class="fu">pow</span>(<span class="dv">2</span>)); }
    
    <span class="kw">public</span> Point2D <span class="fu">add</span>(Point2D o){<span class="kw">return</span> <span class="kw">new</span> Point2D(x.<span class="fu">add</span>(o.<span class="fu">x</span>),y.<span class="fu">add</span>(o.<span class="fu">y</span>)); }
    <span class="kw">public</span> Point2D <span class="fu">sub</span>(Point2D o){<span class="kw">return</span> <span class="kw">new</span> Point2D(x.<span class="fu">sub</span>(o.<span class="fu">x</span>),y.<span class="fu">sub</span>(o.<span class="fu">y</span>)); }
    <span class="kw">public</span> Point2D <span class="fu">mul</span>(Rational r){ <span class="kw">return</span> <span class="kw">new</span> Point2D(x.<span class="fu">mul</span>(r), y.<span class="fu">mul</span>(r)); }
    <span class="kw">public</span> Point2D <span class="fu">div</span>(Rational r){ <span class="kw">return</span> <span class="kw">new</span> Point2D(x.<span class="fu">div</span>(r), y.<span class="fu">div</span>(r)); }
    
    <span class="kw">public</span> Rational <span class="fu">dot</span>(Point2D o)  { <span class="kw">return</span> x.<span class="fu">mul</span>(o.<span class="fu">x</span>).<span class="fu">add</span>(y.<span class="fu">mul</span>(o.<span class="fu">y</span>)); }
    <span class="kw">public</span> Rational <span class="fu">cross</span>(Point2D o){ <span class="kw">return</span> x.<span class="fu">mul</span>(o.<span class="fu">y</span>).<span class="fu">sub</span>(y.<span class="fu">mul</span>(o.<span class="fu">x</span>)); }
    <span class="kw">public</span> Rational <span class="fu">dist</span>(Point2D o) { <span class="kw">return</span> o.<span class="fu">sub</span>(<span class="kw">this</span>).<span class="fu">norm</span>(); }
    
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">ccw</span>(Point2D r, Point2D s){
        <span class="dt">final</span> Point2D a = r.<span class="fu">sub</span>(<span class="kw">this</span>), b = s.<span class="fu">sub</span>(<span class="kw">this</span>);
        <span class="dt">final</span> <span class="dt">long</span> sign = a.<span class="fu">cross</span>(b).<span class="fu">sign</span>();
        
        <span class="kw">if</span>(sign != <span class="dv">0</span>){ <span class="kw">return</span> sign;
        }<span class="kw">else</span> <span class="kw">if</span>(a.<span class="fu">x</span>.<span class="fu">mul</span>(b.<span class="fu">x</span>).<span class="fu">sign</span>() &lt; <span class="dv">0</span> || a.<span class="fu">y</span>.<span class="fu">mul</span>(b.<span class="fu">y</span>).<span class="fu">sign</span>() &lt; <span class="dv">0</span>){
            <span class="kw">return</span> -<span class="dv">1</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a.<span class="fu">norm</span>().<span class="fu">compareTo</span>(b.<span class="fu">norm</span>()) &lt; <span class="dv">0</span>){
            <span class="kw">return</span> <span class="dv">1</span>;
        }<span class="kw">else</span>{ <span class="kw">return</span> <span class="dv">0</span>; }
    }
    
    <span class="fu">@Override</span>
    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">equals</span>(Object obj) { <span class="co">//必要ならHashCodeも生成する事</span>
        <span class="kw">if</span>(!(obj <span class="kw">instanceof</span> Point2D)){ <span class="kw">return</span> <span class="kw">false</span>; }
        Point2D o = (Point2D) obj;
        <span class="kw">if</span>(!<span class="kw">this</span>.<span class="fu">x</span>.<span class="fu">equals</span>(o.<span class="fu">x</span>) || !<span class="kw">this</span>.<span class="fu">y</span>.<span class="fu">equals</span>(o.<span class="fu">y</span>)){ <span class="kw">return</span> <span class="kw">false</span>; }
        <span class="kw">return</span> <span class="kw">true</span>;
    }

    <span class="fu">@Override</span>
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span>(Point2D o) {
        <span class="kw">if</span>(<span class="kw">this</span>.<span class="fu">x</span>.<span class="fu">compareTo</span>(o.<span class="fu">x</span>) != <span class="dv">0</span>){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">x</span>.<span class="fu">compareTo</span>(o.<span class="fu">x</span>); }
        <span class="kw">else</span> <span class="kw">if</span>(<span class="kw">this</span>.<span class="fu">y</span>.<span class="fu">compareTo</span>(o.<span class="fu">y</span>) != <span class="dv">0</span>){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">y</span>.<span class="fu">compareTo</span>(o.<span class="fu">y</span>); }
        <span class="kw">else</span> { <span class="kw">return</span> <span class="dv">0</span>; }
    }
}</code></pre></div>
<h2 id="TwoIntDimPoint"><span class="header-section-number">7.2</span> 2次元の点</h2>
<h3 id="dependence" class="unnumbered">依存</h3>
<ul>
<li><p><a href="./library-sc.html#Rational">有理数 </a> or <a href="./library-sc.html#BigRational">多倍長有理数 </a></p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> Point2D <span class="kw">implements</span> Comparable&lt;Point2D&gt;{
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span> Point2D NaN = <span class="kw">new</span> Point2D(Rational.<span class="fu">NaN</span>, Rational.<span class="fu">NaN</span>);
    
    <span class="kw">private</span> Rational x, y;
    
    <span class="kw">public</span> Point2D(Rational x, Rational y){
        <span class="fu">assert</span>(x != <span class="kw">null</span> &amp;&amp; y != <span class="kw">null</span>); <span class="co">// nullを入れたら殺す!</span>
        <span class="kw">this</span>.<span class="fu">x</span> = x; <span class="kw">this</span>.<span class="fu">y</span> = y;
    }
    
    <span class="kw">public</span> Rational <span class="fu">get_x</span>(){ <span class="kw">return</span> x; }
    <span class="kw">public</span> Rational <span class="fu">get_y</span>(){ <span class="kw">return</span> y; }
    <span class="kw">public</span> Rational <span class="fu">norm</span>(){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">x</span>.<span class="fu">pow</span>(<span class="dv">2</span>).<span class="fu">add</span>(<span class="kw">this</span>.<span class="fu">y</span>.<span class="fu">pow</span>(<span class="dv">2</span>)); }
    
    <span class="kw">public</span> Point2D <span class="fu">add</span>(Point2D o){<span class="kw">return</span> <span class="kw">new</span> Point2D(x.<span class="fu">add</span>(o.<span class="fu">x</span>),y.<span class="fu">add</span>(o.<span class="fu">y</span>)); }
    <span class="kw">public</span> Point2D <span class="fu">sub</span>(Point2D o){<span class="kw">return</span> <span class="kw">new</span> Point2D(x.<span class="fu">sub</span>(o.<span class="fu">x</span>),y.<span class="fu">sub</span>(o.<span class="fu">y</span>)); }
    <span class="kw">public</span> Point2D <span class="fu">mul</span>(Rational r){ <span class="kw">return</span> <span class="kw">new</span> Point2D(x.<span class="fu">mul</span>(r), y.<span class="fu">mul</span>(r)); }
    <span class="kw">public</span> Point2D <span class="fu">div</span>(Rational r){ <span class="kw">return</span> <span class="kw">new</span> Point2D(x.<span class="fu">div</span>(r), y.<span class="fu">div</span>(r)); }
    
    <span class="kw">public</span> Rational <span class="fu">dot</span>(Point2D o)  { <span class="kw">return</span> x.<span class="fu">mul</span>(o.<span class="fu">x</span>).<span class="fu">add</span>(y.<span class="fu">mul</span>(o.<span class="fu">y</span>)); }
    <span class="kw">public</span> Rational <span class="fu">cross</span>(Point2D o){ <span class="kw">return</span> x.<span class="fu">mul</span>(o.<span class="fu">y</span>).<span class="fu">sub</span>(y.<span class="fu">mul</span>(o.<span class="fu">x</span>)); }
    <span class="kw">public</span> Rational <span class="fu">dist</span>(Point2D o) { <span class="kw">return</span> o.<span class="fu">sub</span>(<span class="kw">this</span>).<span class="fu">norm</span>(); }
    
    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">ccw</span>(Point2D r, Point2D s){
        <span class="dt">final</span> Point2D a = r.<span class="fu">sub</span>(<span class="kw">this</span>), b = s.<span class="fu">sub</span>(<span class="kw">this</span>);
        <span class="dt">final</span> <span class="dt">long</span> sign = a.<span class="fu">cross</span>(b).<span class="fu">sign</span>();
        
        <span class="kw">if</span>(sign != <span class="dv">0</span>){ <span class="kw">return</span> sign;
        }<span class="kw">else</span> <span class="kw">if</span>(a.<span class="fu">x</span>.<span class="fu">mul</span>(b.<span class="fu">x</span>).<span class="fu">sign</span>() &lt; <span class="dv">0</span> || a.<span class="fu">y</span>.<span class="fu">mul</span>(b.<span class="fu">y</span>).<span class="fu">sign</span>() &lt; <span class="dv">0</span>){
            <span class="kw">return</span> -<span class="dv">1</span>;
        }<span class="kw">else</span> <span class="kw">if</span>(a.<span class="fu">norm</span>().<span class="fu">compareTo</span>(b.<span class="fu">norm</span>()) &lt; <span class="dv">0</span>){
            <span class="kw">return</span> <span class="dv">1</span>;
        }<span class="kw">else</span>{ <span class="kw">return</span> <span class="dv">0</span>; }
    }
    
    <span class="fu">@Override</span>
    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">equals</span>(Object obj) { <span class="co">//必要ならHashCodeも生成する事</span>
        <span class="kw">if</span>(!(obj <span class="kw">instanceof</span> Point2D)){ <span class="kw">return</span> <span class="kw">false</span>; }
        Point2D o = (Point2D) obj;
        <span class="kw">if</span>(!<span class="kw">this</span>.<span class="fu">x</span>.<span class="fu">equals</span>(o.<span class="fu">x</span>) || !<span class="kw">this</span>.<span class="fu">y</span>.<span class="fu">equals</span>(o.<span class="fu">y</span>)){ <span class="kw">return</span> <span class="kw">false</span>; }
        <span class="kw">return</span> <span class="kw">true</span>;
    }

    <span class="fu">@Override</span>
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span>(Point2D o) {
        <span class="kw">if</span>(<span class="kw">this</span>.<span class="fu">x</span>.<span class="fu">compareTo</span>(o.<span class="fu">x</span>) != <span class="dv">0</span>){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">x</span>.<span class="fu">compareTo</span>(o.<span class="fu">x</span>); }
        <span class="kw">else</span> <span class="kw">if</span>(<span class="kw">this</span>.<span class="fu">y</span>.<span class="fu">compareTo</span>(o.<span class="fu">y</span>) != <span class="dv">0</span>){ <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">y</span>.<span class="fu">compareTo</span>(o.<span class="fu">y</span>); }
        <span class="kw">else</span> { <span class="kw">return</span> <span class="dv">0</span>; }
    }
}</code></pre></div>
<h1 id="string"><span class="header-section-number">8</span> String</h1>
<h2 id="ShiftAnd"><span class="header-section-number">8.1</span> Shift And</h2>
<p>短いパターン文字列をbit演算を使って高速に検索するアルゴリズム.</p>
<h3 id="ux4ed5ux7d44ux307f" class="unnumbered">仕組み</h3>
<p>探索状態をbitで全通り表現して高速に判定する. 状態のbit表現は, i番目の桁に“i番目まで一致しているか”というもの.</p>
<p>なぜbitで探索状態を表現するのかというと, 複数の探索状態をまとめて扱うためである. bitによって全通りの探索状態を表現しているならバックトラックをする必要がなくなる. このため, 効率的な探索を行う事が出来る.</p>
<p>また, パターンの文字毎の出現位置もbitで表す事で, 探索状態bitに対して bit演算だけで有り得る探索状態を抜き出せる.</p>
<p>なので, 現在の状態に対して, 1bit右シフト(次の文字も合致してる可能性があるため)と, 最下位bitを立てる(次の文字がパターンの開始文字である可能性があるため) を行ってから, 実際の次の文字の出現位置bitを使って, 実際の次の状態を抜き出している.</p>
<p>この <a href="http://videlalvaro.github.io/2014/01/shift-and-visualization.html">Shift-And Visualization</a> を見た方が 早い.</p>
<h3 id="ux8a08ux7b97ux91cf" class="unnumbered">計算量</h3>
<p>対象文字列の長さをn, パターンの長さをmとすると</p>
<ul>
<li><p>パターンのbit配列の構築 : O(m)</p></li>
<li><p>文字列検索 : O(n + m)</p></li>
</ul>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">//Mのbit幅 &gt;= パターンの文字列じゃないと死ぬ. 長いならBitSetを使おう.</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">shift_and</span>(String t, String p){ <span class="co">//pの長さはbit幅依存</span>
    <span class="dt">int</span>[] M = <span class="kw">new</span> <span class="dt">int</span>[Character.<span class="fu">MAX_VALUE</span>]; <span class="co">// alphabet全体分の長さが必要. </span>
    <span class="dt">int</span> count = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; p.<span class="fu">length</span>(); i++){
        M[p.<span class="fu">charAt</span>(i)] |= (<span class="dv">1</span> &lt;&lt; i);
    }
    
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>, S = <span class="dv">0</span>; i &lt; t.<span class="fu">length</span>(); i++){
        S = ((S &lt;&lt; <span class="dv">1</span>) | <span class="dv">1</span>) &amp; M[t.<span class="fu">charAt</span>(i)];
        
        <span class="kw">if</span>((S &amp; (<span class="dv">1</span> &lt;&lt; (p.<span class="fu">length</span>() - <span class="dv">1</span>))) != <span class="dv">0</span>){
            count++; <span class="co">// t[i - p.length() + 1, i] </span>
        }
    }
    
    <span class="kw">return</span> count;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="rollingux5fhash"><span class="header-section-number">8.2</span> Rolling Hash</h2>
<p>文字列をハッシュする関数. 部分文字列に対するハッシュを定数時間で行える. 文字列<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">s[0, n)</annotation></semantics></math> に対して</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo>+</mo><mi>s</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false" form="postfix">]</mo><mo>*</mo><mi>b</mi><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>s</mi><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo><mo>*</mo><msup><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false" form="postfix">)</mo><mspace width="0.278em"></mspace><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="0.278em"></mspace><mi>M</mi><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>M</mi><mi>は</mi><mi>互</mi><mi>い</mi><mi>に</mi><mi>素</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">hash(s) = (s[n-1] + s[n-2]*b + ... + s[0]*b^{n-1}) \; mod \; M \; (b, Mは互いに素)</annotation></semantics></math></p>
<h3 id="ux4f7fux3044ux65b9" class="unnumbered">使い方</h3>
<h4 id="ux90e8ux5206ux6587ux5b57ux5217ux306eux30cfux30c3ux30b7ux30e5" class="unnumbered">部分文字列のハッシュ</h4>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="prefix">[</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false" form="prefix">[</mo><mi>r</mi><mo stretchy="false" form="postfix">]</mo><mo>−</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false" form="prefix">[</mo><mi>l</mi><mo stretchy="false" form="postfix">]</mo><mo>*</mo><msup><mi>b</mi><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow></msup></mrow><annotation encoding="application/x-tex">hash(s[l, r)) = hash[r] - hash[l] * b^{r-l}</annotation></semantics></math></p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo stretchy="false" form="postfix">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mi>n</mi><mi>は</mi><mi>文</mi><mi>字</mi><mi>列</mi><mi>の</mi><mi>長</mi><mi>さ</mi></mrow><annotation encoding="application/x-tex">O(N) ... nは文字列の長さ</annotation></semantics></math></p>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">rolling_hash</span>(String s, <span class="dt">final</span> <span class="dt">long</span> b, <span class="dt">final</span> <span class="dt">long</span> m){
    <span class="dt">long</span> ret = 0l;
    <span class="kw">for</span>(<span class="dt">char</span> c : s.<span class="fu">toCharArray</span>()){
        ret *= b; ret %= m;
        ret += c; ret %= m;
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h1 id="puzzle"><span class="header-section-number">9</span> Puzzle</h1>
<h2 id="Nim"><span class="header-section-number">9.1</span> Nim(山N個, 制限無し)</h2>
<p>全てのxorを取る. 0だったら先手必負, それ以外なら先手必勝</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// 0枚で終わると負け(最後の一枚を取った人が勝ちの場合)</span>
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">Nim</span>(<span class="dt">long</span> <span class="kw">... </span>nim) {
    <span class="dt">long</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">final</span> <span class="dt">long</span> n : nim){ ret ^= n; }

    <span class="kw">return</span> ret != <span class="dv">0</span>;
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
<h2 id="misere-nim-ux5c71nux500b-ux5236ux9650ux306aux3057"><span class="header-section-number">9.2</span> Misere Nim (山N個, 制限なし)</h2>
<p>勝利条件が Nim と逆なゲーム.</p>
<p>Nim の数 に 1より大きいのがあれば, Nim の xor が 0 であると負ける. Nim の数 に 1以下しかなければ, Nim の xor が 1 であると負ける.</p>
<h2 id="Dice"><span class="header-section-number">9.3</span> サイコロ</h2>
<p>ICPC系の問題で頻出するサイコロの実装.</p>
<h3 id="complecity" class="unnumbered">計算量</h3>
<h3 id="source-code" class="unnumbered">Source Code</h3>
<div class="sourceCode" language="Java"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> Dice {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> MAX = <span class="dv">5</span>, SIZE = <span class="dv">7</span>;
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> TOP = <span class="dv">0</span>, FRONT = <span class="dv">1</span>, RIGHT = <span class="dv">2</span>;
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> BOTTOM = <span class="dv">5</span>, BACK = <span class="dv">4</span>, LEFT = <span class="dv">3</span>;

    <span class="dt">int</span>[] dice; <span class="co">// in [1, 2, 3, 4, 5, 6]</span>

    <span class="kw">public</span> <span class="fu">Dice</span>(<span class="dt">int</span> top, <span class="dt">int</span> front, <span class="dt">int</span> right, <span class="dt">int</span> sum) {
        dice = <span class="kw">new</span> <span class="dt">int</span>[MAX + <span class="dv">1</span>];
        dice[TOP] = top; dice[FRONT] = front; dice[RIGHT] = right;
        dice[BOTTOM] = sum - top; dice[BACK] = sum - front; dice[LEFT] = sum - right;
    }

    <span class="kw">public</span> <span class="fu">Dice</span>(<span class="dt">int</span> top, <span class="dt">int</span> front, <span class="dt">int</span> right) {
        <span class="kw">this</span>(top, front, right, SIZE);
    }

    <span class="co">// rotate_from は (top | front) から見てどの方向に転がるを指定すると転がしてくれる.</span>
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">rotate_from_top</span>(<span class="dt">final</span> <span class="dt">int</span> dir) { <span class="fu">rotate_dice</span>(TOP, dir, BOTTOM, MAX - dir); }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">rotate_from_front</span>(<span class="dt">final</span> <span class="dt">int</span> dir){ <span class="fu">rotate_dice</span>(FRONT, dir, BACK, MAX - dir); }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">rotate_dice</span>(<span class="dt">int</span><span class="kw">... </span>args) {
        <span class="dt">final</span> <span class="dt">int</span> tmp = dice[args[args.<span class="fu">length</span> - <span class="dv">1</span>]];
        <span class="kw">for</span> (<span class="dt">int</span> now = args.<span class="fu">length</span> - <span class="dv">1</span>; now &gt; <span class="dv">0</span>; now--) {
            dice[args[now]] = dice[args[now - <span class="dv">1</span>]];
        }

        dice[args[<span class="dv">0</span>]] = tmp;
    }
}</code></pre></div>
<h3 id="verified" class="unnumbered">Verified</h3>
    </div>
		<div id="FOOTER">
					</div>
	</body>
</html>

